{"meta":{"title":"双的鱼博客","subtitle":"想起那天夕陽下的奔跑，那是我逝去的青春","description":"双的鱼博客，记录我的学习和感想","author":"JIANG XIAOFAN","url":"https://shuangdeyu.github.io","root":"/"},"pages":[{"title":"about","date":"2023-12-19T06:22:44.000Z","updated":"2023-12-19T08:37:48.701Z","comments":true,"path":"about/index.html","permalink":"https://shuangdeyu.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2019-05-15T06:59:16.000Z","updated":"2023-12-19T06:09:44.701Z","comments":true,"path":"about/index-icarus.html","permalink":"https://shuangdeyu.github.io/about/index-icarus.html","excerpt":"","text":"我的作品goquery爬虫实践 使用goquery爬取豆瓣电影的实践案例 轻博客个人网站-go 使用go，gin框架实现的个人网站源码 小工具 实用的程序开发小工具集合 简易即时聊天室 基于workman的简易即时聊天室 极简类博客个人网站 用thinkphp5开发的极简风格个人网站"},{"title":"相册","date":"2019-05-19T15:35:47.000Z","updated":"2023-12-22T10:28:28.919Z","comments":true,"path":"album/index.html","permalink":"https://shuangdeyu.github.io/album/index.html","excerpt":"","text":"景 人"},{"title":"categories","date":"2019-05-15T16:28:04.000Z","updated":"2023-12-18T06:26:01.531Z","comments":false,"path":"categories/index.html","permalink":"https://shuangdeyu.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-05-15T16:26:16.000Z","updated":"2023-12-18T06:48:33.774Z","comments":false,"path":"tags/index.html","permalink":"https://shuangdeyu.github.io/tags/index.html","excerpt":"","text":""},{"title":"微博-闲言碎语","date":"2019-05-15T16:28:04.000Z","updated":"2024-04-19T05:48:54.697Z","comments":true,"path":"weibo/index.html","permalink":"https://shuangdeyu.github.io/weibo/index.html","excerpt":"","text":"中国汉字源远流长、博大精深、包罗万象，外国人学汉字的时候，应该很兴奋吧 没有经历过真的很难做到感同身受，就像现在才明白以前小的时候年纪比我们大的人总说的：“多读书，不然以后你会后悔的。” “我们都只是暂时的健全人” 为好故事买单 自闭症干预的宗旨其实就是帮助”走出舒适区“ 以前不懂生孩子的意义是什么，没有老一辈那种传宗接代的思想，一个人或者两个人生活岂不潇洒，快哉？直到我的孩子降世，我才明白生孩子的意义只有生了孩子才知道，没生之前，没有任何意义，这口头是无法表述的，但他就是有意义，很重要的意义 对我来说，家乡是从绿水青山，到钢筋水泥家庭住址可以有很多个，但家乡，只有一个无法轻易回去的才叫家乡 人存在的意义就是曾经存在过 数据库服务于功能需求和前端产品，以设计为主后台则服务于数据库，不需要有太多的设计，因为数据库都设计好了，只需要做好数据库数据的展示操作即可 你永远不会知道上一个写代码的人会给你留下什么坑 =_=! …… 贫穷是原罪，是一切矛盾的导火线 《阳神》是我看过的小说中最令人感到不自在的，书中角色几乎都是无情的存在，包括主角的阵营，九成以上人物都是靠利益和武力扭在一起的，甚至主角自身是书中最让我恶心的人物，他做任何事总能为自己找到大义的名分，谁听我话我就对谁好，谁不听我话我就欺负他，倒真是伪君子一个，跟其父一个德行 书中的情都在前期的小狐狸，沈家三人身上用完了，后期都是你跟我有仇我就杀你，你跟我没仇我也要杀人越货…… 在互联网创业公司，程序员就像冲锋陷阵的武将，江山未定的时候是他们最受重用的时候，江山稳固的时候，却是文臣（经理，销售，运营）们大展拳脚的舞台，程序员只有守疆卫土的份 哈哈哈哈，弗利萨有个长高梦 《塞尔达传说.荒野之息》是我玩过最伟大的游戏 大风起兮云飞扬威如海内兮归故乡安得猛士兮守四方！ 白雪公主有几只眼睛？两只那你有几只眼睛？两只那你为什么不能是白雪公主？ 最完美的皇帝非光武帝刘秀莫属 狡兔死，走狗烹；飞鸟尽，良弓藏 讲道理，清朝的皇帝没有一个是只图自己享受不顾民生的昏君，只是自乾隆之后的皇帝不是能力不足就是大权旁落，空有一番抱负却施展不开，而且封建王朝越往后发展积弊越深也是一个重要原因，封建制度实在是漏洞百出，它治下的王朝注定无法久存。 不得不说初清的几个皇帝都是励精图治的好皇帝，特别是康熙，当得一代明君，实力圈粉 口袋妖怪系列剧情最好的永远是宝石版，很感人 元朝这家创业公司完全是死于管理不当，浪费了这么多能武能文的人才 对于那些闯红灯的人和车（电瓶车和自行车，机动车一般没这个胆子闯），我是特别气愤的，所以每次轮到我绿灯前行，而那些人闯红灯的时候，我铁了心不顾他们，就算差点撞上我，事实上的确每次都很容易被撞，可是遇到速度够快的车子的时候，我还是不得不退缩避让他们，所以我对这类人可以说是相当厌恶的，就算他们因闯红灯被车撞了，我也不会生起一点同情之心。 那么我在气愤什么呢？我想最大的原因是原本该属于守规则者的权利和利益，现在被不守规则者抢占了，而且很多情况下，守规则者却不得不将这些原本属于自己的东西拱手相让给不守规则者，最典型的就是排队插队的问题，也可以用这个原因解释我们的愤慨，说到底还是利益的问题，但这些本来就属于我们守规则者的利益，难道不该争取，不该气愤吗？ 违法总是走在立法之前，混乱总是走在秩序之前 想要打造超级英雄系列宇宙电影，只有爆米花这一个套路，因为根本不可能塞得进去这么多内涵，一个或几个内涵拍来拍去等于是自掘坟墓，最怕又想搞深沉，又想搞娱乐的，到头来什么都不是，看着巨尴尬，这就是DC一开始立足不稳的原因，没有方向，没有主干 海贼王目前为止最大的败笔是霸王色的泛滥 我们这个民族最大的特点就是“坚韧不拔” 下一页 document.getElementById('weiboNext').addEventListener('click', function(event) { event.preventDefault(); window.location.href = this.href; });"},{"title":"微博-闲言碎语","date":"2019-05-15T16:28:04.000Z","updated":"2023-12-22T10:29:39.116Z","comments":true,"path":"weibo/page/2/index.html","permalink":"https://shuangdeyu.github.io/weibo/page/2/index.html","excerpt":"","text":"中国历史一直在创业容易守业难的深潭中前行，黄袍加身容易，捍土卫疆难，你方唱罢我登场，战争的铁蹄不知疲倦地席卷全国大地，民不聊生 不记账无非是不知道钱少在哪里了，记账之后看着钱一点点少去无可挽回，那个心痛 还有比Go的logo玩得更溜的语言吗，玩出花来了 盛世唐朝，心向往之 试问 baidu 如何豪言愿与 google 打技术战争？ 今年发生了很多不太好的大事，昆山砍人，房屋中介恶意炒高租房价格，滴滴两起恶意杀人事件，疑似自如甲醛房致人患病……其实并不是今年这类事情比往年更多，而是因为互联网让这些事情得以曝光以及快速传播得益于网络的便利，广大人民群众都有幸参与议论，在舆论的影响下，不管是执法部门还是企业都不可能大事化小甚至敷衍无视这些有恶劣影响的事件，这是一个进步，值得可喜可贺，消息的流通使罪犯黑暗最终无所遁行，但这里脑洞大开，细思极恐一下，未来是否会有一天，舆论凌驾于法律，那将会是社会秩序的崩塌？ 黄泉这么美，我想去黄泉——《鎌仓物语》 未解之谜：为什么开车的时候自己所在的车道总是堵，反向车道总是一路顺畅？ 一个平台的用户基数上来之后，用户的平均素质不可避免的会变低 baidu搜不到东西的时候记得用google，条件允许，就一直用google吧，baidu一次次让我感到心累…… 人没有贵贱之分，但有高低之分 徐克的西游情怀很严重啊，《狄仁杰之四大天王》到头来还是一个“三藏悟空”降妖除魔的故事 感谢你们一直为我的身体做了这么多 解决困扰我将近一个礼拜的bug之后，人都有点飘了~~~ 路飞越来越有强者的从容与自信了 看得出来李易峰是用心在提升自己的演技的，这样的鲜肉并不让人讨厌，反而会更吸粉 —— 《动物世界》 看权力的游戏有感：常备居安思危之心，就算你是位高权重之人，护卫贴身，危险照样会悄无声息地找到你 劳勃.拜拉席恩才是看得最透彻的人 很多看起来，使用起来很简单方便的功能，你想不到背后的程序做了多么复杂的处理。 得益于移动支付，现在钱对于很多人来说，只是一串随时变化的数字了，这不就是虚拟货币吗，只是现在这个阶段，前者是用来日常买卖的，后者是用来炒的。 硬件是基础，软件是灵魂 韩朝牵手的速度真惊人 长沙初印象，生活气息浓厚，香辣美食到处都是，生活节奏舒适，司机开车超级猛，过马路要绕路走过街天桥… 苹果公司在智能手机行业以一敌百，并且多年来一直站在顶点，仿佛武侠小说中的魔教，特立独行，受重重围功而不倒。安卓手机的攻势如何？其可谓是百花齐放，产商众多，发布之频一年到头不间断，iphone却依旧屹立不倒，在这么多的竞争中脱颖而出，引领潮流，实在厉害，唯有一声佩服。 2018年初，众知名公司争相上市为哪般？ 林超贤这回怕是玩得很爽，狙击、坦克、无人机、枪战、迫击炮、直升机、导弹护卫舰、运输机、翼裝飞行、现代化战争、断臂残肢……其结果是，观众看得很爽——《红海行动》 未来来得比你想象的还要快 当善意被报以善意，当恶意也被报以善意，再大的灾难也不可怕 —— 《海云台》 真正伟大的是那些给我们造引擎，造发动机的人，而我们做的只是拼凑一辆汽车，大多数程序员都是拼车的人 一个前科累累的保姆何以再次顺利进入别的家庭？本质上讲，还是这个行业不规范，监管毫无力度啊 上一页 下一页 document.getElementById('weiboPre').addEventListener('click', function(event) { event.preventDefault(); window.location.href = this.href; }); document.getElementById('weiboNext').addEventListener('click', function(event) { event.preventDefault(); window.location.href = this.href; });"},{"title":"微博-闲言碎语","date":"2019-05-15T16:28:04.000Z","updated":"2023-12-22T10:29:39.092Z","comments":true,"path":"weibo/page/3/index.html","permalink":"https://shuangdeyu.github.io/weibo/page/3/index.html","excerpt":"","text":"下雪是最浪漫的一种天气，祝贺杭州2018初雪 - 2018.01.24 杭州的公交体验的确差到爆，车速快，急转，急刹，坐着又晕，站着靠臂力。我一个朋友说：因美丽、礼貌而喜欢上杭州，却因交通而不想呆在杭州。 公司是一个很神奇的地方，它可能是你一年中呆的时间最长的地方，但你可能跟很多人甚至没有交流过一句话，尽管你们同处一室 人类终究成了造物主，当生命可以被创造，那么被创造的生命存在的意义又是什么？ —— 《银翼杀手2049》 分宜是一个小而热闹的县城，我打车去了很多地方，车费大都是起步价的价格，说明它小，但小并不代表着它萧条，相反，车水马龙，人声鼎沸我觉得是形容它最好的词语。 在这个不是过年过节的时间里，路上车流不息，路边停靠车辆见缝插针，电瓶车驰骋着与机动车擦肩而过，路边的饭店、服装店、鞋子店、理发店……光顾的人并不少，特别是饭店，大超市周边街道仿佛杭州的龙翔桥，人头攒动，摊贩遍布，好不热闹。 真是一个神奇的小县城。 DC的世界是神性的，漫威的世界是人性的。漫威胜就胜在有人情味，它的英雄出自民间，又战斗于民间；而DC中的英雄和反派是神明一般的存在，对于人类的描写则深入化，没有漫威的常态化、宽泛化来得通俗易懂，所以给人空泛的感觉，只剩下神仙干架。（论漫威和DC电影宇宙） 这是一个谎言与真相交织的世界，真中有假，假中有真，真真假假，假假真真，这就是片中所谓的幻术 —— 《妖猫传》 已经没事了！要问为何？因为！我来了！—— 欧尔麦特，一个微笑着拯救他人的英雄。对他来说，英雄不是一份职业，而是职责。 新的时代已经到来 对于我们国家，甚至对于全世界来说，这将近十多年来的变化可谓是翻天覆地。 互联网技术、智能手机、民用电子设备等的普及仿佛让我们置身于未来世界，过去我们玩的泥巴，看的方块电视，用的诺基亚早已成为了历史，现在，未来，更多新的事物如雨后春笋般出现。 然而前一年的稳步发展到了今年就变成了大动作 —— 人工智能走上了风口浪尖，世界各国都牟足了劲在抢占市场，这份变化未免来的太快，但是成果却是惊人的，智能AI、人工驾驶等技术都取得了重大突破甚至还有相关的量产产品，这种进步实在太可怕了，相信不久之后全世界将进入一个空前崭新的时代。 时代在前进，有人适应，也有人不适应，无论如何，我们只能顺应潮流，就像你在杭州开店，不用支付宝收款，你觉得你会损失多少营业额？ 城市的地下是肮脏糟粕，繁华的暗面是腐朽破败，长盛的尽头必然久衰，路漫漫，都不要高兴的太早。 遗忘比死亡更可怕 —— 《寻梦环游记》 一个细思极恐的感悟，我们常说钱对于顶级富豪们来说不过是一连串的数字，但是在互联网的推动下，钱对于大多数人来说（特别是人口，经济发达地区）也只是代表一串有价值的数据而已； 吃饭、出行、购物等等活动，只要有卡，有手机就能解决，一年中接触现金交易的次数越来越少，每个月只是看着手机里的那串数字增多或者减少，金钱的概念越来越模糊，设想一下，万一某天我们的，或者全人类的这些数字因为某些因素造成不可逆的消除，那不仅仅是自身多年的劳动成果毁于一旦了，这将是社会的灾难。 正义终究会到达的，但是他往往来得很慢，在付出巨大的牺牲之后 为什么一个明星的自拍都能上新闻？因为他有庞大的粉丝效应，能带来庞大的点击流量，有流量就有利益，所以他的一举一动都能轻易登上新闻，尽管这个新闻毫无意义，毫无营养； 明朝的历史真有意思，总是在谋反与被谋反之间进行着皇位更替 程序员生态圈的恶劣程度已经到了一个不可忽视的程度 差异性让人产生购买的欲望 早上看了今年iphone的重磅级新品iphoneX的介绍，作为一个电子专业出身的人，我深感它技术和工艺的精湛，实在令人赞叹以及赏心悦目，尽管iphone跟其它品牌手机相比在高度和距离上越来越接近，但仍不失为手机界顶级的艺术品。 区别于安卓机，苹果在系统上存在最大的区别，还有苹果软件自带的部分功能也有相当大的差异，还有第三方厂商开发的部分app跟安卓相比也有会多出一些细小的功能。 所以，虽然安卓机不管在性能上，外观上，还是工艺上越来越靠近苹果，但苹果基于安卓存在的优良差异和暂时领先的细小创新都不会不让人产生购买的欲望，重点是苹果不亲民的价格让很多人望而怯步。 大公司分工过细，职能限制在很小的环节上，小公司又要求面面俱到，粗旷型开发，个人得不到持续发展，干两年认为到头了，纷纷转行 —— 来自知乎，我觉得这是对现今底层程序员这个群体最贴切的描述。 我之所以讨厌打电话，是因为打电话的时候你必须停下手头正在做的事情，这股强迫感令我很不舒服 是否可以拿高工资取决于你能为公司做出多少贡献，不在于你有多少经验和能力，但有经验有能力的人往往能给公司带来更多的收益，所以他们工资高 的确，国内电影市场的票房越来越让人看不懂了，这是一个金钱的时代，而不是情怀、执着、艺术的时代 原来皇帝不能那么的无法无天，不是无所不能做，而且当皇帝非常非常的累，其实身居高位者往往承受着一般人想象不到的压力与责任 —— 读《明朝那些事儿》有感 我从《三体》看出了这两个观点：能使人类产生本质进步的是基础物理科学，而不是计算机科学；拯救人类的是理性，而感性会毁灭人类。 最撕心裂肺的痛，是到头来我所做的一切都是徒劳——《嫌疑人X的献身》 DC没有变成漫威 —— 《神奇女侠》 做短产品 当下玲琅满目的app中不乏许多的精品，人们每天需要在这些app中做一个是否点击的抉择，毕竟一天工作下来留给你娱乐的时间并不多，所以我觉得那些每天占用用户更少时间的短内容产品更能抓住用户源。举个栗子：lol的节奏紧凑，对局时间较短是其深受广大人群爱好的原因之一，以及短视频的火热，更体现了短内容的市场，反而是那些功能庞大，交互过深的app，很多人不愿做过多的停留。 任何多么华丽，功能多么强大的产品，经受不住市场的考验，都是在自我意淫。 豆瓣电影的影评就像新闻联播的报喜不报忧，报好不报差，反而短评相对来说具有参考性多了。 读东野圭吾《恶意》 上次看完了东野圭吾的《恶意》着实被这本书震撼到了我觉得这本书才是目前东野圭吾的巅峰之作 哪里被震撼了呢？它成功引导出了读者心中的恶意。最终的真相之前的真相是——日高多年以来胁迫野野口当他的影子作家，移居加拿大之际戏弄野野口说放过他，不可忍受的野野口终于杀害了日高 故事到这里，我想绝大一部分人都是对野野口抱有同情之心，而对日高则抱着死有余辜的态度，我们都认为野野口才是真的受害者，而日高才是恶魔 然而故事的结尾来了个巨大的转折，日高从小到大都是一个温柔善良且宽容坚定的人，受尽校园暴力却从不屈服，而野野口就是一个追随在暴力者身边马首是瞻的胆小鬼，日高见证了野野口的所有懦弱。尽管如此，多年后相见日高还是亲切得原谅并接受了野野口，而且还给他介绍工作 野野口癌症复发时日无多，为了掩埋过去的丑恶，为了自己早没了的自尊，激发了心中因嫉妒而对日高恨到极点的恶意，并设计一系列复杂的手法残忍杀害日高并让所有人认为他才是这些畅销书真正的作家，其实这些书的确是日高所写 这才是真相，是凶手的恶意 这本书就震撼在，当我们站在杀人凶手一边对被杀害的那个人冷嘲热讽的时候，我们心中的恶意就被无形地激发了。作者巧妙地引出了人们内心的恶意，在未知道真相的情况下，听信表面的报导妄自评价并嘲讽真正的受害者，当日高被拉下神坛时我们心中是不是有过那么一丝畅快，这是嫉妒，这些都是恶意。而在知道真相的时候，我才发现背后发凉，回过头来一想原来我也是拥有这些恶意的人，我也是谩骂老好人日高的一员，这怎么不叫人震撼？ 上一页 document.getElementById('weiboPre').addEventListener('click', function(event) { event.preventDefault(); window.location.href = this.href; });"}],"posts":[{"title":"喂老头，我成魔教教主了","slug":"喂老头，我成魔教教主了","date":"2024-04-06T16:00:00.000Z","updated":"2024-04-07T09:15:40.373Z","comments":true,"path":"2024/04/07/wei-lao-tou-wo-cheng-mo-jiao-jiao-zhu-liao/","link":"","permalink":"https://shuangdeyu.github.io/2024/04/07/wei-lao-tou-wo-cheng-mo-jiao-jiao-zhu-liao/","excerpt":"","text":"相见 「喂，老头，一大把年纪了，说话可不能反悔啊！」 「那是自然，今天贫道就是求也要将这痴儿求走，他可是天生的剑仙胚子。」 「好好好，这小拖油瓶今天总算能送走了，你快带他走吧，我事情可多着呢，莫要耽误了时间。」 「不去，哪也不去，我就要跟哥哥在一起，呜呜呜……」 风雪正喧嚣，路有冻死骨。 一个衣衫褴褛的孩童紫红紫红的双手紧紧扯着一个同样衣不蔽体的少年的衣角，哭红了眼，哭红了脸。 他们不远处，一个素袍老人负着手静静地站着，他立于风雪之中，却片雪不沾身，宛如一个不沾人间因果的谪仙，但是紧紧抓在一块的双手，戳破了他古井无波的表象。 「别闹，老头说你是痴儿，你还真是痴儿，这可是多少达官显贵，甚至是皇帝都求不来的神仙机缘，是你说不去就不去的吗。」少年陈青说着忽地用掌心推了一下孩童陈松的额头，将他推得一个踉跄，双手却离不开衣角一厘一毫。 「你，你就是个拖油瓶，离了你这个累赘，天下之大我大可去闯得，日后成就不一定就比你低呢，看在兄弟一场，你可莫要误了我前程。」陈青咬着牙关，面露不忍，但这话还是脱了口而出。 只是，陈松说什么也不肯松开双手，只是哭，只是哭，小小的身躯不知道哪来这么多气力。 哭是最耗气力的。 「听话，小松最乖了。」佯怒之后，陈青便蹲下来握着陈松僵了七分的双手，赶紧凑在嘴边，长长哈了两口热气：「以你的天赋，修成仙人也要不了多少年，日后，等你修成归来，要是为兄还没闯出名堂，指不定得要你接济呢，到时候你可不准嫌弃为兄。」 「当然，你修可不能随便修，定要修成那一方巨擘，到时候为兄想入宗门还不是以你一句话的事情吗？可不要像这个老头一样，左一句宗门规定，右一句宗门规定，窝囊得连我这毛头小子都看不下去了，修仙修仙，修不成逍遥自在，修个屁的神仙，你说是吧，老头。」 「呵呵，咳。」老人尴尬笑笑也没有气色。 要是同道中人知道他这个上三宗之一的剑宗最资深长老被一个小屁孩指着鼻子骂，定会惊掉一地下巴。 剑宗与其他修仙门派不同，宁缺毋滥，没有剑修天赋，不收就是不收。 「小友说得对，世人都道神仙好，都言神仙如何如何超脱，殊不知，修仙之人的条条框框，明争暗斗可多了去了，不比凡人来得潇洒快活，小友小小年纪便是个通透人，将来成就不可限量。」老人讨好般夸着陈青，脸上的皱纹挤在一块，本来就看不出多少来的仙风道骨，一笑就全部烟消云散了。 「可别夸了，老头，快带他走吧，这冰天雪地的，你们不冷我还冷呢，总站在这是个什么事？」陈青挥挥手，突然憋着的一身热气控制不住一散，浑身打了个长长的寒颤，感觉连心脏都被一只冰做的手握住，差点不跳了。 「我不走，我不要修仙！」陈松用衣袖抹了一把冰冷的泪和鼻涕，转头对着老人凶道：「我就要跟哥哥在一起！」 只不过奶奶的语气听不出丝毫威慑力。 老人叹了口气，刚要再次做惆怅状摇头念叨着「痴儿，痴儿」，陈青便噌地一下站起，用力打掉了陈松的手，这次他是真的生气了，道：「你这人怎么这么油盐不进呢，再胡闹，我就要生气了，听哥的话，修仙又不是坐牢，你要是想哥了，就到每年春天会开满满田野油菜花的竹溪村去找我，我每年春天都会去那里等你，记好了，我不再说第二遍！」 「呜呜呜……」陈松哭得更大声了，双手往前伸着，像是要重新抓住陈青的衣角，又像是期待着陈青的拥抱安慰，显得那么孤苦无助，他哽咽着点点头：「记得，那是，那是哥哥捡到我的地方，呜呜呜……」 相见之处，怎能不记得。 见状，陈青也不废话，强拖着陈松就往老人手里送去，走了短短几步，陈青竟觉得比偷了肉包子后跑上一条街还累。 好在很快，抗拒如一条咬钩的鱼的陈松头一歪竟晕了过去，毕竟年纪小再加上平日里总吃不饱饭，导致身子虚得很，哭闹了这么久终究是扛不住了。 「走了，老头，好好待他。」待老头接过陈松，陈青当即转身走向那噬人的茫茫巨口，头也不回。 「小友。」老头看着这个单薄的少年，眼中尽是惋惜，叹了口气道：「相遇即是缘，我叫李长庚，你不适合练剑，但练刀未必不能大放异彩，这本刀法你且拿着。」 陈青伸手接过柔柔飘来的刀谱，顺道挥了挥手：「谢了老头，回头我练练看，练成了再见你，我便叫你一声师父。」 「哈哈哈，好！」老人爽朗一笑，向来迂腐闷静的他心中难得感到了一丝畅快，他看着陈青一步一步走远，雪地上留下他的一串脚印，歪歪扭扭，深浅不一，很快又被新落下的雪盖住，轻轻念了一声：「一路平安，陈青小子。」 旧雪未及消， 新雪又拥户。 老人带着陈松御剑飞走了，惊的那处的雪花四处飘荡，陈青有所感，回头一望，天地间只剩下一片苍茫，除了白色还是白色。 「哈，哈。」陈青终是绷不住了，刚才保持的云淡风轻几乎用完了他所有气力，他随处找了一户人家的门沿墙角蹲着，使劲对着冻僵的手哈着热气，手里还紧紧攥着一本不新不旧的刀谱。 「这鬼天气，究竟何时是个头，冷死我了。」憋着的气散了之后，陈青冷到了骨子里，身体控制不住地发抖，抖若筛糠，待双手热乎了一点后，他使劲搓着双脚，然后搓着身子，又搓着手臂肩膀，等到搓到脸上的时候，两行清泪早已冻成了霜。 「臭小子真走运，哥哥不在，你可要好好照顾自己啊，呜呜呜……」终究只是一个十一二岁的小孩，这一刻，委屈、遗憾、不舍，他的种种情绪爆发在这无人的深夜，很快又被厚厚的风雪盖住，跟滔滔洪流中一颗石头一样毫不不起眼。 他这样的遭遇，在这兵荒马乱，食不果腹的年代中，也只是千千万万悲剧中的一个，又有谁会多看一眼呢。 相比其他人，陈青已经算是幸运了，遇到传说中的修仙之人，还得赠一本刀谱，至少，他从此有了在乱世中崛起的资本。 度厄 桃月中旬，三月桃花粉面羞，正是那满山桃花怒放，绮丽芬芳的时候，除此之外，另有百花争艳，点缀着山间地头，路边河岸，处处是春光，好不热闹。 特别是山下那一片金黄，灿灿生辉，其艳丽甚至盖过了山上那粉红佳人，一时风头无两。 「兄长，今年这满山油菜花开得还是跟往年一样旺。」少年陈松手捻一片金黄花瓣，嘴里喃喃着：「可是为何还不见你人影，你到底在哪里？」 陈松长大了，明眸剑眉，高鼻皓齿，长发盘髻，挺拔的身姿宛如一柄插在地上的利剑，隐隐散发着逼人的剑意，仿佛下一刻就要斩尽这满地金黄。 他眉间那抹化不开的忧愁又为他增添了一股忧郁气质，令人越看越着迷，良久，他收回思绪，手一垂，任由手中花瓣滑落，静静道：「要是你出了意外，我定要荡平所有伤害与你之人。」 话落，顿时一股气机由他为中心散开，惊得满地油菜花瑟瑟发抖，从满地金黄抖出了一个漫天生辉，围绕着陈松胡乱飞着。 山间，田野，飞花，少年，好一幅画里走出来的景象。 「该走啦，师弟。」背后突然响起的少女银铃般的呼唤打破了这本不平静的一幕，陈松转身，只见少女目含愠怒，似乎是因为在陈松这里，她跟油菜花的斗艳败下了阵，嘟着嘴不满道：「这油菜花有什么好看的，山门那常年的姹紫嫣红还不够师弟你看啊？」 「这些花花绿绿，哪有我好看，哼。」这句话是她在心里嘀咕的。 「抱歉，师姐久等了。」陈松对着少女欠身一拜，尽显谦虚恭敬，他挠挠头道：「走吧，师兄们怕是等久了。」 「哼，你还知道久啊。」 说着，二人纵身一跃，踏着飞剑驶向天际，一阵风吹过，满田野的油菜花重归平静，只剩一团花瓣随风飘荡。 云端之上，三个比起陈松略显成熟的少年见陈松二人飞来，当即架起飞剑再次赶起了路。 「师兄们久等了。」陈松再次抱拳道歉。 「不急，论剑大会明日才开始，今日就当散步了，这人间美色也算是别有一番风味。」领头之人说道。 「话说今年这三宗四派可都出了些了不得的人物，这次论剑大会怕是要精彩数倍不止了。」其中一人道。 「管他什么妖魔鬼怪，第一必是我剑宗的，因为我们有师弟。」少女道，看向陈松眼中连放异彩。 「师姐可别夸了，我还差得远呢，境界低了一大轮。」陈松摇头笑道。 「咱剑修看重的可不是境界，而是剑意，松师弟之剑意已有剑仙之姿，不可妄自菲薄，想必剑宗最年轻剑仙的称号非师弟莫属了。」 「的确，这次，松师弟就是我剑宗隐藏的利剑，一旦出鞘，定叫其他宗派惊为天人，哈哈哈。」 「哈哈，我可等不及看他们表情了。」 「哈哈哈……」 少年少女谈笑间，意气风发，一两黄金一两风，最风光是少年时。 另一边，陈松心中念叨着的陈青正在经历九死一生之劫。 「哈啊，哈啊……」陈青全身湿漉漉的，靠在一处洞壁之上，染血的衣物紧紧贴在肌肤之上，说不出的黏腻和难受，他大口大口喘着粗气，眼神却越发明亮，有一种大难不死的喜悦：「金刀门的杂碎，觊觎我的刀谱不说，还想抢我机缘，几次逼我到绝路，等着，我早晚弄死你们！」 陈青暗自发着狠誓，强撑着身体向洞口外的明亮走去，左手骨节泛白，紧紧抓着手中一个略显古朴的长匣，上面有血浸过的痕迹，随着手臂晃动，匣子里侧贴着的三根断指露了出来，触目惊心。 就在不经意间，断指上的血渗进了匣子，里面缓缓传来一阵轻微的机括声，而陈青还在咒骂着：「想不到吧，这五毒谷我不是第一次来了，更想不到吧，这水潭下面虽有毒蛇，深处却别有洞天，隐藏着这么一个洞天福地。」 「待我将这机缘消化，就是你们的死期，我陈青有恩必还，有仇必报。」 说着说着，陈青语气渐低，变得有些失落起来：「唉，今年又失约了，不知道陈松那傻小子去没去油菜花田。」 「呵，我在瞎想什么，仙人哪有我这么闲，传说中修仙之人一闭关短则上月，长则几年，恐怕松小子这会还在闭关修炼也说不定，不想了，他有他的机缘，我有我的机遇，总会有相见的那一天。」 「啊！」突然，陈青断指处一阵吃痛，竟是手中匣子不知什么时候已经打开了，盖子正好弹中他的伤口，从中「咣铛」一声掉落两物，没有霞光万道，也没有机关重重，就如匣子一般古朴无华。 「这是？」陈青捡起一看，登时眉头深深地拧在一块：「这，这竟然是千年前那令人闻风丧胆的魔尊的毕生武学度厄诀，还有他的度厄刀？」 「我竟然得了魔尊的传承，学还是不学？」 陈青没有被这泼天的机缘冲昏了头脑，一代魔尊的绝学就算当今的三宗也找不出几本能够与之匹敌的，但他很清楚一旦学了这门功法将会引来什么样的因果，更何况，传说中这魔尊魔气滔天，杀人千百万，他的绝学只怕很难不是邪功。 犹豫再三，陈青有了决断：「我陈青有恩报恩，有仇报仇，自认良心坚固，魔尊功法又如何，难不成还没练就能摄人心魄？要真是一门邪功，我还不屑学呢？」 说着，陈青便盘膝而坐就地看了起来，这一看，看得他眼睛再也移不开了。 良久，他才放下功法本子，拿起那柄度厄刀哈哈大笑：「度厄，度厄，世人皆苦，欲渡厄，先尝厄，肉体历经九九八十一厄难，方能超脱，厄难不缠身，或者说厄难缠身也不怕，正如天将降大任于斯人也，必先苦其心志劳其筋骨。」 「这本质上是一本极致的锤炼肉体的法门，壮大的是血气，甚至练至小成就可以肉白骨，而传统名门正派修的是外界灵气，传说那教主周身血气如虹，是杀了千千万万人所至，看来也是谬传了，可笑可笑，这哪里是邪功了，只身修炼方向不一样，又不伤天害理，这些正派当真霸道无边，竟硬生生将这功法宣传成了邪功。」 「既然如此，这度厄诀我练定了，不就是度厄吗，我陈青别的没有，就是吃的苦多，还怕扛不过去？作为回报，日后我定将你等正名。」 说着陈青抖了一下刀身，不知是不是错觉，度厄刀上一道寒芒闪过，刀身隐约间发出了一声欢快的轻吟，似是认可了这个新主人。 时光匆匆而过，谁能想到世间绝地之一的五毒谷深处竟有一处世外桃源般的山谷，谷中一个少年正练着天下一等一绝顶的法门，同时，也在经受着地狱般的锤炼。 究竟是为邪功正名，行侠卫道，还是人人喊打，除之而后快，一切还未可知。 魔头 「杀人啦，杀人啦，魔教打上金刀门啦，血红魔气覆盖整个门派，无一人生还。」 很快，金刀门被灭门的消息如星火燎原般传遍天下，上至庙堂，下至江湖，天下震动，不为别的，只因为他是三宗四派中，霸刀派设在人间的直属门派。 霸刀，霸刀，向来霸道无边，跟其他修仙宗派不同，霸刀派乐忠于渗透人间，而金刀门借着这一层关系，不说无恶不作也差不多了，嚣张跋扈到武林盟都不敢明着打压他们，当真是江湖一大毒瘤。 现在金刀门一灭，更多的人则是拍手称快，另有一部分人则深深担忧着，无论是灭了金刀门的狠人，还是金刀门背后的霸刀派，目前来看都不是好相与的角色，恐怕，这世间又要起惊天波澜了。 「当真是血红魔气和刀气？还覆盖了整个门庭？」荒漠深处，有一片连绵房屋，其中正中那间殿堂内传出一声的怒吼，其声雄浑如滚滚惊雷，乍响而起。 任谁都想不到，万里戈壁深处竟有这么一片气势恢宏的群落居所，这，正是整个霸刀派的门庭所在处。 「刀，刀主在上，小，小的所说，千真万确，那景象……」大堂之中，主位之前，一中年趴伏在地，浑身瑟瑟发抖，双眼埋在臂弯之间，盯着古朴的地板，仍旧难掩恐惧之色，也不知是在怕谁，他回忆了下，接着颤颤巍巍道：「那景象宛如炼狱直临，将天都映红了，只一眼，只一眼小的就吓晕了过去，所以才侥幸逃过一劫。」 末了，他抬起头，一改怯弱声嘶力竭道：「死了，全死了啊，金刀门上下三百多号人呐，还有我的儿啊，全死了，望刀主主持公道，将那魔头碎尸万段！」 说着便「咚」的一声重重磕了一个响头，长跪不起。 主位上，那名为刀主的魁梧男人沉吟片刻，唤退这金刀门幸存者之后，对着左右在位长老道：「各位长老怎么看，难道真是当年那魔尊传承有了后人？」 「八九不离十了，这几日我旧伤隐隐作痛，我道是什么原因，原来是这度厄魔功出世引起的，此子，断不能留，咳咳咳。」其中一老人顿了下手中木杖，咬牙切齿道。 「大长老所言极是，我想应该没人会质疑大长老的判断，毕竟他可是从那个时代活下来的。」另一人道。 「一个金刀门是小事，灭了再立一个就是，但此人断不能留，不然魔尊再临，天下生灵涂炭，我提议即刻通知其余三宗四派，全力捉拿此獠。」 「复议。」 「复议。」 …… 商讨很快便有了结论，等到众人陆续退出大堂，刀主仍旧坐在主位之上，他一手撑头，一手摩挲着主椅上雕刻着的白虎，眯着眼，眼中闪烁着贪婪渴望。 与此同时，这位风暴中心的始作俑者此刻正走在一处城镇的街头，身边跟着一个轻纱遮面，身段婀娜的妖女，正是当代魔教圣女。 「喂，你烦不烦，都说了我不是什么魔尊，也不会加入你们魔教，不要再跟着我了。」陈青皱着眉头，语气颇为不耐烦。 「嘻嘻，不愧是魔尊传人，灭了一个名门正派还大摇大摆地走在街头，生怕别人认不出你。」圣女在陈青耳边吐气如兰，纤纤玉指勾着他的下巴，笑嘻嘻道。 「哼，何惧之有。」陈青一巴掌拍掉圣女不老实的手，不为所动：「我行的是正道，那金刀门几次三番欲置我于死地，况且该门派霸道无边，暗地里做的坏事还少吗，我这是替天行道，我就不信这世间没了正义可言。」 「况且，我得了魔尊传承，他本人行事如何我不足以论评，但我既已立誓为他绝学正名，自然要光明正大施展出来，一辈子躲躲藏藏还谈何正名，这于我道心有碍。」 妖女轻笑一声，不置可否：「金刀门只是一个引子，重要的是你身怀魔尊功法，恐惧你的，觊觎你的，仇视你的……到时候，什么妖魔鬼怪都会出现，那些人，可比我们魔教可怕多了。」 「这些我自然知道。」陈青笑笑，伸了个懒腰：「就像刚才所说，我需要为度厄诀正名，所以我必须入世，度厄，度厄，我还未超脱，自然一生都要在度厄，你说的这些何尝不是一种厄难呢？」 「要不，我把度厄诀教你啊，这样世人就不会一直盯着我了。」 圣女一怔，红颜祸水般的姣好面容上还挂着那抹胸有成竹的媚笑，这时候尤其显得尴尬，不过魔教圣女心性自然也是一等一的，很快，她便恢复往常，只是看着陈青目中多了一丝刚才所没有的认可和好感。 她娇笑一声：「呵呵，魔尊的功法不是谁都能学的，既然你学会了，我魔教就会尊你为主，心甘情愿的哦。」 「我说了，我不会加入魔教的。」 「嘻嘻，那我们走着瞧好了。」 「你烦不烦。」 …… 「灭了金刀门的魔头在这里，杀了他，我门就能进三宗四派挑功法了，杀！」 「哈哈，羽翼未丰的小魔头，这等机缘被我哥俩遇到，天该我哥俩崛起！」 陈青一眼就认出这两人乃是凶名赫赫的散修欧阳二老，当即脸色一变，前所未有的凝重：「你们疯了吧，我们无冤无仇，何苦追我三天三夜。」 「桀桀桀，大哥，这小子当真天真无邪，看起来不像是魔头啊。」 「重要吗，只要他得了魔尊传承，不是魔头也得是魔头，桀桀桀，受死吧。」 陈青脸色阴沉，握着度厄刀的右手上粗壮的青筋如虬蛇攀爬，手中度厄刀越颤越快，血光弥漫。 只有陈青自己知道，不是他在控制自己的手，而是他在控制度厄刀不要轻举妄动，但是现在，他快控制不住了，不管是度厄刀，还是他的杀心。 「别逼我杀了你们……」 随后，一阵血光弥漫，很快又恢复平静，最后从林子里走出的只有陈青一人，他受了点伤，但不重，唯独双眸似是盖上了一层迷雾，藏着深深的迷茫。 这样的情景，陈青不知道遭遇过几回了，有些人教训一下他放了，也有些人他杀了，渐渐的，度厄之名真正的涵义也传了开来，但一波波红了眼的「猎人」还是络绎不绝。 陈青迷茫了，满心满脑只剩下「为什么」三个字，为什么他做的这一切好像并没有用，只要他练的功法叫做度厄。 难道真的是自己过于天真了？还是这世界太过荒谬？ …… 最后一次了，这是最后一次了，从此世上少了一个魔尊传人，多了一个真正的魔尊。 「魔头人头当属我青云宗，尔等速速退下。」 「凭什么，青云宗这么霸道吗？」 「魔头屠了我霸刀派属金刀门，自然是由我霸刀派擒拿处置。」 「呵呵，我宗也有人死在魔头手上。」 「我派也有。」 「呵呵，哈哈哈，哈哈哈哈，哈哈哈哈哈，啊哈哈哈哈哈！」陈青冷冷看着面前这一群乌泱泱的人，笑了，笑得癫狂。 「好一些名门正派，冠冕堂皇，你们要杀我？」 「无所谓了，那就杀吧，杀吧。」 「我累了，曾经我问过自己很多个为什么，现在不问了，答案早就摆在了眼前，而我却迟迟视而不见，何其愚蠢，哈哈哈。」 陈青还在癫狂地自言自语，而对面这些正派联军一时间竟被吓住了，再加上他们联军不联心，一时间也无人不识趣地打断陈青，只当是他死前的发泄。 「以前我穷苦潦倒也没失了本心，偷了哪家的包子日后我都几倍报答了回去；度厄诀非人能练成，我也扛了过来，守住本心，没有因此变得嗜杀残暴，可是……」 「唯独抵不住你们源源不断，一口一个魔头啊。」 「我本不欲成魔，奈何你们苦苦相逼，好，从此我便是魔，正义、公道，原来如此廉价，是我太天真了，这世界只讲利益，仙人也好，凡人也罢，都是利益这个漩涡中的牺牲品罢了，我实在是蠢透了，吃了这么多年苦，却连这点道理都看不透，呵呵，哈哈哈哈！」 说罢，陈青手握度厄刀在左手掌心一划，冒出的掌心血顿时氤氲成雾，围绕着陈青转悠，再加上他怒而血红的双眼，此刻真宛如魔尊再临。 这一刀，是告别，是他在跟以前的自己告别。 「既然如此，那我就要战在这世界之巅，让这天再也压不住我，让这地再也埋不了我，海到无边天作岸，山登绝顶我为峰！」 「恭迎教主，恭迎魔尊！」 陈青这句话一落地，江边两侧便爆发出一阵阵滔天的激昂口号，一群人目露激动地看着陈青走出，一眼都没看这浩浩荡荡的正派联军，仿佛在他们眼里，这些人跟死物没什么区别。 「什么，魔教怎么会在这里！」 「你们难道想跟天下宗门开战吗？」 面对威胁，魔教之人丝毫不惧，为首的圣女轻笑一声，开口道：「教主说了算，教主说降那就降，教主说杀，那就杀！」 陈青淡淡瞥了一眼，毫不犹豫地吐出一个字：「杀。」 那一天，胸有成竹，浩浩荡荡的除魔队伍无一人生还，清澈的永安江中那刺目的艳红和血腥三天三夜未消。 荡魔 永安江一战，天下震动，从此世人皆知有一个魔头，不，应该是魔尊唤作陈青，度厄刀再次让整个天下人心惶惶。 震怒之下，三宗四派联合天下高手，发出荡魔令，于宁门横断山，前往山顶魔教大本营展开荡魔计划，史称宁门荡魔。 天下风云动荡，人间和修行界均起战乱，可谓是末日之兆。 中州武林盟。 「盟主，三宗通知我们出兵，我们出是不出啊？」 「滚蛋，他们修仙界打架，关我们江湖武林什么事。」 「他们说金刀门是武林门派，我们得去主持公道。」 「放他娘的屁，这些老不死的个个阴着呢，我们去了还不是当炮灰的料，吩咐下去，谁敢私自去凑热闹，打断双脚送入丐帮。」 一手握陌刀的精壮中年人叹了口气，轻声道：「陈青小子，我只能帮你到这里了。」 隐世宗门诸葛家。 「使者请回吧，我诸葛家早已不入俗世。」 请走三宗使者后，这个儒雅书生放下手中的茶盏，捻起桌上一枚铜钱，自言自语道：「陈青，唯有身怀大气运者是我诸葛丘算不到的，有趣，有趣，有机会真想见你一面，与整个修仙界为敌，诸葛做不到，但只要你进了诸葛家地界，诸葛家还是有办法保你的。」 大山深处，妖族。 「三宗四派不可抗，众妖听令，暗中行事，必要时刻，救走人族陈青，来深山处。」 随着大妖一声令下，暗处隐着的妖怪们纷纷散去，去那对他们来说如履平地的山林各处，接应陈青。 大妖身旁，一只灵气四溢的小狐狸，眼中含着浓浓的担忧，祈求着看了一眼大妖。 大妖叹了口气，仍旧是无奈地摇了摇头。 就在全世界好像都与陈青为敌的时候，仍旧有一些人，有一些势力，在为他担忧，在尽其所能地帮助着陈青。 这一刻，命运的齿轮开始转动，以往做过的一件件好事，行过的一桩桩正事皆是引起了连锁反应，正所谓是善因结善果，这个世界还没有抛弃陈青，只是他现在还看不到。 「教主，那些正派欺人太甚，与他们拼了吧！」 「拼了！」 「拼了！」 「够了！」陈青一摆手，制止了下方教众的喧哗，他面容古井无波，平静道：「不需要，他们只是冲我来的，你们不出去就不会有事，我知道你们有血性，但不要做无谓的牺牲，留得青山在不愁没柴烧。」 「教主。」一位看起来地位比圣女还大的长眉长须老者道：「教主仁慈，多谢教主为我们考虑，但我等知道，魔教至今未灭只是因为那些正派需要留着我们给门中弟子历练用，这样的日子我们受够了，今天就让那些伪君子看看我们的骨气和底蕴，既然来了，就别想留着全身回去。」 「对，我们不要再当老鼠。」 「给他们点颜色瞧瞧。」 「杀，杀光他们，我要为我爹报仇。」 陈青看着下方群情激奋的众人，皱了皱眉，但终究还是没再说什么。 这些人，有跟陈青一样，是无父无母的孤儿，为圣教所救，报身圣教；有因那些正派的跋扈而弄得家破人亡的逃亡之人；也有真正的恶徒，走投无路混入圣教，但他们也不敢胡作非为，不然不光正派所不容，所谓的魔教也待不下去了。 大部分都是苦名门正派久矣之人。 最终，陈青唯有轻叹一声：「随你们吧。」 …… 横断山顶，传说是上古剑仙一剑削成，造成了现在山顶如履平地的地貌，本来是世界不可多得的剑修悟道之地，但好不巧，那位剑仙乃是邪剑仙，他削去的不仅仅是山头，还有此地方圆百里的所有灵气。 此刻，这里受到了从未有过的欢迎，人潮涌动，两拨人剑拔弩张。 「孽障，还不束手就擒，你算我长庚师叔半个弟子，回我剑宗接受惩罚，免得误了长庚师叔的名声。」自陈青名动天下后，他的生平自然是事无巨细地被扒了个干净，连十多年前剑宗大长老赠刀谱的事情都挖了出来。 「剑宗，莫要太目中无人了。」还不等陈青发话，那剑修身旁一尊魁梧的大汉不满道：「魔尊陈青屠我金刀门，杀我派弟子数十，今天，我霸刀派必要擒了他，将他抽筋剥皮，曝尸三天三夜！」 「刀主莫怪，实在是我替我宗长庚剑仙抱不平，竟看走了眼当初给了这个魔头机缘。」剑修抱拳道歉，但嘴角一直挂着淡淡的微笑，充满戏谑。 「哼。」霸刀派刀主冷哼一声也不再纠缠，他左一个长庚剑仙，右一个长庚剑仙，傻子都听得出来是在拿长庚剑仙立威，好为后续利益分配之时谋得更多。 不过这都是后话了，眼下最重要的还是这场大战，尽管长庚剑仙声名在外，但陈青，他霸刀刀主说什么也要拿到手。 陈青看着那正派联军还未开打就在勾心斗角，只觉得好笑：「哈哈哈，土鸡瓦狗。」 「你说得对，我陈青一生光明磊落，有仇报仇，有恩报恩，从未亏欠任何人，唯独你说的那个老头，我至今还没报了恩情。」 「我靠着他的刀诀走到今天，既然如此，如今我自断一臂，以报他的恩情足够了。」 说着，在任何人都没反应之下，一道刀光闪过，陈青左臂便连根飞起，摔在地上。 陈青第一时间运转度厄诀，收缩血气，这才没造成大喷血。 「从此，我们两不相欠，我陈青再不欠任何人！」 「教主！」 「教主！」 魔教见此则丝毫不淡定，纷纷惊讶于陈青的果决，有担忧的，也有责怪他不顾大局自损实力的。 「无妨，一臂而已。」陈青则毫不在意，只有练过度厄诀的他自己知道，血气亦可如臂使指，断臂又如何，血气不干，哪怕三头六臂都能给你整出来。 相反的，正派联军那边，有人见魔尊断臂，「实力大降」，当即就忍不住想要出手。 「杀，魔尊重伤，正是杀他的好时机！」 领军的几人也不阻止，他们需要这种愣头青来打头阵试探虚实。 不过联军中有一人早已忍不住要跳出了。 「住手，我看谁敢杀我哥！」 陈松目眦欲裂，刚才陈青断手，将他最后一丝顾忌打破，现在哪怕叛出宗门，与全世界为敌，他陈松都不会有二话，偏要站在兄长这边。 他虽未成剑仙，但已具剑仙之姿，周身剑气勃发，手中长剑狰鸣。 「陈松，快回来，莫要自误。」剑宗领头那剑仙气得胡子直抖。 陈松一脸坚定，丝毫未退，这时，一道威严的声音响起：「吾乃魔尊，凭你也敢妄称我弟？」 与此同时，一道血气震来，震得陈松飞回剑宗队伍，震得他一脸不可置信，再到明悟，又回到担忧。 陈青这是铁了心要跟他断绝关系，但凡现在跟他扯上关系的人，无一不是众矢之的。 没了陈松的阻挠，那几个迫不及待的炮灰当即冲出，打响了这场大战的第一炮，他们出手就是全力和杀招。 「一群臭虫也配拿我项上人头？」血红刀光闪过，几截断尸簌簌而落。 「魔头猖狂。」眼看时机和气氛烘托得差不多了，刀主一声令下：「今日，荡魔！」 霎时间，群情激奋，法宝和法术漫天飞舞，飞剑和枪戟碰撞出刺目的火花，挑出鲜艳的血红，战争，血与火，往往存在着一种震撼的美感，但在这种美感下是无尽的残酷，是廉价的生命，更是诱人的利益。 死亡不分对象，魔教和正道联军此刻每一分钟都有人在死去，成为这场荒谬的战争的添头。 「叮，铛」。 陈松举剑回挡，荡开陈青斜砍的一刀，急着说道：「哥！回头吧，我们去找师父求情，就说你是被魔教所蛊惑，相信我，相信师父。」 「愚蠢，修了这么多年还是如此愚蠢，回不了头了，我也不需，不想回头，既然这世道虚伪，那就让我来将他搅个地覆天翻，捅穿他！」陈青怒道，遂大开大合，度厄刀一时间压得陈松举剑唯艰，周身剑气纷纷破碎。 「魔头受死！」陈松的同门师姐见机从侧面攻来，找的角度及其刁钻，正是陈青挥刀力度正深的刹那，他必然难以及时收力回防。 看来，这位师姐是一直在看着陈松被打得节节败退，却不伸援手，只等这获利的一刻。 陈青眼角余光瞄见，随即露出一抹轻蔑的笑，只见他身上血气涌动，竟涌出一只全由血气组成的手臂，手中还握着一把血气形的度厄刀。 一刀，剑断，香消玉殒，甚至陈松师姐全身的血气都被吸食了个干净。 这就是度厄诀的恐怖之处，不仅能驱使自身的血气，还能够吸食别人的血气为己用，壮大自身，这令陈青在这场战争中如鱼得水，至今都未损耗一点血气。 同时，这也令得度厄诀显露出它邪异的一面，本来陈青是不想用出来的，无奈世人苦苦相逼，可以说是这些正道之人生生逼出来的。 现在，他们该尝尝这个恶果了。 「不！」陈松目眦欲裂，师姐明着暗着向他暗表情愫，正所谓日久生情，说他对师姐没点好感，那只能是假的。 陈青则面无表情，随意看了眼这个被吸成人干的美少女，心中暗道：「弟弟啊，你还是这么单纯，这女人的血气中充斥的都是欲望，你只是一条她向上爬的梯子而已，为兄就帮你这一次，斩了你的情缘，了了你的牵挂，让你更上一层楼，你不能只站在山腰，我在山顶等你。」 牵挂，说的是师姐，更是陈青自己，而他却亲手断了这段羁绊，逼的就是兄弟反目，就是要陈松跟他断绝关系，落得个清清白白。 「不，这是为什么，不！」陈松崩溃了，他浑身剑意大发，竟短暂的隐隐触摸到了剑仙的层次，不愧是天生剑仙之姿。 「飒」，剑光瞬息闪至，顶着陈青的额头。 「为什么？」陈松咬牙问道，回答他的却还是沉默，他瞪红了双眼，握剑的手止不住地颤抖，终究还是下不去这个手。 「啊！」陈松疯了，他冲向战场后方，发了疯似的去杀魔教成员，他需要一个发泄途径，不然肯定得落得个走火入魔的下场。 最终，陈青看着陈松被魔教双护法联手打得重伤昏迷，最后被剑宗长老救走，重重叹了口气。 厮杀还在继续，陈青也迎来了本次最大的劫难，那就是这支荡魔联军之首，霸刀派刀主。 陈青笑道：「想学我的度厄刀吗，跪下来磕个响头叫声爷爷，我就教你。」 回应他的是一声：「找死。」 大战爆发。 传闻这场荡魔之战陆陆续续打了足足有五天五夜之久，杀得那是血流成河，浓郁的血气直笼罩整座横断山而久久不散。 此战，世人皆知魔教之底蕴深厚得令人惊叹，虽然这仅仅是昙花一现，但却足够让正道联军十不存二，连后续支援都赶之不及，可以说整个正道宗派元气大伤，恐怕百年都不一定能恢复过来，实在是两败俱伤的局面。 而此战结局，以刀主身亡，魔教灭亡为终点，以鲜血为墨，最终画上了句号。 师父 「圣教因我而毁，虽然这是他们自己的选择，但我还是难辞其咎，他们尊我为教主，而我却不能保他们平安，恨，好恨，只恨我不够强，强到那能改写天下规则的地步。」 「妖女，北王，青衫长老，虎王，左护法，逃出来的就剩这么几个人了，我相信他们，只要他们还活着，圣教总有一天还会重现世间。」 「而我，我还不能死，我要变得更强，成为那绝巅，天下规则尽由我写，我要改变这虚伪的世道。」 陈青踉跄着朝一片沼泽林走去，脸色苍白，身上青色衣衫早已染成了暗红，破破烂烂，自身血气更是降到了极点，导致胸口那条深可见骨的伤痕迟迟未能痊愈，上面一股霸道的刀意弥留，时时刻刻剐蚀着他的血肉骨髓。 尽管如此，他眼中求生的欲望还是强盛到可怕，正是这无人能及的求生欲，让他一步步化险为夷，走到了今天。 那么这次，陈青是否还能再次战胜劫难，迎来新生呢？ 或许这个答案得由拦在他前面的这个老人来给。 「呵呵，没想到，最后是你。」 「师父。」 「从未言传身教，怎受得起师父二字？」老人负手而立，背对着陈青轻笑道，没有责问，没有说教，语气轻松如常，就像是两个久未素面的故人，平淡的话语下饱含热情。 这倒让陈青一时迷糊了，他沉默了会，晃晃脑袋尽量使自己保持清明，道：「我说过，你赠我刀谱，再见面，我喊你声师父。」 「却没想到是以这种方式见面。」说这句话的时候，陈青是真的感到心情有点低落。 对于老头，他是感恩的，却未能报答他的恩情。 「唉，陈青小子。」老头长叹口气，这一刻他的身影仿佛佝偻了几分，一股沧桑的气质忽然窜出，瞬间便取代了之前的仙风道骨，就好像现在才是他最真实的状态，而刚才是他的伪装，变化速度之快，令人心生疑惑。 「你受苦了。」 陈青一怔，满脸的疑惑：「喂，老头，抓我就抓我，别打感情牌啊，你之于我的恩情我自知一臂难以偿还，但放心，日后我必会百倍千倍还你。」 「但我可不会束手就擒啊，更不会被你三言两语拿下。」 「沧州大雪，你躲在死去的马肚里取暖，却仍旧命悬一线。」老头对于陈青的话语充耳未闻，仍旧自顾自说着：「荒州深林，你跟妖族厮杀，骨断筋折；中州天子脚下，你愤而锄奸去恶，被庙堂权势追杀七天七夜，无处藏身……」 老头滔滔不绝地吐着字，每吐一字，陈青内心便震撼一分，不可置信地看着这个既熟悉但更陌生的老头。 良久，老头吐出最后几句话：「陈青小子，我从你身上学到了很多，勇往直前，不默守陈规，敢于打破规则，质疑权贵，以及不管逆境如何多，如何困苦，也从不屈服的坚定意志，和一直保持初心的那颗赤子之心。」 「就算我年轻的时候也比不得你啊，我终究是老了，是糊涂了，能力越来越大，人却越活越差劲了。」 「现今所谓正道满嘴仁义道德，行的却是你争我夺，强抢霸道，打压异己之事，我早已看清，却不敢对此举剑反抗，此乃无能，此乃帮凶，助纣为虐。」 「但你敢，你也这么做了，天下只此你一人，说实话，我佩服你啊，陈青小子。」 最后这几句话陈青听得迷迷糊糊，他心烦意乱，一直沉浸在老头刚才关于他的遭遇的描述中。 「这些事，老头怎么会知道的，难道？不，不可能，怎么会！」 陈青再怎么不愿承认，但往昔记忆依然如流水般涌来，曾经没注意到的细节，不同寻常的画面现在一幕幕闪过眼前。 「原来，五毒谷底那些毒蛇是你惊走的，而且还是两次。」 「原来，那年在我快冻死之际赏我一身棉袄，一顿饱饭的行商是你。」 「原来，挟着生生果救我一命的小狐狸也是你引着来到我身边的。」 「原来，走即将走火入魔之时，突然涌进脑中的清明和顿悟也是你出手造成的。」 …… 「原来……原来都是你，是你一直在背后为我遮风挡雨。」 这一刻，陈青内心被从未有过的迷茫和慌乱充斥。 一路走来，他以为自己孤苦无依，没想到背后却有一个老人在为他遮风挡雨。 他以为自己受尽磨难，内心坚如磐石，就算是陈松，他都能忍痛与他划清界限，却没想到老头所做一切，让他内心深处的柔软再次破土而出。 陈青跌跌撞撞，他不知道自己是什么时候走到的老头身后，他不知道自己是相信老头不会伤害他，还是他自己已升不起抵抗之心。 他张了张嘴，却发现自己无论如何也说不出什么话来。 「扑通」一声，陈青跪在老头身后，脸上已没有了求生之欲：「老头，我累了，不想争了，你来送我走吧，这条命给你，我瞑目的。」 回应他的，是一只长满老茧的手，粗糙且温暖。 老头摸了摸陈青脑袋，像是老人对于子孙的宠溺：「傻孩子，生命多宝贵啊，怎么能轻言生死呢，往后的路，还长着呢。」 陈青身躯猛地一颤，他触电般抬头，只看见一只苍老的手，和一面同样苍老布满皱纹的侧脸。 然后，陈青哭了，两行清泪无声落下。 快饿死的时候，他没哭；摔下悬崖的时候，他没哭；被人追杀的时候，他没哭；被当做魔头受尽委屈的时候，他也没哭。 自那一场风雪夜之后，不管再怎么困难意难平陈青都没哭，现在他却哭了，知道老头所做的一切后他哭了。 老头现在真的就是个老头，陈青从他身上感受不到一点修为波动。 原来老头在陈青来此之前早已散了毕生修为。 身为剑宗长老，老头职责在身，该阻陈青，但他散去修为，不是不阻，而是阻不了。 毕生修为，说散就散了，陈青瞬间明了一切，他泣不成声，磕着头长跪不起。 「为什么？我只是一个没有修行天赋的流浪儿，这天下有千千万万个我这样的。」 「为什么？我可是杀人不眨眼，双手沾满鲜血，人人喊打的魔头啊。」 「为什么要为我做这一切，为什么？」 「师父！」 陈青转而嚎啕大哭，他从没这样哭过，本来苍白的脸，现在却哭得满脸通红。 老头没有回答陈青的疑问，只是安静地站着，最终，他长叹一声：「走吧，快走吧，没有为什么，你是那个能改变世界的人，你就当是我对自己的救赎好了。」 风声渐熄，眼泪总有流尽的那一刻，陈青抬起头，看着老头的身影，越发佝偻。 他眼神变幻，最终脸色恢复平静，眼中露出前所未有的坚定，起身用袖子胡乱抹了一把脸，他的脸更脏了。 陈青停顿片刻之后，一言不发地大踏步向前走去，从始至终都没有转过头看一眼老头。 他不敢看他的脸，那张布满岁月痕迹的脸，它本不该如此的。 从老头身旁踏过，陈青说了一句：「我走了，老头，你可不能死得那么早啊。等我，等我做完想做的，我将这身血气渡让给你。」 「记住了，别死得这么早啊，不然我发起疯来，这天下可能就没了。」 陈青走了，消失在这个最后阻拦者的面前，也就是从今天开始，世上再也没人见过这位年轻的魔尊，但关于他的传说却越传越广，当然，都是负面传闻。 不过那又怎样呢，当他再次出世的时候，或许他真的能做到一人言，万万人臣服，那这点流言蜚语又算得了什么。 或许一年，或许五年，也或许十年，相信他不会让天下人久等的。 「哒，哒，哒」。 陈松满脸疲惫，他手持一柄断剑，拖着沉重的脚步，一步一步走向老头，也就是他的师父。 跟老头并肩站在一起，他目光望向前方黑暗幽深的五毒谷，开口问道：「他走了吗？」 「走了。」老头回答。 「那就好。」 故事完","categories":[{"name":"小说","slug":"小说","permalink":"https://shuangdeyu.github.io/categories/%E5%B0%8F%E8%AF%B4/"}],"tags":[{"name":"武侠","slug":"武侠","permalink":"https://shuangdeyu.github.io/tags/%E6%AD%A6%E4%BE%A0/"}]},{"title":"《许三观卖血记》读书笔记","slug":"《许三观卖血记》读书笔记","date":"2024-02-03T16:00:00.000Z","updated":"2024-04-07T09:12:58.598Z","comments":true,"path":"2024/02/04/xu-san-guan-mai-xie-ji-du-shu-bi-ji/","link":"","permalink":"https://shuangdeyu.github.io/2024/02/04/xu-san-guan-mai-xie-ji-du-shu-bi-ji/","excerpt":"","text":"如果他在她们中间选一个做自己的女人，一个在冬天下雪的时候和他同心协力将被子裹得紧紧的女人，他会看上林芬芳，那个辫子垂到了腰上的姑娘，笑起来牙齿又白又整齐，还有酒窝，她一双大眼睛要是能让他看上一辈子、许三观心想自己就会舒服一辈子；林芬芳也经常粑她的手拍到他的头上，推到他的胸前、有一次还偷偷在他的手背上捏了一下，那一次他把最好的蚕茧送到了她这里、从此以后他就没法把不好的蚕茧送给她了。 用平凡朴素的笔触写出了许三观对许玉兰的喜欢，没有华丽的辞藻，没有矫情的话语和心理活动，仅从简简单单的动作上进行描写，但是却更加令人印象深刻 她在大街上的行走，使她的漂亮像穿过这座城镇的河流一样被人们所熟悉，在这里人们都叫她油条西施……“你们看，油条西施走过来了。……“油条西施走到布店里去了，她天天都要去布店买漂亮的花布。”……“不是，油条西施去布店是光看不买。”……“油条西施的脸上香喷喷的。”……“油条西施的手不漂亮，她的手太短，手指太粗。”……“她就是油条西施？”…… 极妙的比喻，怎么描写她的漂亮被人熟知呢，在比喻之后用对话进行了详细解释，从第三者的角度描写许玉兰自认为的漂亮，这段话其实是在说她爱漂亮，爱显摆 当时何小勇穿着干净的白衬衣，袖管卷到手腕上面，他微笑着说话时，双手握往自己的手腕，他的这个动作使许玉兰十分着迷，这个漂亮的姑娘仰脸望着他时，眼睛里闪闪发亮 描写一个人对另一个人的崇拜和喜欢 那个年月城里的街上还没有路灯，只有一些灯笼挂在店铺的屋檐下面，将石板铺出来的街道一截一截地照亮，许三观一会儿黑一会儿亮地往家中走去 这段描写很有画面感，很细腻，很真实 “啊呀，”许玉兰叫道，“所以你让三个儿子叫一乐，二乐，三乐，我在产房里疼了一次，二次，三次；你在外面乐了一次，二次，三次，是不是？” 重复描写法，比说“我疼了三次，你在外面乐了三次”更好，后者太显白话了，这段话一看就比较能让人抓住重点，许玉兰生三次儿子，许三观乐了三次，许玉兰嘴里喊着疼，但又何尝不乐呢 许三观将这面三角形的残镜拿在了手中，他照着自己的眼睛看了一会儿，再去看一乐的眼睛，都是眼睛；他又照着自己的鼻子看了一会儿，又去看一乐的鼻子，都是鼻子……许三观心里想：都说一乐长得不像我，我看着还是有点像 这段话也有重复的技巧在里面，眼睛都是眼睛，鼻子都是鼻子，谁的儿子不是儿子，其实是许三观有点自欺欺人的表现 许玉兰决定拆手套的时候，总是在前一天晚上睡觉前把窗户打开，把头探出去看看夜空里是不是星光灿烂，当她看到月亮闪闪发亮，又看到星星闪闪发亮，她就会断定第二天阳光肯定好，到了第二天，她就要拆手套了 这句话核心只有一个，就是在说许玉兰得到精仿手套的时候很开心，星星、月亮、阳光都是为了映衬她发自心底的开心，特别是阳光，第二天的阳光谁知道呢，因为她心情好，所以第二天的阳光肯定也好 许玉兰和二乐在那里一坐，两个人就会没完没了地说话，一个三十岁的女人和一个八岁的男孩，两个人吃完饭，两个人睡觉前，两个人一起走在街上，两个人经常越说越投机 一个三十岁，一个八岁，年龄是一个反差，但紧接着后面的描写更加点睛了没完没了地说话，怎么个没完没了呢，哦，是这样子的没完没了，写出了母子关系的和谐，有爱再者，这段话之后就是母子俩关于日常八卦的对话，更像是两闺蜜之间的对话，再次说明母子俩关系的好 这段不是书里一段具体的句子，而是一段剧情：书里说许三观喜欢一乐，许玉兰喜欢二乐，唯独三乐，所有人都对他说“你走开，三乐”，看起来大家都觉得三乐是拖油瓶，帮倒忙，不喜欢他，但当三乐跟别人打架的时候，二乐一乐二话不说就来帮忙，其实这家里人对三乐不是讨厌，而是爱，正是因为爱他，所以才把他保护得太好，怕他受伤 这是一种反差的写法，前面看起来有多嫌弃三乐，但当三乐有难，兄弟二话不说来维护的时候，前面有多嫌弃，现在就有多爱 和你们妈也没有别的办法，只好先把你们的小命保住，别的就顾不上了，俗话说得好，留得青山在不怕没柴烧，只要把命保住了，熬过了这昔日子，往下就是很长很长的好日子了 即是那个时代的无奈，又是那个时代人们淳朴的愿望，短短几句话就写出了那个时代的苦难 说着，许玉兰掉出了眼泪，她把钱叠好放到里面的衣服口袋里，然后举起手去擦眼泪，她先是用手心擦去脸颊上的泪水，再用手指去擦眼角的泪水。 这描写就很细节，很真实，很有画面感，一般人只会写“她用手擦去脸上的泪水”，这就是高手和新手的区别 他一个人在桌前坐下来，将那个还热着的红薯放在桌上，开始小心翼翼地剥下红薯的皮，他看到剥开皮以后，里面是橙黄一片，就像阳光一样。他闻到了来自红薯热烈的香味，而且在香味里就已经洋溢出了甜的滋味。他咬了一口，香和甜立刻沾满了他的嘴。 那个红薯一乐才咬了四口，就没有了。之后他继续坐在那里，让舌头在嘴里卷来卷去，使残留在嘴中的红薯继续着最后的香甜，直到满嘴都是口水以后。他知道红薯已经吃完了，可是他还想吃，他就去看刚才剥下来的红薯皮，他拿起一块放到嘴里，在焦糊里他仍然吃到了香甜，于是他把红薯的皮也全吃了下去。 优秀的描写，写出了一个长时间没有吃过玉米糊粥之外的食物的人，对待一个简简单单的“美食”，吃出了十二分的美味 他让自己的哭声越来越响，他听到这个夜晚里什么声音都没有了，风吹来吹去的声音没有了，树叶抖动的声音没有了，身后饭店里凳子搬动的声音也没有了，只有他自己的哭声在响着，在这个夜晚里飘着。 伤心的写法，不仅聚焦于人本身，也从四周景物上面反衬他哭得是真的伤心 轮船到位城里时，天还没有亮，城里也在下雪，地上已经积了很厚的一层雪，二乐背着一乐那条棉被又盖着一乐，所以二乐走去时像是一辆三轮车那么庞大，雪地上留下他的一串脚印，脚印弯弯扭扭，深浅不一，在路灯的光线里闪闪发亮。 从侧面写出了二乐身上的重量之重，步行的困难，可以多从四周可取材的事物上描写，再反应到人身上 他要去的地方是上海，路上要经过林浦、北荡、西塘、百里、通元、松林、大桥、安昌门、靖安、黄店、虎头桥、三环洞、七里堡、黄湾、柳村、长宁、新镇。其中林浦、百里、松林、黄店、七里堡、长宁是县城，他要在这六个地方上岸卖血，他要一路卖着血去上海。 这句是写一乐到上海看病路途的遥远和困难，不是一句话概括说远，而是细致写出了要经过的地名之多，让人切切实实感受到路途的远，从而联想到一路的艰辛，也为许三观这一路要卖这么多次血而揪心，不免为他的命运担忧起来 许三观说着腾出一只手指了指自己的衣领，继续说：“这里就像是你们家的窗户，你们家的窗户到了冬天都关上了吧，冬天要是开着客户，在家里的人会冻坏的。” 许三观又何尝不是全家的窗户呢，为家人遮风挡雨 许三观走在街上时，脸上挂满了笑容，笑容使他脸上的皱纹像河水一样波动起来，阳光照在他脸上，把皱纹里面都照亮了。 记录一下，描写皱纹的好句子 许三观开始哭了，他敞开胸口的衣服走过去，让风呼呼地吹在他的脸上，吹在他的胸口；让混浊的眼泪涌出眼眶，沿着两侧的脸颊刷刷地流，流到了脖子里，流到了胸口上，他抬起手去擦了擦，眼泪又流到了他的手上，在他的手掌上流，也在他的手背上流。 他的脚在往前走，他的眼泪在往下流。他的头抬着。他的胸也挺着，他的腿迈出去时坚强有力，他的胳膊甩动时也是毫不迟疑，可是他脸上充满了悲伤。他的泪水在他脸上纵横交错地流，就像雨水打在窗玻璃上，就像裂缝爬上炔要破碎的碗，就像蓬勃生长出去的树枝，就像渠水流进了田地，就像街道布满了城镇，泪水在他脸上织成了一张网。 很细致的极度伤心的描写 屌毛出得比眉毛晚，长得倒比眉毛长 一刷完毕，期待二刷有更多的收获，是一部优秀的作品","categories":[{"name":"读书","slug":"读书","permalink":"https://shuangdeyu.github.io/categories/%E8%AF%BB%E4%B9%A6/"}],"tags":[{"name":"经典","slug":"经典","permalink":"https://shuangdeyu.github.io/tags/%E7%BB%8F%E5%85%B8/"},{"name":"余华","slug":"余华","permalink":"https://shuangdeyu.github.io/tags/%E4%BD%99%E5%8D%8E/"}]},{"title":"《如何阅读一本书》笔记-转载","slug":"《如何阅读一本书》笔记","date":"2024-01-30T16:00:00.000Z","updated":"2024-02-02T06:04:04.648Z","comments":true,"path":"2024/01/31/ru-he-yue-du-yi-ben-shu-bi-ji/","link":"","permalink":"https://shuangdeyu.github.io/2024/01/31/ru-he-yue-du-yi-ben-shu-bi-ji/","excerpt":"","text":"《如何阅读一本书》，这是一本探讨和教授阅读方法的经典书籍，我读了前面八章（中文版），的确有很多实用性的方法，但整体来说偏啰嗦，一个论点引申开来的篇幅太长了，其实它核心论点不多，就这么几个，其实它就是一本工具书。 本来想自己整理的，但看了网上有很多整理好的优秀笔记，我就转载一个喜欢的到这里，方便自己日常回顾（协议允许转载我才转载的） 原文地址：https://leovan.me/cn/2019/02/how-to-read-a-book/ （Copyright © 2017-2024 范叶亮 | Leo Van） 阅读的层次 第一提醒读者，阅读可以是一件多少主动的事。第二要指出的是，阅读越主动，效果越好。 读书，不是非做不可的事，而是想要去做的事。——《女王的教室》 阅读的目标：为获得资讯而读，以及为求的理解而读。 也就是说，阅读类似学习，知其然，知其所以然。 阅读就是学习：指导型的学习，以及自我发现型的学习之间的差异。 独立的思考与思辨。 阅读的层次分为： 基础阅读 (Elementary Reading) 检视阅读 (Inspectional Reading) 分析阅读 (Analytical Reading) 主题阅读 (Syntopical Reading) 基础阅读基础阅读的四个阶段： 阅读准备阶段，相当于学前教育或幼稚园的学习经验。 认字，相当于一年级学生典型的学习经验。 字汇的增长及对课文的运用，通常是四年级结束时学会的方法。 “成熟”的阅读者，小学或初中毕业时的读写能力。 无限制的受教育机会是一个社会能提供给人民最有价值的服务。 检视阅读有系统的略读或粗读略读 (Skimming) 和粗读 (Pre-reading) 是检视阅读的第一个层次，用不着花太多时间，如何去做，建议如下： 先看书名页，然后如果有序就先看序。 研究目录页，对书的基本架构做概括性的理解。 如果书中附有索引，也要检阅一下。 读一下出版者的介绍。 挑几个看来跟主题息息相关的篇章来看。 东翻翻西翻翻，念一两段，连续读几页，不要太多。 在最多不超过一个小时的时间内对书有个大概的了解其是否包含你还想继续挖掘下去的内容，是否值的你再继续投入时间与注意。 粗浅的阅读 头一次面对一本难读的书的时候，从头到尾读完一遍，碰到不懂的地方不要停下来查询或思索。 在阅读一本书的时候，慢不该慢的不值得，快不该快到有损于满足与理解。 略读或粗读一本书总是个好主意，尤其当你并不清楚手边的一本书是否值的细心阅读时。 在第一次阅读一本难读的书时，不要企图了解每一个子句。 做一个自我要求的读者在阅读时要提出问题来，同时自己必须尝试去回答这些问题： 整体来说，这本书到底在谈些什么？(主题) 作者细部说了什么，怎么说的？(细节) 这本书说得有道理吗？是全部有道理，还是部分有道理？(个人的评价) 这本书跟你有什么关系？(意义) 这四个问题概括了一个阅读者的责任，读书要对书负责，更要对自己负责。 你必须读出言外之意，才会有更大的收获，我们也鼓励你“写出言外之意”。 对于阅读来说，在书上做笔记是不可或缺的事。 可以让你保持清醒，不只是不昏睡，还是非常清醒。 主动的阅读是一种思考，而写出来是阅读者表达思考的好方法。 将自己的感想写下来，有助于记住作者的思想。 培养阅读的习惯，除了不断地运作练习之法，别无他法。 我们谈到一个有技术的人时，并不是在说他知道该如何去做那件事，而是他已经养成去做那件是的习惯了。 分析阅读第一阶段 规则 1你一定要知道自己在读的是哪一类书，而且越早知道越好。最好早在你开始阅读之前就先知道。 我们一定要超越“知道这是怎么回事”，进而明白“如果我们想做些什么，应该怎么利用它”。 也就是我们需要做到知行合一。 理论性作品是在教你这是什么，实用性的作品是在教你如何去做你想要做的事，或你认为应该做的事。 实用的书常会出现“应该”和“应当”，“好”和“坏”，“结果”和“意义”之类的字眼，相反的理论型作品却常常说“是”。 理论性作品可以分为： 历史，历史就是纪事，常以说故事的形态出现。 科学，以实验为基础，或依赖精确的观察研究，并不容易被证明。 哲学，是坐在摇椅上的思考，相对容易被观察和理解。 规则 2使用一个单一的句子，或最多几句话（一小段文字）来叙述整本书的内容。 也就是用你的话告诉别人这本书在讲什么。 规则 3将书中重要的篇章列举出来，说明它们如何按照顺序组成一个整体的架构。 规则 2 是在指导你注意一本书的整体性，规则 3 是在强调一本书的复杂度。 写作与阅读是一体两面的事，就像教书与被教一样。 一个作品应该有整体感，清楚明白，前后连贯。 规则 4找出作者要问的问题。 第一阶段的目的就是掌握结构大纲。 第二阶段 规则 5找出重要的单字，透过他们与作者达成共识。 字词只是作者表达的工具，我们需要通过这些字词探索作者想表达的本意。 一本书之所以能给你带来新的洞察力或启发，就是因为其中有一些你不能一读即懂的字句。 规则 6将一本书中最重要的句子圈出来，找出其中的主旨。 主旨则是这些问题的答案。 阅读的一部分本质就是被困惑，而且知道自己被困惑。 惑，知惑！ 规则 7从相关文句的关联中，设法架构出一本书的基本论述。 要记住所有的论述都包含了一些声明。 要区别两种论述的不同之处。归纳法：以一个或多个特殊的事实证明某种共通的概念，演绎法：以连串的通则来证明更进一步的共通概念。 找出作者认为哪些事情是假设，哪些是能证实的或有根据的，以及哪些是不需要证实的自明之理。 规则 8找出作者的解答。 第三阶段 遵守思维的礼节。 最能学习的读者，也就是最能批评的读者。 受教是一种美德，但受教并非是被动的顺从，而是主动的思考。 规则 9在你说出“我同意”，“我不同意”，或“我暂缓评论”之前，你一定要能肯定的说：“我了解了”。 毫无理解便同意只是愚蠢，还不清楚便不同意也是无礼。 规则 10当你不同意作者的观点时，要理性地表达自己的意见，不要无礼地辩驳或争论。 争议是教导与受教的一个过程。 规则 11尊重知识与个人观点的不同，在作任何评断之前，都要找出理论基础。 事无对错，需有理有据，避免口舌之争。 当读者不只是盲目地跟从作者的论点，还能和作者的论点针锋相对时，他最后才能提出同意或反对的有意义的评论。 规则 12说一位作者知识不足，就是说他缺少某些与他想要解决的问题相关的知识。 除非这些知识确实相关，否则就没有理由作这样的评论。 规则 13说一位作者的知识错误，就是说他的理念不正确。 论点与事实相反。 规则 14说一位作者是不和逻辑的，就是说他的推论荒谬。 荒谬有两种形态：一种是缺乏连贯，也就是结论冒出来了，却跟前面所说的理论连不起来。另一种是事件变化的前后不一致，也就是作者所说的两件事是前后矛盾的。 规则 15说一位作者的分析是不完整的，就是说他并没有解决他一开始提出来的所有问题。 严格来说，规则 15 并不能作为不同意一个作者的根据。我们只能就作者的成就是有限的这一点而站在对立面上。 CHEAT SHEET 分析阅读的第一阶段：找出一本书在谈些什么的规则 (1). 依照书本的种类与主题作分类。 (2). 用最简短的句子说出整本书在谈些什么。 (3). 按照顺序与关系，列出全书的重要部分。将全书的纲要拟出来之后，再将各个部分的纲要也一一列出。 (4). 找出作者在问的问题，或作者想要解决的问题。 分析阅读的第二阶段：诠释一本书的内容规则 (5). 诠释作者使用的关键字，与作者达成共识。 (6). 从最重要的句子中抓出作者的重要主旨。 (7). 找出作者的论述，重新架构这些论述的前因后果，以明白作者的主张。 (8). 确定作者已经解决了哪些问题，还有哪些是未解决的。在未解决的问题中，确定哪些是作者认为自己无法解决的问题。 分析阅读的第三阶段：像是沟通知识一样地评论一本书的规则 A. 智慧礼节的一般规则 (9). 除非你已经完成大纲架构，也能诠释整本书了，否则不要轻易批评。（在你说出：“我读懂了”之前，不要说你同意、不同意或暂缓评论。） (10). 不要争强好胜，非辩到底不可。 (11). 在说出评论之前，你要能证明自己区别得出真正的知识与个人观点的不同。 B. 批评观点的特别标准 (12). 证明作者的知识不足。 (13). 证明作者的知识错误。 (14). 证明作者不合逻辑。 (15). 证明作者的分析与理由是不完整的。 辅助阅读 内在阅读，是指阅读书籍本身，于所有其他的书都是不相关的。外在阅读，是指借助其他的一些书籍来阅读一本书。 外在的辅助来源可以分为四个部分：相关经验，其他的书，导论与摘要，工具书。 导读和摘要要尽量少用，因为：一本书的导读并不一定都是对的，就算他们写对了，可能也不完整。 如果你在阅读全书之前，先看了他的导读手册，你就隶属于他了。 这也是为什么我不喜欢将自己看过的书借给其他人的原因，我不希望其他读者在第一次读这本书的时候就被我记录在书上的笔记所影响。 阅读不同读物的方法阅读实用型的书 分析阅读的规则，一般来说适用于论说性的作品，也就是说任何一种传达知识的书。 任何实用性的书都不能解决该书所关心的问题。 实用性的书分为两类：其中一种，就像本书一样，或是烹饪书、驾驶指南，基本上都是在说明规则的。另一类的主要是在阐述形成规则的原理，许多伟大的经济、政治、道德巨著就属于这一类。 在读实用性的书要提出的四个问题： 这本书在谈些什么？ 找出作者的共识、主旨和论述。 内容真实吗？（比前两点重要） 这本书于我何干？ 赞同一本实用性的书，需要你采取行动。 阅读想象文学 想象文学的主要目的是娱乐，而非教育。 关于阅读想象文学，建议的否定指令： 不要抗拒想象文学带给你的影响力。（生活不只有眼前的苟且，还有诗和远方） 在想象文学中，不要去找共识、主旨和论述。 不要用适用于传递知识的，与真理一致的标准来批评小说。（一千个人眼中有一千个哈姆雷特） 阅读小说的规则： 架构性： 你必须将想象文学作品分类。 你要抓住整本书的大意，一篇故事的大意总是在情节之中。 你不仅能够将整本书简化为大意，还要能发现整本书各个部分是如何架构起来的。 诠释性： 小说的要素是插曲、事件、角色与他们的思想、言语、感觉及行动。 共识与主旨有关。（尝试身临其境） 任何活动就是论述的发展。 评论性 在你衷心感谢作者试着为你创造的经验之前，不要批评一本想象的作品。 不该反对或赞成，而是喜欢或不喜欢。 阅读故事、戏剧与诗 暴君并不怕唠叨的作家宣扬自由的思想，他害怕一个醉酒的诗人说了一个笑话，吸引了全民的注意力。所谓“纯”艺术，并不是因为“精致”或“完美”，而是因为作品本身就是一个结束，不再与其他的影响有关。就如同爱默生所说的，美的本身就是存在的唯一标准。 阅读故事书的规则： 快读，并且全心全意地读。 整本书在谈些什么？一个故事的词义，存在于角色与事件之中。 批评小说时，要区分是满足个人特殊潜意识需求的小说还是大多数人潜意识的小说。 阅读抒情诗的规则： 不论你自己觉得懂不懂，都要一口气读完，不要停。 重读一遍，大声读出来。 对论说性作品所提出的问题是文法与逻辑上的问题。对抒情诗的问题却通常是修辞的问题，或是句法的问题。 要了解一首诗，一定要去读它，一遍又一遍地读。 阅读历史书 就事实而言的历史 (history of fact) 与就书写记录而言的历史 (history as a written record of the facts) 是不同的。 历史的基本是叙事的。 所以叙事应尽可能的公平，公正地描述所发生的事情。 历史比较接近小说，而非科学。这并不是说历史学家在捏造事实，就像诗人或小说家那样。 历史根本就没有模式可循。 在了解一个已经发生过的事情时，最好多听取几个不同的版本，哪怕每个人的陈述都已经尽可能的公平公正了，但也可能会存在信息的丢失。 修昔底德说过，他写历史的原因是：希望经由他所观察到的错误，以及他个人受到的灾难与国家所受的苦楚，将来的人们不会重蹈覆辙。 以铜为鉴，可以正衣冠，以人为鉴，可以知得失，以史为鉴，可以知兴替。 阅读历史书要提出的问题： 每一本历史书都有一个特殊而且有限定范围的主题。 历史书在说一个故事，而这个故事当然是发生在一个特定的时间里。 这与我何干？历史会建议一些可行性，因为那是以前的人已经做过的事。 传记包含很多类型： 定案本 (definitive) 的传记是对一个人的一生作详尽完整的学术性报告，这个人重要到够得上写这种完结篇的传记。定案本的传记决不能用来写活着的人。 授权本 (authorized) 的传记通常是由继承人，或是某个重要人物的朋友来负责的。读这种书不能像读一般的历史书一样，读者必须了解作者可能会有偏见。 自传所写的都是还未完结的生活。对于任何自传都要有一点疑心，同时别忘了，在你还不了解一本书之前，不要妄下论断。 阅读科学与数学 科学的客观不在于没有最初的偏见，而在于坦白承认。 科学基本上是归纳法，基本的论述也就是经由研究查证，建立出来的一个通则。 只要你记住，你的责任不是成为这个主题的专家，而是要去了解相关的问题，在阅读时就会轻松许多。 阅读哲学书我想在进一步阅读或学习如何阅读哲学书之前，最好针对这个相对特殊的类别有一个简要的科普。待我对其窥见一斑后再回来补充这一章节。 阅读社会科学 社会科学不是一个完全独立的学科。诸如人类学、经济学、政治学、社会学的学科，都是组成社会科学的核心。大部分有关法律、教育、公共行政的作品，及一部分商业、社会服务的作品，再加上大量的心理学作品，也适合社会科学的定义。 阅读社会科学时，关于一个主题通常要读好几本书，而不会只读一本书。主要的着眼点在一个特殊的事件或问题上，而非一个特殊的作者或一本书。 主题阅读 在作主题阅读时，第一个要求就是知道：对一个特定的问题来说，所牵涉的绝对不是一本书而已。第二个要求则是：要知道就总的来说，应该读的是哪些书？第二个要求比第一个要求还难做到。 分析阅读的技巧只适用于单一的作品，主要的目标是要了解这本书。 在主题阅读的准备阶段包含如下步骤： 针对你要研究的主题，设计一份实验性的书目。你可以参考图书馆目录，专家的建议与书中的书目索引。 浏览这份书目上所有的书，确定哪些与你的主题相关，并就你的主题建立起清楚的概念。 主题阅读一共有五个步骤，这些步骤不能称之为规则，因为只要漏掉其中一个步骤，主题阅读就会变得很困难。 浏览所有在准备阶段被认定与你主题相关的书，找出最相关的章节。 根据主题创造出一套中立的词汇，带引作者与你达成共识，无论作者是否实际用到这些词汇，所有的作者，或至少绝大部分的作者都可以用这套词汇来诠释。 建立一个中立的主旨，列出一连串的问题，无论作者是否明白谈过这些问题，所有的作者，或者至少大多数的作者都要能解读为针对这些问题提供了他们的回答。 界定主要及次要的议题。然后将作者针对各个问题的不同意见整理陈列在各个议题之旁。你要记住，各个作者之间或之中，不见得一定存在着某个议题。有时候，你需要针对一些不是作者主要关心的范围的事情，把他的观点解读，才能建构出这种议题。 分析这些讨论。这得把问题和议题按照顺序排列，以求突显主题。比较有共通性的议题，要放在比较没有共通性的议题之前。各个议题之间的关系也要清楚得界定出来。 心智成长 对你来说最重要的是，你不只要能读得好，还有有能力分辨出哪些书能够帮助你增进阅读能力。 读一本好书，会让你的努力有所回报： 当你成功地阅读了一本难读的好书之后，你的阅读技巧必然增进了。 一本好书能教你了解这个世界以及你自己。 一本书如果是可以让你学习的书，重读的时候，你会发现书中的内容好像比你记忆中的少了许多。如果这本书属于更高层次的书，你在重读的时候会发现这本书好像与你一起成长了。 好的阅读，也就是主动的阅读，不只是对阅读本身有用，也不只是对我们的工作或事业有帮助，更能帮助我们的心智保持活力与成长。 再次申明，本文来源：https://leovan.me/cn/2019/02/how-to-read-a-book/ （Copyright © 2017-2024 范叶亮 | Leo Van）","categories":[{"name":"读书","slug":"读书","permalink":"https://shuangdeyu.github.io/categories/%E8%AF%BB%E4%B9%A6/"}],"tags":[{"name":"工具书","slug":"工具书","permalink":"https://shuangdeyu.github.io/tags/%E5%B7%A5%E5%85%B7%E4%B9%A6/"},{"name":"经典","slug":"经典","permalink":"https://shuangdeyu.github.io/tags/%E7%BB%8F%E5%85%B8/"}]},{"title":"gofpdf示例文档","slug":"gofpdf示例文档","date":"2024-01-29T16:00:00.000Z","updated":"2024-01-31T02:05:50.429Z","comments":true,"path":"2024/01/30/gofpdf-shi-li-wen-dang/","link":"","permalink":"https://shuangdeyu.github.io/2024/01/30/gofpdf-shi-li-wen-dang/","excerpt":"","text":"最近在做Golang创建PDF方面的项目，一通找寻后主要定位到了两个现成的PDF库，也是网上比较流行的直接引用库，一个是gopdf，另一个是gofpdf 这两个库基本功能大致相同，都包含了常用的一些PDF功能，但还是有一些区别，正是这些区别导致我选择了gofpdf gofpdf 已经归档了，不再更新，而 gopdf 还在更新中，但更新速度也是比较缓慢的，最近一次更新还是两个月前 而 gofpdf 对字体样式的支持更加丰富，能够设置加粗，斜体等功能，所以我的项目中选择了它，不过它的文档不够丰富，所以我翻译了下它test文件里面的代码，当做一个示例查询目录，使用的时候方便点 基础func Example() &#123; pdf := gofpdf.New(gofpdf.OrientationPortrait, \"mm\", \"A4\", \"\") pdf.AddPage() pdf.SetFont(\"Arial\", \"B\", 16) pdf.Cell(40, 10, \"Hello World!\") fileStr := example.Filename(\"basic\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/basic.pdf &#125; 演示页眉、页脚和分页符的生成// ExampleFpdf_AddPage demonsrates the generation of headers, footers and page breaks. func ExampleFpdf_AddPage() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.SetTopMargin(30) pdf.SetHeaderFuncMode(func() &#123; pdf.Image(example.ImageFile(\"logo.png\"), 10, 6, 30, 0, false, \"\", 0, \"\") pdf.SetY(5) pdf.SetFont(\"Arial\", \"B\", 15) pdf.Cell(80, 0, \"\") pdf.CellFormat(30, 10, \"Title\", \"1\", 0, \"C\", false, 0, \"\") pdf.Ln(20) &#125;, true) pdf.SetFooterFunc(func() &#123; pdf.SetY(-15) pdf.SetFont(\"Arial\", \"I\", 8) pdf.CellFormat(0, 10, fmt.Sprintf(\"Page %d/&#123;nb&#125;\", pdf.PageNo()), \"\", 0, \"C\", false, 0, \"\") &#125;) pdf.AliasNbPages(\"\") pdf.AddPage() pdf.SetFont(\"Times\", \"\", 12) for j := 1; j &lt;= 40; j++ &#123; pdf.CellFormat(0, 10, fmt.Sprintf(\"Printing line number %d\", j), \"\", 1, \"\", false, 0, \"\") &#125; fileStr := example.Filename(\"Fpdf_AddPage\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_AddPage.pdf &#125; 演示换行、行对齐和分页// ExampleFpdf_MultiCell demonstrates word-wrapping, line justification and // page-breaking. func ExampleFpdf_MultiCell() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") titleStr := \"20000 Leagues Under the Seas\" pdf.SetTitle(titleStr, false) pdf.SetAuthor(\"Jules Verne\", false) pdf.SetHeaderFunc(func() &#123; // Arial bold 15 pdf.SetFont(\"Arial\", \"B\", 15) // Calculate width of title and position wd := pdf.GetStringWidth(titleStr) + 6 pdf.SetX((210 - wd) / 2) // Colors of frame, background and text pdf.SetDrawColor(0, 80, 180) pdf.SetFillColor(230, 230, 0) pdf.SetTextColor(220, 50, 50) // Thickness of frame (1 mm) pdf.SetLineWidth(1) // Title pdf.CellFormat(wd, 9, titleStr, \"1\", 1, \"C\", true, 0, \"\") // Line break pdf.Ln(10) &#125;) pdf.SetFooterFunc(func() &#123; // Position at 1.5 cm from bottom pdf.SetY(-15) // Arial italic 8 pdf.SetFont(\"Arial\", \"I\", 8) // Text color in gray pdf.SetTextColor(128, 128, 128) // Page number pdf.CellFormat(0, 10, fmt.Sprintf(\"Page %d\", pdf.PageNo()), \"\", 0, \"C\", false, 0, \"\") &#125;) chapterTitle := func(chapNum int, titleStr string) &#123; // // Arial 12 pdf.SetFont(\"Arial\", \"\", 12) // Background color pdf.SetFillColor(200, 220, 255) // Title pdf.CellFormat(0, 6, fmt.Sprintf(\"Chapter %d : %s\", chapNum, titleStr), \"\", 1, \"L\", true, 0, \"\") // Line break pdf.Ln(4) &#125; chapterBody := func(fileStr string) &#123; // Read text file txtStr, err := ioutil.ReadFile(fileStr) if err != nil &#123; pdf.SetError(err) &#125; // Times 12 pdf.SetFont(\"Times\", \"\", 12) // Output justified text pdf.MultiCell(0, 5, string(txtStr), \"\", \"\", false) // Line break pdf.Ln(-1) // Mention in italics pdf.SetFont(\"\", \"I\", 0) pdf.Cell(0, 5, \"(end of excerpt)\") &#125; printChapter := func(chapNum int, titleStr, fileStr string) &#123; pdf.AddPage() chapterTitle(chapNum, titleStr) chapterBody(fileStr) &#125; printChapter(1, \"A RUNAWAY REEF\", example.TextFile(\"20k_c1.txt\")) printChapter(2, \"THE PROS AND CONS\", example.TextFile(\"20k_c2.txt\")) fileStr := example.Filename(\"Fpdf_MultiCell\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_MultiCell.pdf &#125; 演示如何生成具有多列的PDF文档这是通过SetLeftMargin()和Cell()方法完成的 // ExampleFpdf_SetLeftMargin demonstrates the generation of a PDF document that has multiple // columns. This is accomplished with the SetLeftMargin() and Cell() methods. func ExampleFpdf_SetLeftMargin() &#123; var y0 float64 var crrntCol int pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.SetDisplayMode(\"fullpage\", \"TwoColumnLeft\") titleStr := \"20000 Leagues Under the Seas\" pdf.SetTitle(titleStr, false) pdf.SetAuthor(\"Jules Verne\", false) setCol := func(col int) &#123; // Set position at a given column crrntCol = col x := 10.0 + float64(col)*65.0 pdf.SetLeftMargin(x) pdf.SetX(x) &#125; chapterTitle := func(chapNum int, titleStr string) &#123; // Arial 12 pdf.SetFont(\"Arial\", \"\", 12) // Background color pdf.SetFillColor(200, 220, 255) // Title pdf.CellFormat(0, 6, fmt.Sprintf(\"Chapter %d : %s\", chapNum, titleStr), \"\", 1, \"L\", true, 0, \"\") // Line break pdf.Ln(4) y0 = pdf.GetY() &#125; chapterBody := func(fileStr string) &#123; // Read text file txtStr, err := ioutil.ReadFile(fileStr) if err != nil &#123; pdf.SetError(err) &#125; // Font pdf.SetFont(\"Times\", \"\", 12) // Output text in a 6 cm width column pdf.MultiCell(60, 5, string(txtStr), \"\", \"\", false) pdf.Ln(-1) // Mention pdf.SetFont(\"\", \"I\", 0) pdf.Cell(0, 5, \"(end of excerpt)\") // Go back to first column setCol(0) &#125; printChapter := func(num int, titleStr, fileStr string) &#123; // Add chapter pdf.AddPage() chapterTitle(num, titleStr) chapterBody(fileStr) &#125; pdf.SetAcceptPageBreakFunc(func() bool &#123; // Method accepting or not automatic page break if crrntCol &lt; 2 &#123; // Go to next column setCol(crrntCol + 1) // Set ordinate to top pdf.SetY(y0) // Keep on page return false &#125; // Go back to first column setCol(0) // Page break return true &#125;) pdf.SetHeaderFunc(func() &#123; // Arial bold 15 pdf.SetFont(\"Arial\", \"B\", 15) // Calculate width of title and position wd := pdf.GetStringWidth(titleStr) + 6 pdf.SetX((210 - wd) / 2) // Colors of frame, background and text pdf.SetDrawColor(0, 80, 180) pdf.SetFillColor(230, 230, 0) pdf.SetTextColor(220, 50, 50) // Thickness of frame (1 mm) pdf.SetLineWidth(1) // Title pdf.CellFormat(wd, 9, titleStr, \"1\", 1, \"C\", true, 0, \"\") // Line break pdf.Ln(10) // Save ordinate y0 = pdf.GetY() &#125;) pdf.SetFooterFunc(func() &#123; // Position at 1.5 cm from bottom pdf.SetY(-15) // Arial italic 8 pdf.SetFont(\"Arial\", \"I\", 8) // Text color in gray pdf.SetTextColor(128, 128, 128) // Page number pdf.CellFormat(0, 10, fmt.Sprintf(\"Page %d\", pdf.PageNo()), \"\", 0, \"C\", false, 0, \"\") &#125;) printChapter(1, \"A RUNAWAY REEF\", example.TextFile(\"20k_c1.txt\")) printChapter(2, \"THE PROS AND CONS\", example.TextFile(\"20k_c2.txt\")) fileStr := example.Filename(\"Fpdf_SetLeftMargin_multicolumn\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_SetLeftMargin_multicolumn.pdf &#125; 演示文字换行的表格单元格// ExampleFpdf_SplitLines_tables demonstrates word-wrapped table cells func ExampleFpdf_SplitLines_tables() &#123; const ( colCount = 3 colWd = 60.0 marginH = 15.0 lineHt = 5.5 cellGap = 2.0 ) // var colStrList [colCount]string type cellType struct &#123; str string list [][]byte ht float64 &#125; var ( cellList [colCount]cellType cell cellType ) pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") // 210 x 297 header := [colCount]string&#123;\"Column A\", \"Column B\", \"Column C\"&#125; alignList := [colCount]string&#123;\"L\", \"C\", \"R\"&#125; strList := loremList() pdf.SetMargins(marginH, 15, marginH) pdf.SetFont(\"Arial\", \"\", 14) pdf.AddPage() // Headers pdf.SetTextColor(224, 224, 224) pdf.SetFillColor(64, 64, 64) for colJ := 0; colJ &lt; colCount; colJ++ &#123; pdf.CellFormat(colWd, 10, header[colJ], \"1\", 0, \"CM\", true, 0, \"\") &#125; pdf.Ln(-1) pdf.SetTextColor(24, 24, 24) pdf.SetFillColor(255, 255, 255) // Rows y := pdf.GetY() count := 0 for rowJ := 0; rowJ &lt; 2; rowJ++ &#123; maxHt := lineHt // Cell height calculation loop for colJ := 0; colJ &lt; colCount; colJ++ &#123; count++ if count > len(strList) &#123; count = 1 &#125; cell.str = strings.Join(strList[0:count], \" \") cell.list = pdf.SplitLines([]byte(cell.str), colWd-cellGap-cellGap) cell.ht = float64(len(cell.list)) * lineHt if cell.ht > maxHt &#123; maxHt = cell.ht &#125; cellList[colJ] = cell &#125; // Cell render loop x := marginH for colJ := 0; colJ &lt; colCount; colJ++ &#123; pdf.Rect(x, y, colWd, maxHt+cellGap+cellGap, \"D\") cell = cellList[colJ] cellY := y + cellGap + (maxHt-cell.ht)/2 for splitJ := 0; splitJ &lt; len(cell.list); splitJ++ &#123; pdf.SetXY(x+cellGap, cellY) pdf.CellFormat(colWd-cellGap-cellGap, lineHt, string(cell.list[splitJ]), \"\", 0, alignList[colJ], false, 0, \"\") cellY += lineHt &#125; x += colWd &#125; y += maxHt + cellGap + cellGap &#125; fileStr := example.Filename(\"Fpdf_SplitLines_tables\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_SplitLines_tables.pdf &#125; 演示各种表格样式// ExampleFpdf_CellFormat_tables demonstrates various table styles. func ExampleFpdf_CellFormat_tables() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") type countryType struct &#123; nameStr, capitalStr, areaStr, popStr string &#125; countryList := make([]countryType, 0, 8) header := []string&#123;\"Country\", \"Capital\", \"Area (sq km)\", \"Pop. (thousands)\"&#125; loadData := func(fileStr string) &#123; fl, err := os.Open(fileStr) if err == nil &#123; scanner := bufio.NewScanner(fl) var c countryType for scanner.Scan() &#123; // Austria;Vienna;83859;8075 lineStr := scanner.Text() list := strings.Split(lineStr, \";\") if len(list) == 4 &#123; c.nameStr = list[0] c.capitalStr = list[1] c.areaStr = list[2] c.popStr = list[3] countryList = append(countryList, c) &#125; else &#123; err = fmt.Errorf(\"error tokenizing %s\", lineStr) &#125; &#125; fl.Close() if len(countryList) == 0 &#123; err = fmt.Errorf(\"error loading data from %s\", fileStr) &#125; &#125; if err != nil &#123; pdf.SetError(err) &#125; &#125; // Simple table basicTable := func() &#123; left := (210.0 - 4*40) / 2 pdf.SetX(left) for _, str := range header &#123; pdf.CellFormat(40, 7, str, \"1\", 0, \"\", false, 0, \"\") &#125; pdf.Ln(-1) for _, c := range countryList &#123; pdf.SetX(left) pdf.CellFormat(40, 6, c.nameStr, \"1\", 0, \"\", false, 0, \"\") pdf.CellFormat(40, 6, c.capitalStr, \"1\", 0, \"\", false, 0, \"\") pdf.CellFormat(40, 6, c.areaStr, \"1\", 0, \"\", false, 0, \"\") pdf.CellFormat(40, 6, c.popStr, \"1\", 0, \"\", false, 0, \"\") pdf.Ln(-1) &#125; &#125; // Better table improvedTable := func() &#123; // Column widths w := []float64&#123;40.0, 35.0, 40.0, 45.0&#125; wSum := 0.0 for _, v := range w &#123; wSum += v &#125; left := (210 - wSum) / 2 // Header pdf.SetX(left) for j, str := range header &#123; pdf.CellFormat(w[j], 7, str, \"1\", 0, \"C\", false, 0, \"\") &#125; pdf.Ln(-1) // Data for _, c := range countryList &#123; pdf.SetX(left) pdf.CellFormat(w[0], 6, c.nameStr, \"LR\", 0, \"\", false, 0, \"\") pdf.CellFormat(w[1], 6, c.capitalStr, \"LR\", 0, \"\", false, 0, \"\") pdf.CellFormat(w[2], 6, strDelimit(c.areaStr, \",\", 3), \"LR\", 0, \"R\", false, 0, \"\") pdf.CellFormat(w[3], 6, strDelimit(c.popStr, \",\", 3), \"LR\", 0, \"R\", false, 0, \"\") pdf.Ln(-1) &#125; pdf.SetX(left) pdf.CellFormat(wSum, 0, \"\", \"T\", 0, \"\", false, 0, \"\") &#125; // Colored table fancyTable := func() &#123; // Colors, line width and bold font pdf.SetFillColor(255, 0, 0) pdf.SetTextColor(255, 255, 255) pdf.SetDrawColor(128, 0, 0) pdf.SetLineWidth(.3) pdf.SetFont(\"\", \"B\", 0) // Header w := []float64&#123;40, 35, 40, 45&#125; wSum := 0.0 for _, v := range w &#123; wSum += v &#125; left := (210 - wSum) / 2 pdf.SetX(left) for j, str := range header &#123; pdf.CellFormat(w[j], 7, str, \"1\", 0, \"C\", true, 0, \"\") &#125; pdf.Ln(-1) // Color and font restoration pdf.SetFillColor(224, 235, 255) pdf.SetTextColor(0, 0, 0) pdf.SetFont(\"\", \"\", 0) // Data fill := false for _, c := range countryList &#123; pdf.SetX(left) pdf.CellFormat(w[0], 6, c.nameStr, \"LR\", 0, \"\", fill, 0, \"\") pdf.CellFormat(w[1], 6, c.capitalStr, \"LR\", 0, \"\", fill, 0, \"\") pdf.CellFormat(w[2], 6, strDelimit(c.areaStr, \",\", 3), \"LR\", 0, \"R\", fill, 0, \"\") pdf.CellFormat(w[3], 6, strDelimit(c.popStr, \",\", 3), \"LR\", 0, \"R\", fill, 0, \"\") pdf.Ln(-1) fill = !fill &#125; pdf.SetX(left) pdf.CellFormat(wSum, 0, \"\", \"T\", 0, \"\", false, 0, \"\") &#125; loadData(example.TextFile(\"countries.txt\")) pdf.SetFont(\"Arial\", \"\", 14) pdf.AddPage() basicTable() pdf.AddPage() improvedTable() pdf.AddPage() fancyTable() fileStr := example.Filename(\"Fpdf_CellFormat_tables\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_CellFormat_tables.pdf &#125; 演示带有和不带基本 HTML 的内部和外部链接// ExampleFpdf_HTMLBasicNew demonstrates internal and external links with and without basic // HTML. func ExampleFpdf_HTMLBasicNew() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") // First page: manual local link pdf.AddPage() pdf.SetFont(\"Helvetica\", \"\", 20) _, lineHt := pdf.GetFontSize() pdf.Write(lineHt, \"To find out what's new in this tutorial, click \") pdf.SetFont(\"\", \"U\", 0) link := pdf.AddLink() pdf.WriteLinkID(lineHt, \"here\", link) pdf.SetFont(\"\", \"\", 0) // Second page: image link and basic HTML with link pdf.AddPage() pdf.SetLink(link, 0, -1) pdf.Image(example.ImageFile(\"logo.png\"), 10, 12, 30, 0, false, \"\", 0, \"http://www.fpdf.org\") pdf.SetLeftMargin(45) pdf.SetFontSize(14) _, lineHt = pdf.GetFontSize() htmlStr := `You can now easily print text mixing different styles: &lt;b>bold&lt;/b>, ` + `&lt;i>italic&lt;/i>, &lt;u>underlined&lt;/u>, or &lt;b>&lt;i>&lt;u>all at once&lt;/u>&lt;/i>&lt;/b>!&lt;br>&lt;br>` + `&lt;center>You can also center text.&lt;/center>` + `&lt;right>Or align it to the right.&lt;/right>` + `You can also insert links on text, such as ` + `&lt;a href=\"http://www.fpdf.org\">www.fpdf.org&lt;/a>, or on an image: click on the logo.` html := pdf.HTMLBasicNew() html.Write(lineHt, htmlStr) fileStr := example.Filename(\"Fpdf_HTMLBasicNew\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_HTMLBasicNew.pdf &#125; 演示非标准字体的使用// ExampleFpdf_AddFont demonstrates the use of a non-standard font. func ExampleFpdf_AddFont() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", example.FontDir()) pdf.AddFont(\"Calligrapher\", \"\", \"calligra.json\") pdf.AddPage() pdf.SetFont(\"Calligrapher\", \"\", 35) pdf.Cell(0, 10, \"Enjoy new fonts with FPDF!\") fileStr := example.Filename(\"Fpdf_AddFont\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_AddFont.pdf &#125; 演示如何使用Write函数对齐文本// ExampleFpdf_WriteAligned demonstrates how to align text with the Write function. func ExampleFpdf_WriteAligned() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", example.FontDir()) pdf.SetLeftMargin(50.0) pdf.SetRightMargin(50.0) pdf.AddPage() pdf.SetFont(\"Helvetica\", \"\", 12) pdf.WriteAligned(0, 35, \"This text is the default alignment, Left\", \"\") pdf.Ln(35) pdf.WriteAligned(0, 35, \"This text is aligned Left\", \"L\") pdf.Ln(35) pdf.WriteAligned(0, 35, \"This text is aligned Center\", \"C\") pdf.Ln(35) pdf.WriteAligned(0, 35, \"This text is aligned Right\", \"R\") pdf.Ln(35) line := \"This can by used to write justified text\" leftMargin, _, rightMargin, _ := pdf.GetMargins() pageWidth, _ := pdf.GetPageSize() pageWidth -= leftMargin + rightMargin pdf.SetWordSpacing((pageWidth - pdf.GetStringWidth(line)) / float64(strings.Count(line, \" \"))) pdf.WriteAligned(pageWidth, 35, line, \"L\") fileStr := example.Filename(\"Fpdf_WriteAligned\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_WriteAligned.pdf &#125; 演示如何将图像包含在文档中// ExampleFpdf_Image demonstrates how images are included in documents. func ExampleFpdf_Image() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.AddPage() pdf.SetFont(\"Arial\", \"\", 11) pdf.Image(example.ImageFile(\"logo.png\"), 10, 10, 30, 0, false, \"\", 0, \"\") pdf.Text(50, 20, \"logo.png\") pdf.Image(example.ImageFile(\"logo.gif\"), 10, 40, 30, 0, false, \"\", 0, \"\") pdf.Text(50, 50, \"logo.gif\") pdf.Image(example.ImageFile(\"logo-gray.png\"), 10, 70, 30, 0, false, \"\", 0, \"\") pdf.Text(50, 80, \"logo-gray.png\") pdf.Image(example.ImageFile(\"logo-rgb.png\"), 10, 100, 30, 0, false, \"\", 0, \"\") pdf.Text(50, 110, \"logo-rgb.png\") pdf.Image(example.ImageFile(\"logo.jpg\"), 10, 130, 30, 0, false, \"\", 0, \"\") pdf.Text(50, 140, \"logo.jpg\") fileStr := example.Filename(\"Fpdf_Image\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_Image.pdf &#125; 演示了如何使用ImageOption结构体的AllowNegativePosition字段来影响图像的水平位置// ExampleFpdf_ImageOptions demonstrates how the AllowNegativePosition field of the // ImageOption struct can be used to affect horizontal image placement. func ExampleFpdf_ImageOptions() &#123; var opt gofpdf.ImageOptions pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.AddPage() pdf.SetFont(\"Arial\", \"\", 11) pdf.SetX(60) opt.ImageType = \"png\" pdf.ImageOptions(example.ImageFile(\"logo.png\"), -10, 10, 30, 0, false, opt, 0, \"\") opt.AllowNegativePosition = true pdf.ImageOptions(example.ImageFile(\"logo.png\"), -10, 50, 30, 0, false, opt, 0, \"\") fileStr := example.Filename(\"Fpdf_ImageOptions\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_ImageOptions.pdf &#125; 演示如何从io加载图像Reader(在本例中是一个文件)并将其注册为options // ExampleFpdf_RegisterImageOptionsReader demonstrates how to load an image // from a io.Reader (in this case, a file) and register it with options. func ExampleFpdf_RegisterImageOptionsReader() &#123; var ( opt gofpdf.ImageOptions pdfStr string fl *os.File err error ) pdfStr = example.Filename(\"Fpdf_RegisterImageOptionsReader\") pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.AddPage() pdf.SetFont(\"Arial\", \"\", 11) fl, err = os.Open(example.ImageFile(\"logo.png\")) if err == nil &#123; opt.ImageType = \"png\" opt.AllowNegativePosition = true _ = pdf.RegisterImageOptionsReader(\"logo\", opt, fl) fl.Close() for x := -20.0; x &lt;= 40.0; x += 5 &#123; pdf.ImageOptions(\"logo\", x, x+30, 0, 0, false, opt, 0, \"\") &#125; err = pdf.OutputFileAndClose(pdfStr) &#125; example.Summary(err, pdfStr) // Output: // Successfully generated pdf/Fpdf_RegisterImageOptionsReader.pdf &#125; 演示了带有图像的横向模式// This example demonstrates Landscape mode with images. func ExampleFpdf_SetAcceptPageBreakFunc() &#123; var y0 float64 var crrntCol int loremStr := lorem() pdf := gofpdf.New(\"L\", \"mm\", \"A4\", \"\") const ( pageWd = 297.0 // A4 210.0 x 297.0 margin = 10.0 gutter = 4 colNum = 3 colWd = (pageWd - 2*margin - (colNum-1)*gutter) / colNum ) setCol := func(col int) &#123; crrntCol = col x := margin + float64(col)*(colWd+gutter) pdf.SetLeftMargin(x) pdf.SetX(x) &#125; pdf.SetHeaderFunc(func() &#123; titleStr := \"gofpdf\" pdf.SetFont(\"Helvetica\", \"B\", 48) wd := pdf.GetStringWidth(titleStr) + 6 pdf.SetX((pageWd - wd) / 2) pdf.SetTextColor(128, 128, 160) pdf.Write(12, titleStr[:2]) pdf.SetTextColor(128, 128, 128) pdf.Write(12, titleStr[2:]) pdf.Ln(20) y0 = pdf.GetY() &#125;) pdf.SetAcceptPageBreakFunc(func() bool &#123; if crrntCol &lt; colNum-1 &#123; setCol(crrntCol + 1) pdf.SetY(y0) // Start new column, not new page return false &#125; setCol(0) return true &#125;) pdf.AddPage() pdf.SetFont(\"Times\", \"\", 12) for j := 0; j &lt; 20; j++ &#123; if j == 1 &#123; pdf.Image(example.ImageFile(\"fpdf.png\"), -1, 0, colWd, 0, true, \"\", 0, \"\") &#125; else if j == 5 &#123; pdf.Image(example.ImageFile(\"golang-gopher.png\"), -1, 0, colWd, 0, true, \"\", 0, \"\") &#125; pdf.MultiCell(colWd, 5, loremStr, \"\", \"\", false) pdf.Ln(-1) &#125; fileStr := example.Filename(\"Fpdf_SetAcceptPageBreakFunc_landscape\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_SetAcceptPageBreakFunc_landscape.pdf &#125; 演示各种几何图形的构造// ExampleFpdf_Circle demonstrates the construction of various geometric figures, func ExampleFpdf_Circle() &#123; const ( thin = 0.2 thick = 3.0 ) pdf := gofpdf.New(\"\", \"\", \"\", \"\") pdf.SetFont(\"Helvetica\", \"\", 12) pdf.SetFillColor(200, 200, 220) pdf.AddPage() y := 15.0 pdf.Text(10, y, \"Circles\") pdf.SetFillColor(200, 200, 220) pdf.SetLineWidth(thin) pdf.Circle(20, y+15, 10, \"D\") pdf.Circle(45, y+15, 10, \"F\") pdf.Circle(70, y+15, 10, \"FD\") pdf.SetLineWidth(thick) pdf.Circle(95, y+15, 10, \"FD\") pdf.SetLineWidth(thin) y += 40.0 pdf.Text(10, y, \"Ellipses\") pdf.SetFillColor(220, 200, 200) pdf.Ellipse(30, y+15, 20, 10, 0, \"D\") pdf.Ellipse(75, y+15, 20, 10, 0, \"F\") pdf.Ellipse(120, y+15, 20, 10, 0, \"FD\") pdf.SetLineWidth(thick) pdf.Ellipse(165, y+15, 20, 10, 0, \"FD\") pdf.SetLineWidth(thin) y += 40.0 pdf.Text(10, y, \"Curves (quadratic)\") pdf.SetFillColor(220, 220, 200) pdf.Curve(10, y+30, 15, y-20, 40, y+30, \"D\") pdf.Curve(45, y+30, 50, y-20, 75, y+30, \"F\") pdf.Curve(80, y+30, 85, y-20, 110, y+30, \"FD\") pdf.SetLineWidth(thick) pdf.Curve(115, y+30, 120, y-20, 145, y+30, \"FD\") pdf.SetLineCapStyle(\"round\") pdf.Curve(150, y+30, 155, y-20, 180, y+30, \"FD\") pdf.SetLineWidth(thin) pdf.SetLineCapStyle(\"butt\") y += 40.0 pdf.Text(10, y, \"Curves (cubic)\") pdf.SetFillColor(220, 200, 220) pdf.CurveBezierCubic(10, y+30, 15, y-20, 10, y+30, 40, y+30, \"D\") pdf.CurveBezierCubic(45, y+30, 50, y-20, 45, y+30, 75, y+30, \"F\") pdf.CurveBezierCubic(80, y+30, 85, y-20, 80, y+30, 110, y+30, \"FD\") pdf.SetLineWidth(thick) pdf.CurveBezierCubic(115, y+30, 120, y-20, 115, y+30, 145, y+30, \"FD\") pdf.SetLineCapStyle(\"round\") pdf.CurveBezierCubic(150, y+30, 155, y-20, 150, y+30, 180, y+30, \"FD\") pdf.SetLineWidth(thin) pdf.SetLineCapStyle(\"butt\") y += 40.0 pdf.Text(10, y, \"Arcs\") pdf.SetFillColor(200, 220, 220) pdf.SetLineWidth(thick) pdf.Arc(45, y+35, 20, 10, 0, 0, 180, \"FD\") pdf.SetLineWidth(thin) pdf.Arc(45, y+35, 25, 15, 0, 90, 270, \"D\") pdf.SetLineWidth(thick) pdf.Arc(45, y+35, 30, 20, 0, 0, 360, \"D\") pdf.SetLineCapStyle(\"round\") pdf.Arc(135, y+35, 20, 10, 135, 0, 180, \"FD\") pdf.SetLineWidth(thin) pdf.Arc(135, y+35, 25, 15, 135, 90, 270, \"D\") pdf.SetLineWidth(thick) pdf.Arc(135, y+35, 30, 20, 135, 0, 360, \"D\") pdf.SetLineWidth(thin) pdf.SetLineCapStyle(\"butt\") fileStr := example.Filename(\"Fpdf_Circle_figures\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_Circle_figures.pdf &#125; 演示alpha透明度func ExampleFpdf_SetAlpha() &#123; const ( gapX = 10.0 gapY = 9.0 rectW = 40.0 rectH = 58.0 pageW = 210 pageH = 297 ) modeList := []string&#123;\"Normal\", \"Multiply\", \"Screen\", \"Overlay\", \"Darken\", \"Lighten\", \"ColorDodge\", \"ColorBurn\", \"HardLight\", \"SoftLight\", \"Difference\", \"Exclusion\", \"Hue\", \"Saturation\", \"Color\", \"Luminosity\"&#125; pdf := gofpdf.New(\"\", \"\", \"\", \"\") pdf.SetLineWidth(2) pdf.SetAutoPageBreak(false, 0) pdf.AddPage() pdf.SetFont(\"Helvetica\", \"\", 18) pdf.SetXY(0, gapY) pdf.SetTextColor(0, 0, 0) pdf.CellFormat(pageW, gapY, \"Alpha Blending Modes\", \"\", 0, \"C\", false, 0, \"\") j := 0 y := 3 * gapY for col := 0; col &lt; 4; col++ &#123; x := gapX for row := 0; row &lt; 4; row++ &#123; pdf.Rect(x, y, rectW, rectH, \"D\") pdf.SetFont(\"Helvetica\", \"B\", 12) pdf.SetFillColor(0, 0, 0) pdf.SetTextColor(250, 250, 230) pdf.SetXY(x, y+rectH-4) pdf.CellFormat(rectW, 5, modeList[j], \"\", 0, \"C\", true, 0, \"\") pdf.SetFont(\"Helvetica\", \"I\", 150) pdf.SetTextColor(80, 80, 120) pdf.SetXY(x, y+2) pdf.CellFormat(rectW, rectH, \"A\", \"\", 0, \"C\", false, 0, \"\") pdf.SetAlpha(0.5, modeList[j]) pdf.Image(example.ImageFile(\"golang-gopher.png\"), x-gapX, y, rectW+2*gapX, 0, false, \"\", 0, \"\") pdf.SetAlpha(1.0, \"Normal\") x += rectW + gapX j++ &#125; y += rectH + gapY &#125; fileStr := example.Filename(\"Fpdf_SetAlpha_transparency\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_SetAlpha_transparency.pdf &#125; 演示各种梯度// ExampleFpdf_LinearGradient deomstrates various gradients. func ExampleFpdf_LinearGradient() &#123; pdf := gofpdf.New(\"\", \"\", \"\", \"\") pdf.SetFont(\"Helvetica\", \"\", 12) pdf.AddPage() pdf.LinearGradient(0, 0, 210, 100, 250, 250, 255, 220, 220, 225, 0, 0, 0, .5) pdf.LinearGradient(20, 25, 75, 75, 220, 220, 250, 80, 80, 220, 0, .2, 0, .8) pdf.Rect(20, 25, 75, 75, \"D\") pdf.LinearGradient(115, 25, 75, 75, 220, 220, 250, 80, 80, 220, 0, 0, 1, 1) pdf.Rect(115, 25, 75, 75, \"D\") pdf.RadialGradient(20, 120, 75, 75, 220, 220, 250, 80, 80, 220, 0.25, 0.75, 0.25, 0.75, 1) pdf.Rect(20, 120, 75, 75, \"D\") pdf.RadialGradient(115, 120, 75, 75, 220, 220, 250, 80, 80, 220, 0.25, 0.75, 0.75, 0.75, 0.75) pdf.Rect(115, 120, 75, 75, \"D\") fileStr := example.Filename(\"Fpdf_LinearGradient_gradient\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_LinearGradient_gradient.pdf &#125; 演示了剪裁// ExampleFpdf_ClipText demonstrates clipping. func ExampleFpdf_ClipText() &#123; pdf := gofpdf.New(\"\", \"\", \"\", \"\") y := 10.0 pdf.AddPage() pdf.SetFont(\"Helvetica\", \"\", 24) pdf.SetXY(0, y) pdf.ClipText(10, y+12, \"Clipping examples\", false) pdf.RadialGradient(10, y, 100, 20, 128, 128, 160, 32, 32, 48, 0.25, 0.5, 0.25, 0.5, 0.2) pdf.ClipEnd() y += 12 pdf.SetFont(\"Helvetica\", \"B\", 120) pdf.SetDrawColor(64, 80, 80) pdf.SetLineWidth(.5) pdf.ClipText(10, y+40, pdf.String(), true) pdf.RadialGradient(10, y, 200, 50, 220, 220, 250, 80, 80, 220, 0.25, 0.5, 0.25, 0.5, 1) pdf.ClipEnd() y += 55 pdf.ClipRect(10, y, 105, 20, true) pdf.SetFillColor(255, 255, 255) pdf.Rect(10, y, 105, 20, \"F\") pdf.ClipCircle(40, y+10, 15, false) pdf.RadialGradient(25, y, 30, 30, 220, 250, 220, 40, 60, 40, 0.3, 0.85, 0.3, 0.85, 0.5) pdf.ClipEnd() pdf.ClipEllipse(80, y+10, 20, 15, false) pdf.RadialGradient(60, y, 40, 30, 250, 220, 220, 60, 40, 40, 0.3, 0.85, 0.3, 0.85, 0.5) pdf.ClipEnd() pdf.ClipEnd() y += 28 pdf.ClipEllipse(26, y+10, 16, 10, true) pdf.Image(example.ImageFile(\"logo.jpg\"), 10, y, 32, 0, false, \"JPG\", 0, \"\") pdf.ClipEnd() pdf.ClipCircle(60, y+10, 10, true) pdf.RadialGradient(50, y, 20, 20, 220, 220, 250, 40, 40, 60, 0.3, 0.7, 0.3, 0.7, 0.5) pdf.ClipEnd() pdf.ClipPolygon([]gofpdf.PointType&#123;&#123;X: 80, Y: y + 20&#125;, &#123;X: 90, Y: y&#125;, &#123;X: 100, Y: y + 20&#125;&#125;, true) pdf.LinearGradient(80, y, 20, 20, 250, 220, 250, 60, 40, 60, 0.5, 1, 0.5, 0.5) pdf.ClipEnd() y += 30 pdf.SetLineWidth(.1) pdf.SetDrawColor(180, 180, 180) pdf.ClipRoundedRect(10, y, 120, 20, 5, true) pdf.RadialGradient(10, y, 120, 20, 255, 255, 255, 240, 240, 220, 0.25, 0.75, 0.25, 0.75, 0.5) pdf.SetXY(5, y-5) pdf.SetFont(\"Times\", \"\", 12) pdf.MultiCell(130, 5, lorem(), \"\", \"\", false) pdf.ClipEnd() y += 30 pdf.SetDrawColor(180, 100, 180) pdf.ClipRoundedRectExt(10, y, 120, 20, 5, 10, 5, 10, true) pdf.RadialGradient(10, y, 120, 20, 255, 255, 255, 240, 240, 220, 0.25, 0.75, 0.25, 0.75, 0.5) pdf.SetXY(5, y-5) pdf.SetFont(\"Times\", \"\", 12) pdf.MultiCell(130, 5, lorem(), \"\", \"\", false) pdf.ClipEnd() fileStr := example.Filename(\"Fpdf_ClipText\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_ClipText.pdf &#125; 生成具有不同页面大小的PDF文档// ExampleFpdf_PageSize generates a PDF document with various page sizes. func ExampleFpdf_PageSize() &#123; pdf := gofpdf.NewCustom(&amp;gofpdf.InitType&#123; UnitStr: \"in\", Size: gofpdf.SizeType&#123;Wd: 6, Ht: 6&#125;, FontDirStr: example.FontDir(), &#125;) pdf.SetMargins(0.5, 1, 0.5) pdf.SetFont(\"Times\", \"\", 14) pdf.AddPageFormat(\"L\", gofpdf.SizeType&#123;Wd: 3, Ht: 12&#125;) pdf.SetXY(0.5, 1.5) pdf.CellFormat(11, 0.2, \"12 in x 3 in\", \"\", 0, \"C\", false, 0, \"\") pdf.AddPage() // Default size established in NewCustom() pdf.SetXY(0.5, 3) pdf.CellFormat(5, 0.2, \"6 in x 6 in\", \"\", 0, \"C\", false, 0, \"\") pdf.AddPageFormat(\"P\", gofpdf.SizeType&#123;Wd: 3, Ht: 12&#125;) pdf.SetXY(0.5, 6) pdf.CellFormat(2, 0.2, \"3 in x 12 in\", \"\", 0, \"C\", false, 0, \"\") for j := 0; j &lt;= 3; j++ &#123; wd, ht, u := pdf.PageSize(j) fmt.Printf(\"%d: %6.2f %s, %6.2f %s\\n\", j, wd, u, ht, u) &#125; fileStr := example.Filename(\"Fpdf_PageSize\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // 0: 6.00 in, 6.00 in // 1: 12.00 in, 3.00 in // 2: 6.00 in, 6.00 in // 3: 3.00 in, 12.00 in // Successfully generated pdf/Fpdf_PageSize.pdf &#125; 演示Bookmark方法// ExampleFpdf_Bookmark demonstrates the Bookmark method. func ExampleFpdf_Bookmark() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.AddPage() pdf.SetFont(\"Arial\", \"\", 15) pdf.Bookmark(\"Page 1\", 0, 0) pdf.Bookmark(\"Paragraph 1\", 1, -1) pdf.Cell(0, 6, \"Paragraph 1\") pdf.Ln(50) pdf.Bookmark(\"Paragraph 2\", 1, -1) pdf.Cell(0, 6, \"Paragraph 2\") pdf.AddPage() pdf.Bookmark(\"Page 2\", 0, 0) pdf.Bookmark(\"Paragraph 3\", 1, -1) pdf.Cell(0, 6, \"Paragraph 3\") fileStr := example.Filename(\"Fpdf_Bookmark\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_Bookmark.pdf &#125; 演示各种转换它改编自Moritz Wagner和Andreas Würmser的示例脚本 // ExampleFpdf_TransformBegin demonstrates various transformations. It is adapted from an // example script by Moritz Wagner and Andreas Würmser. func ExampleFpdf_TransformBegin() &#123; const ( light = 200 dark = 0 ) var refX, refY float64 var refStr string pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.AddPage() color := func(val int) &#123; pdf.SetDrawColor(val, val, val) pdf.SetTextColor(val, val, val) &#125; reference := func(str string, x, y float64, val int) &#123; color(val) pdf.Rect(x, y, 40, 10, \"D\") pdf.Text(x, y-1, str) &#125; refDraw := func(str string, x, y float64) &#123; refStr = str refX = x refY = y reference(str, x, y, light) &#125; refDupe := func() &#123; reference(refStr, refX, refY, dark) &#125; titleStr := \"Transformations\" titlePt := 36.0 titleHt := pdf.PointConvert(titlePt) pdf.SetFont(\"Helvetica\", \"\", titlePt) titleWd := pdf.GetStringWidth(titleStr) titleX := (210 - titleWd) / 2 pdf.Text(titleX, 10+titleHt, titleStr) pdf.TransformBegin() pdf.TransformMirrorVertical(10 + titleHt + 0.5) pdf.ClipText(titleX, 10+titleHt, titleStr, false) // Remember that the transform will mirror the gradient box too pdf.LinearGradient(titleX, 10, titleWd, titleHt+4, 120, 120, 120, 255, 255, 255, 0, 0, 0, 0.6) pdf.ClipEnd() pdf.TransformEnd() pdf.SetFont(\"Helvetica\", \"\", 12) // Scale by 150% centered by lower left corner of the rectangle refDraw(\"Scale\", 50, 60) pdf.TransformBegin() pdf.TransformScaleXY(150, 50, 70) refDupe() pdf.TransformEnd() // Translate 7 to the right, 5 to the bottom refDraw(\"Translate\", 125, 60) pdf.TransformBegin() pdf.TransformTranslate(7, 5) refDupe() pdf.TransformEnd() // Rotate 20 degrees counter-clockwise centered by the lower left corner of // the rectangle refDraw(\"Rotate\", 50, 110) pdf.TransformBegin() pdf.TransformRotate(20, 50, 120) refDupe() pdf.TransformEnd() // Skew 30 degrees along the x-axis centered by the lower left corner of the // rectangle refDraw(\"Skew\", 125, 110) pdf.TransformBegin() pdf.TransformSkewX(30, 125, 110) refDupe() pdf.TransformEnd() // Mirror horizontally with axis of reflection at left side of the rectangle refDraw(\"Mirror horizontal\", 50, 160) pdf.TransformBegin() pdf.TransformMirrorHorizontal(50) refDupe() pdf.TransformEnd() // Mirror vertically with axis of reflection at bottom side of the rectangle refDraw(\"Mirror vertical\", 125, 160) pdf.TransformBegin() pdf.TransformMirrorVertical(170) refDupe() pdf.TransformEnd() // Reflect against a point at the lower left point of rectangle refDraw(\"Mirror point\", 50, 210) pdf.TransformBegin() pdf.TransformMirrorPoint(50, 220) refDupe() pdf.TransformEnd() // Mirror against a straight line described by a point and an angle angle := -20.0 px := 120.0 py := 220.0 refDraw(\"Mirror line\", 125, 210) pdf.TransformBegin() pdf.TransformRotate(angle, px, py) pdf.Line(px-1, py-1, px+1, py+1) pdf.Line(px-1, py+1, px+1, py-1) pdf.Line(px-5, py, px+60, py) pdf.TransformEnd() pdf.TransformBegin() pdf.TransformMirrorLine(angle, px, py) refDupe() pdf.TransformEnd() fileStr := example.Filename(\"Fpdf_TransformBegin\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_TransformBegin.pdf &#125; 演示Lawrence Kesteloot的图像注册代码// ExampleFpdf_RegisterImage demonstrates Lawrence Kesteloot's image registration code. func ExampleFpdf_RegisterImage() &#123; const ( margin = 10 wd = 210 ht = 297 ) fileList := []string&#123; \"logo-gray.png\", \"logo.jpg\", \"logo.png\", \"logo-rgb.png\", \"logo-progressive.jpg\", &#125; var infoPtr *gofpdf.ImageInfoType var imageFileStr string var imgWd, imgHt, lf, tp float64 pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.AddPage() pdf.SetMargins(10, 10, 10) pdf.SetFont(\"Helvetica\", \"\", 15) for j, str := range fileList &#123; imageFileStr = example.ImageFile(str) infoPtr = pdf.RegisterImage(imageFileStr, \"\") imgWd, imgHt = infoPtr.Extent() switch j &#123; case 0: lf = margin tp = margin case 1: lf = wd - margin - imgWd tp = margin case 2: lf = (wd - imgWd) / 2.0 tp = (ht - imgHt) / 2.0 case 3: lf = margin tp = ht - imgHt - margin case 4: lf = wd - imgWd - margin tp = ht - imgHt - margin &#125; pdf.Image(imageFileStr, lf, tp, imgWd, imgHt, false, \"\", 0, \"\") &#125; fileStr := example.Filename(\"Fpdf_RegisterImage\") // Test the image information retrieval method infoShow := func(imageStr string) &#123; imageStr = example.ImageFile(imageStr) info := pdf.GetImageInfo(imageStr) if info != nil &#123; if info.Width() > 0.0 &#123; fmt.Printf(\"Image %s is registered\\n\", filepath.ToSlash(imageStr)) &#125; else &#123; fmt.Printf(\"Incorrect information for image %s\\n\", filepath.ToSlash(imageStr)) &#125; &#125; else &#123; fmt.Printf(\"Image %s is not registered\\n\", filepath.ToSlash(imageStr)) &#125; &#125; infoShow(fileList[0]) infoShow(\"foo.png\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Image image/logo-gray.png is registered // Image image/foo.png is not registered // Successfully generated pdf/Fpdf_RegisterImage.pdf &#125; 演示布鲁诺米歇尔的分线功能// ExampleFpdf_SplitLines demonstrates Bruno Michel's line splitting function. func ExampleFpdf_SplitLines() &#123; const ( fontPtSize = 18.0 wd = 100.0 ) pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") // A4 210.0 x 297.0 pdf.SetFont(\"Times\", \"\", fontPtSize) _, lineHt := pdf.GetFontSize() pdf.AddPage() pdf.SetMargins(10, 10, 10) lines := pdf.SplitLines([]byte(lorem()), wd) ht := float64(len(lines)) * lineHt y := (297.0 - ht) / 2.0 pdf.SetDrawColor(128, 128, 128) pdf.SetFillColor(255, 255, 210) x := (210.0 - (wd + 40.0)) / 2.0 pdf.Rect(x, y-20.0, wd+40.0, ht+40.0, \"FD\") pdf.SetY(y) for _, line := range lines &#123; pdf.CellFormat(190.0, lineHt, string(line), \"\", 1, \"C\", false, 0, \"\") &#125; fileStr := example.Filename(\"Fpdf_Splitlines\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: &#125; 演示如何呈现由jSignature web控件生成的类型的简单纯路径SVG图像// ExampleFpdf_SVGBasicWrite demonstrates how to render a simple path-only SVG image of the // type generated by the jSignature web control. func ExampleFpdf_SVGBasicWrite() &#123; const ( fontPtSize = 16.0 wd = 100.0 sigFileStr = \"signature.svg\" ) var ( sig gofpdf.SVGBasicType err error ) pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") // A4 210.0 x 297.0 pdf.SetFont(\"Times\", \"\", fontPtSize) lineHt := pdf.PointConvert(fontPtSize) pdf.AddPage() pdf.SetMargins(10, 10, 10) htmlStr := `This example renders a simple ` + `&lt;a href=\"http://www.w3.org/TR/SVG/\">SVG&lt;/a> (scalable vector graphics) ` + `image that contains only basic path commands without any styling, ` + `color fill, reflection or endpoint closures. In particular, the ` + `type of vector graphic returned from a ` + `&lt;a href=\"http://willowsystems.github.io/jSignature/#/demo/\">jSignature&lt;/a> ` + `web control is supported and is used in this example.` html := pdf.HTMLBasicNew() html.Write(lineHt, htmlStr) sig, err = gofpdf.SVGBasicFileParse(example.ImageFile(sigFileStr)) if err == nil &#123; scale := 100 / sig.Wd scaleY := 30 / sig.Ht if scale > scaleY &#123; scale = scaleY &#125; pdf.SetLineCapStyle(\"round\") pdf.SetLineWidth(0.25) pdf.SetDrawColor(0, 0, 128) pdf.SetXY((210.0-scale*sig.Wd)/2.0, pdf.GetY()+10) pdf.SVGBasicWrite(&amp;sig, scale) &#125; else &#123; pdf.SetError(err) &#125; fileStr := example.Filename(\"Fpdf_SVGBasicWrite\") err = pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_SVGBasicWrite.pdf &#125; 演示了Stefan Schroeder的代码来控制垂直对齐// ExampleFpdf_CellFormat_align demonstrates Stefan Schroeder's code to control vertical // alignment. func ExampleFpdf_CellFormat_align() &#123; type recType struct &#123; align, txt string &#125; recList := []recType&#123; &#123;\"TL\", \"top left\"&#125;, &#123;\"TC\", \"top center\"&#125;, &#123;\"TR\", \"top right\"&#125;, &#123;\"LM\", \"middle left\"&#125;, &#123;\"CM\", \"middle center\"&#125;, &#123;\"RM\", \"middle right\"&#125;, &#123;\"BL\", \"bottom left\"&#125;, &#123;\"BC\", \"bottom center\"&#125;, &#123;\"BR\", \"bottom right\"&#125;, &#125; recListBaseline := []recType&#123; &#123;\"AL\", \"baseline left\"&#125;, &#123;\"AC\", \"baseline center\"&#125;, &#123;\"AR\", \"baseline right\"&#125;, &#125; var formatRect = func(pdf *gofpdf.Fpdf, recList []recType) &#123; linkStr := \"\" for pageJ := 0; pageJ &lt; 2; pageJ++ &#123; pdf.AddPage() pdf.SetMargins(10, 10, 10) pdf.SetAutoPageBreak(false, 0) borderStr := \"1\" for _, rec := range recList &#123; pdf.SetXY(20, 20) pdf.CellFormat(170, 257, rec.txt, borderStr, 0, rec.align, false, 0, linkStr) borderStr = \"\" &#125; linkStr = \"https://github.com/jung-kurt/gofpdf\" &#125; &#125; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") // A4 210.0 x 297.0 pdf.SetFont(\"Helvetica\", \"\", 16) formatRect(pdf, recList) formatRect(pdf, recListBaseline) var fr fontResourceType pdf.SetFontLoader(fr) pdf.AddFont(\"Calligrapher\", \"\", \"calligra.json\") pdf.SetFont(\"Calligrapher\", \"\", 16) formatRect(pdf, recListBaseline) fileStr := example.Filename(\"Fpdf_CellFormat_align\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Generalized font loader reading calligra.json // Generalized font loader reading calligra.z // Successfully generated pdf/Fpdf_CellFormat_align.pdf &#125; 演示将UTF-8字符串自动转换为8位字体编码// ExampleFpdf_CellFormat_codepage demonstrates the automatic conversion of UTF-8 strings to an // 8-bit font encoding. func ExampleFpdf_CellFormat_codepage() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", example.FontDir()) // A4 210.0 x 297.0 // See documentation for details on how to generate fonts pdf.AddFont(\"Helvetica-1251\", \"\", \"helvetica_1251.json\") pdf.AddFont(\"Helvetica-1253\", \"\", \"helvetica_1253.json\") fontSize := 16.0 pdf.SetFont(\"Helvetica\", \"\", fontSize) ht := pdf.PointConvert(fontSize) tr := pdf.UnicodeTranslatorFromDescriptor(\"\") // \"\" defaults to \"cp1252\" write := func(str string) &#123; // pdf.CellFormat(190, ht, tr(str), \"\", 1, \"C\", false, 0, \"\") pdf.MultiCell(190, ht, tr(str), \"\", \"C\", false) pdf.Ln(ht) &#125; pdf.AddPage() str := `Gofpdf provides a translator that will convert any UTF-8 code point ` + `that is present in the specified code page.` pdf.MultiCell(190, ht, str, \"\", \"L\", false) pdf.Ln(2 * ht) write(\"Voix ambiguë d'un cœur qui au zéphyr préfère les jattes de kiwi.\") write(\"Falsches Üben von Xylophonmusik quält jeden größeren Zwerg.\") write(\"Heizölrückstoßabdämpfung\") write(\"Forårsjævndøgn / Efterårsjævndøgn\") write(\"À noite, vovô Kowalsky vê o ímã cair no pé do pingüim queixoso e vovó\" + \"põe açúcar no chá de tâmaras do jabuti feliz.\") pdf.SetFont(\"Helvetica-1251\", \"\", fontSize) // Name matches one specified in AddFont() tr = pdf.UnicodeTranslatorFromDescriptor(\"cp1251\") write(\"Съешь же ещё этих мягких французских булок, да выпей чаю.\") pdf.SetFont(\"Helvetica-1253\", \"\", fontSize) tr = pdf.UnicodeTranslatorFromDescriptor(\"cp1253\") write(\"Θέλει αρετή και τόλμη η ελευθερία. (Ανδρέας Κάλβος)\") fileStr := example.Filename(\"Fpdf_CellFormat_codepage\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_CellFormat_codepage.pdf &#125; 演示文档的密码保护// ExampleFpdf_SetProtection demonstrates password protection for documents. func ExampleFpdf_SetProtection() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.SetProtection(gofpdf.CnProtectPrint, \"123\", \"abc\") pdf.AddPage() pdf.SetFont(\"Arial\", \"\", 12) pdf.Write(10, \"Password-protected.\") fileStr := example.Filename(\"Fpdf_SetProtection\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_SetProtection.pdf &#125; 在多边形函数的演示中显示等边多边形// ExampleFpdf_Polygon displays equilateral polygons in a demonstration of the Polygon // function. func ExampleFpdf_Polygon() &#123; const rowCount = 5 const colCount = 4 const ptSize = 36 var x, y, radius, gap, advance float64 var rgVal int var pts []gofpdf.PointType vertices := func(count int) (res []gofpdf.PointType) &#123; var pt gofpdf.PointType res = make([]gofpdf.PointType, 0, count) mlt := 2.0 * math.Pi / float64(count) for j := 0; j &lt; count; j++ &#123; pt.Y, pt.X = math.Sincos(float64(j) * mlt) res = append(res, gofpdf.PointType&#123; X: x + radius*pt.X, Y: y + radius*pt.Y&#125;) &#125; return &#125; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") // A4 210.0 x 297.0 pdf.AddPage() pdf.SetFont(\"Helvetica\", \"\", ptSize) pdf.SetDrawColor(0, 80, 180) gap = 12.0 pdf.SetY(gap) pdf.CellFormat(190.0, gap, \"Equilateral polygons\", \"\", 1, \"C\", false, 0, \"\") radius = (210.0 - float64(colCount+1)*gap) / (2.0 * float64(colCount)) advance = gap + 2.0*radius y = 2*gap + pdf.PointConvert(ptSize) + radius rgVal = 230 for row := 0; row &lt; rowCount; row++ &#123; pdf.SetFillColor(rgVal, rgVal, 0) rgVal -= 12 x = gap + radius for col := 0; col &lt; colCount; col++ &#123; pts = vertices(row*colCount + col + 3) pdf.Polygon(pts, \"FD\") x += advance &#125; y += advance &#125; fileStr := example.Filename(\"Fpdf_Polygon\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_Polygon.pdf &#125; 演示文档图层图层的初始可见性是用第二个参数AddLayer()指定的。文档阅读器显示的层列表允许交互式地控制层的可见性。 // ExampleFpdf_AddLayer demonstrates document layers. The initial visibility of a layer // is specified with the second parameter to AddLayer(). The layer list // displayed by the document reader allows layer visibility to be controlled // interactively. func ExampleFpdf_AddLayer() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.AddPage() pdf.SetFont(\"Arial\", \"\", 15) pdf.Write(8, \"This line doesn't belong to any layer.\\n\") // Define layers l1 := pdf.AddLayer(\"Layer 1\", true) l2 := pdf.AddLayer(\"Layer 2\", true) // Open layer pane in PDF viewer pdf.OpenLayerPane() // First layer pdf.BeginLayer(l1) pdf.Write(8, \"This line belongs to layer 1.\\n\") pdf.EndLayer() // Second layer pdf.BeginLayer(l2) pdf.Write(8, \"This line belongs to layer 2.\\n\") pdf.EndLayer() // First layer again pdf.BeginLayer(l1) pdf.Write(8, \"This line belongs to layer 1 again.\\n\") pdf.EndLayer() fileStr := example.Filename(\"Fpdf_AddLayer\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_AddLayer.pdf &#125; 演示如何使用从web服务器检索到的图像// ExampleFpdf_RegisterImageReader demonstrates the use of an image that is retrieved from a web // server. func ExampleFpdf_RegisterImageReader() &#123; const ( margin = 10 wd = 210 ht = 297 fontSize = 15 urlStr = \"https://github.com/jung-kurt/gofpdf/blob/master/image/gofpdf.png?raw=true\" msgStr = `Images from the web can be easily embedded when a PDF document is generated.` ) var ( rsp *http.Response err error tp string ) pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.AddPage() pdf.SetFont(\"Helvetica\", \"\", fontSize) ln := pdf.PointConvert(fontSize) pdf.MultiCell(wd-margin-margin, ln, msgStr, \"\", \"L\", false) rsp, err = http.Get(urlStr) if err == nil &#123; tp = pdf.ImageTypeFromMime(rsp.Header[\"Content-Type\"][0]) infoPtr := pdf.RegisterImageReader(urlStr, tp, rsp.Body) if pdf.Ok() &#123; imgWd, imgHt := infoPtr.Extent() pdf.Image(urlStr, (wd-imgWd)/2.0, pdf.GetY()+ln, imgWd, imgHt, false, tp, 0, \"\") &#125; &#125; else &#123; pdf.SetError(err) &#125; fileStr := example.Filename(\"Fpdf_RegisterImageReader_url\") err = pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_RegisterImageReader_url.pdf &#125; 演示Beziergon函数// ExampleFpdf_Beziergon demonstrates the Beziergon function. func ExampleFpdf_Beziergon() &#123; const ( margin = 10 wd = 210 unit = (wd - 2*margin) / 6 ht = 297 fontSize = 15 msgStr = `Demonstration of Beziergon function` coefficient = 0.6 delta = coefficient * unit ln = fontSize * 25.4 / 72 offsetX = (wd - 4*unit) / 2.0 offsetY = offsetX + 2*ln ) srcList := []gofpdf.PointType&#123; &#123;X: 0, Y: 0&#125;, &#123;X: 1, Y: 0&#125;, &#123;X: 1, Y: 1&#125;, &#123;X: 2, Y: 1&#125;, &#123;X: 2, Y: 2&#125;, &#123;X: 3, Y: 2&#125;, &#123;X: 3, Y: 3&#125;, &#123;X: 4, Y: 3&#125;, &#123;X: 4, Y: 4&#125;, &#123;X: 1, Y: 4&#125;, &#123;X: 1, Y: 3&#125;, &#123;X: 0, Y: 3&#125;, &#125; ctrlList := []gofpdf.PointType&#123; &#123;X: 1, Y: -1&#125;, &#123;X: 1, Y: 1&#125;, &#123;X: 1, Y: 1&#125;, &#123;X: 1, Y: 1&#125;, &#123;X: 1, Y: 1&#125;, &#123;X: 1, Y: 1&#125;, &#123;X: 1, Y: 1&#125;, &#123;X: 1, Y: 1&#125;, &#123;X: -1, Y: 1&#125;, &#123;X: -1, Y: -1&#125;, &#123;X: -1, Y: -1&#125;, &#123;X: -1, Y: -1&#125;, &#125; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.AddPage() pdf.SetFont(\"Helvetica\", \"\", fontSize) for j, src := range srcList &#123; srcList[j].X = offsetX + src.X*unit srcList[j].Y = offsetY + src.Y*unit &#125; for j, ctrl := range ctrlList &#123; ctrlList[j].X = ctrl.X * delta ctrlList[j].Y = ctrl.Y * delta &#125; jPrev := len(srcList) - 1 srcPrev := srcList[jPrev] curveList := []gofpdf.PointType&#123;srcPrev&#125; // point [, control 0, control 1, point]* control := func(x, y float64) &#123; curveList = append(curveList, gofpdf.PointType&#123;X: x, Y: y&#125;) &#125; for j, src := range srcList &#123; ctrl := ctrlList[jPrev] control(srcPrev.X+ctrl.X, srcPrev.Y+ctrl.Y) // Control 0 ctrl = ctrlList[j] control(src.X-ctrl.X, src.Y-ctrl.Y) // Control 1 curveList = append(curveList, src) // Destination jPrev = j srcPrev = src &#125; pdf.MultiCell(wd-margin-margin, ln, msgStr, \"\", \"C\", false) pdf.SetDashPattern([]float64&#123;0.8, 0.8&#125;, 0) pdf.SetDrawColor(160, 160, 160) pdf.Polygon(srcList, \"D\") pdf.SetDashPattern([]float64&#123;&#125;, 0) pdf.SetDrawColor(64, 64, 128) pdf.SetLineWidth(pdf.GetLineWidth() * 3) pdf.Beziergon(curveList, \"D\") fileStr := example.Filename(\"Fpdf_Beziergon\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_Beziergon.pdf &#125; 演示使用通用字体加载器加载非标准字体fontResourceType实现了FontLoader接口，并在测试源代码中进行了本地定义。 // ExampleFpdf_SetFontLoader demonstrates loading a non-standard font using a generalized // font loader. fontResourceType implements the FontLoader interface and is // defined locally in the test source code. func ExampleFpdf_SetFontLoader() &#123; var fr fontResourceType pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.SetFontLoader(fr) pdf.AddFont(\"Calligrapher\", \"\", \"calligra.json\") pdf.AddPage() pdf.SetFont(\"Calligrapher\", \"\", 35) pdf.Cell(0, 10, \"Load fonts from any source\") fileStr := example.Filename(\"Fpdf_SetFontLoader\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Generalized font loader reading calligra.json // Generalized font loader reading calligra.z // Successfully generated pdf/Fpdf_SetFontLoader.pdf &#125; 演示路径绘制功能如:移动，直线，曲线，…、ClosePath和DrawPath。 // ExampleFpdf_MoveTo demonstrates the Path Drawing functions, such as: MoveTo, // LineTo, CurveTo, ..., ClosePath and DrawPath. func ExampleFpdf_MoveTo() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.AddPage() pdf.MoveTo(20, 20) pdf.LineTo(170, 20) pdf.ArcTo(170, 40, 20, 20, 0, 90, 0) pdf.CurveTo(190, 100, 105, 100) pdf.CurveBezierCubicTo(20, 100, 105, 200, 20, 200) pdf.ClosePath() pdf.SetFillColor(200, 200, 200) pdf.SetLineWidth(3) pdf.DrawPath(\"DF\") fileStr := example.Filename(\"Fpdf_MoveTo_path\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_MoveTo_path.pdf &#125; 演示各种线帽和线连接样式// ExampleFpdf_SetLineJoinStyle demonstrates various line cap and line join styles. func ExampleFpdf_SetLineJoinStyle() &#123; const offset = 75.0 pdf := gofpdf.New(\"L\", \"mm\", \"A4\", \"\") pdf.AddPage() var draw = func(cap, join string, x0, y0, x1, y1 float64) &#123; // transform begin &amp; end needed to isolate caps and joins pdf.SetLineCapStyle(cap) pdf.SetLineJoinStyle(join) // Draw thick line pdf.SetDrawColor(0x33, 0x33, 0x33) pdf.SetLineWidth(30.0) pdf.MoveTo(x0, y0) pdf.LineTo((x0+x1)/2+offset, (y0+y1)/2) pdf.LineTo(x1, y1) pdf.DrawPath(\"D\") // Draw thin helping line pdf.SetDrawColor(0xFF, 0x33, 0x33) pdf.SetLineWidth(2.56) pdf.MoveTo(x0, y0) pdf.LineTo((x0+x1)/2+offset, (y0+y1)/2) pdf.LineTo(x1, y1) pdf.DrawPath(\"D\") &#125; x := 35.0 caps := []string&#123;\"butt\", \"square\", \"round\"&#125; joins := []string&#123;\"bevel\", \"miter\", \"round\"&#125; for i := range caps &#123; draw(caps[i], joins[i], x, 50, x, 160) x += offset &#125; fileStr := example.Filename(\"Fpdf_SetLineJoinStyle_caps\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_SetLineJoinStyle_caps.pdf &#125; 演示各种填充模式// ExampleFpdf_DrawPath demonstrates various fill modes. func ExampleFpdf_DrawPath() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.SetDrawColor(0xff, 0x00, 0x00) pdf.SetFillColor(0x99, 0x99, 0x99) pdf.SetFont(\"Helvetica\", \"\", 15) pdf.AddPage() pdf.SetAlpha(1, \"Multiply\") var ( polygon = func(cx, cy, r, n, dir float64) &#123; da := 2 * math.Pi / n pdf.MoveTo(cx+r, cy) pdf.Text(cx+r, cy, \"0\") i := 1 for a := da; a &lt; 2*math.Pi; a += da &#123; x, y := cx+r*math.Cos(dir*a), cy+r*math.Sin(dir*a) pdf.LineTo(x, y) pdf.Text(x, y, strconv.Itoa(i)) i++ &#125; pdf.ClosePath() &#125; polygons = func(cx, cy, r, n, dir float64) &#123; d := 1.0 for rf := r; rf > 0; rf -= 10 &#123; polygon(cx, cy, rf, n, d) d *= dir &#125; &#125; star = func(cx, cy, r, n float64) &#123; da := 4 * math.Pi / n pdf.MoveTo(cx+r, cy) for a := da; a &lt; 4*math.Pi+da; a += da &#123; x, y := cx+r*math.Cos(a), cy+r*math.Sin(a) pdf.LineTo(x, y) &#125; pdf.ClosePath() &#125; ) // triangle polygons(55, 45, 40, 3, 1) pdf.DrawPath(\"B\") pdf.Text(15, 95, \"B (same direction, non zero winding)\") // square polygons(155, 45, 40, 4, 1) pdf.DrawPath(\"B*\") pdf.Text(115, 95, \"B* (same direction, even odd)\") // pentagon polygons(55, 145, 40, 5, -1) pdf.DrawPath(\"B\") pdf.Text(15, 195, \"B (different direction, non zero winding)\") // hexagon polygons(155, 145, 40, 6, -1) pdf.DrawPath(\"B*\") pdf.Text(115, 195, \"B* (different direction, even odd)\") // star star(55, 245, 40, 5) pdf.DrawPath(\"B\") pdf.Text(15, 290, \"B (non zero winding)\") // star star(155, 245, 40, 5) pdf.DrawPath(\"B*\") pdf.Text(115, 290, \"B* (even odd)\") fileStr := example.Filename(\"Fpdf_DrawPath_fill\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_DrawPath_fill.pdf &#125; 演示创建和使用模板// ExampleFpdf_CreateTemplate demonstrates creating and using templates func ExampleFpdf_CreateTemplate() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.SetCompression(false) // pdf.SetFont(\"Times\", \"\", 12) template := pdf.CreateTemplate(func(tpl *gofpdf.Tpl) &#123; tpl.Image(example.ImageFile(\"logo.png\"), 6, 6, 30, 0, false, \"\", 0, \"\") tpl.SetFont(\"Arial\", \"B\", 16) tpl.Text(40, 20, \"Template says hello\") tpl.SetDrawColor(0, 100, 200) tpl.SetLineWidth(2.5) tpl.Line(95, 12, 105, 22) &#125;) _, tplSize := template.Size() // fmt.Println(\"Size:\", tplSize) // fmt.Println(\"Scaled:\", tplSize.ScaleBy(1.5)) template2 := pdf.CreateTemplate(func(tpl *gofpdf.Tpl) &#123; tpl.UseTemplate(template) subtemplate := tpl.CreateTemplate(func(tpl2 *gofpdf.Tpl) &#123; tpl2.Image(example.ImageFile(\"logo.png\"), 6, 86, 30, 0, false, \"\", 0, \"\") tpl2.SetFont(\"Arial\", \"B\", 16) tpl2.Text(40, 100, \"Subtemplate says hello\") tpl2.SetDrawColor(0, 200, 100) tpl2.SetLineWidth(2.5) tpl2.Line(102, 92, 112, 102) &#125;) tpl.UseTemplate(subtemplate) &#125;) pdf.SetDrawColor(200, 100, 0) pdf.SetLineWidth(2.5) pdf.SetFont(\"Arial\", \"B\", 16) // serialize and deserialize template b, _ := template2.Serialize() template3, _ := gofpdf.DeserializeTemplate(b) pdf.AddPage() pdf.UseTemplate(template3) pdf.UseTemplateScaled(template3, gofpdf.PointType&#123;X: 0, Y: 30&#125;, tplSize) pdf.Line(40, 210, 60, 210) pdf.Text(40, 200, \"Template example page 1\") pdf.AddPage() pdf.UseTemplate(template2) pdf.UseTemplateScaled(template3, gofpdf.PointType&#123;X: 0, Y: 30&#125;, tplSize.ScaleBy(1.4)) pdf.Line(60, 210, 80, 210) pdf.Text(40, 200, \"Template example page 2\") fileStr := example.Filename(\"Fpdf_CreateTemplate\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_CreateTemplate.pdf &#125; 演示如何使用字节数组中的嵌入字体// ExampleFpdf_AddFontFromBytes demonstrate how to use embedded fonts from byte array func ExampleFpdf_AddFontFromBytes() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.AddPage() pdf.AddFontFromBytes(\"calligra\", \"\", files.CalligraJson, files.CalligraZ) pdf.SetFont(\"calligra\", \"\", 16) pdf.Cell(40, 10, \"Hello World With Embedded Font!\") fileStr := example.Filename(\"Fpdf_EmbeddedFont\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_EmbeddedFont.pdf &#125; 演示了剪切的表格单元格// This example demonstrate Clipped table cells func ExampleFpdf_ClipRect() &#123; marginCell := 2. // margin of top/bottom of cell pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.SetFont(\"Arial\", \"\", 12) pdf.AddPage() pagew, pageh := pdf.GetPageSize() mleft, mright, _, mbottom := pdf.GetMargins() cols := []float64&#123;60, 100, pagew - mleft - mright - 100 - 60&#125; rows := [][]string&#123;&#125; for i := 1; i &lt;= 50; i++ &#123; word := fmt.Sprintf(\"%d:%s\", i, strings.Repeat(\"A\", i%100)) rows = append(rows, []string&#123;word, word, word&#125;) &#125; for _, row := range rows &#123; _, lineHt := pdf.GetFontSize() height := lineHt + marginCell x, y := pdf.GetXY() // add a new page if the height of the row doesn't fit on the page if y+height >= pageh-mbottom &#123; pdf.AddPage() x, y = pdf.GetXY() &#125; for i, txt := range row &#123; width := cols[i] pdf.Rect(x, y, width, height, \"\") pdf.ClipRect(x, y, width, height, false) pdf.Cell(width, height, txt) pdf.ClipEnd() x += width &#125; pdf.Ln(-1) &#125; fileStr := example.Filename(\"Fpdf_ClippedTableCells\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_ClippedTableCells.pdf &#125; 演示包装表格单元格// This example demonstrate wrapped table cells func ExampleFpdf_Rect() &#123; marginCell := 2. // margin of top/bottom of cell pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.SetFont(\"Arial\", \"\", 12) pdf.AddPage() pagew, pageh := pdf.GetPageSize() mleft, mright, _, mbottom := pdf.GetMargins() cols := []float64&#123;60, 100, pagew - mleft - mright - 100 - 60&#125; rows := [][]string&#123;&#125; for i := 1; i &lt;= 30; i++ &#123; word := fmt.Sprintf(\"%d:%s\", i, strings.Repeat(\"A\", i%100)) rows = append(rows, []string&#123;word, word, word&#125;) &#125; for _, row := range rows &#123; curx, y := pdf.GetXY() x := curx height := 0. _, lineHt := pdf.GetFontSize() for i, txt := range row &#123; lines := pdf.SplitLines([]byte(txt), cols[i]) h := float64(len(lines))*lineHt + marginCell*float64(len(lines)) if h > height &#123; height = h &#125; &#125; // add a new page if the height of the row doesn't fit on the page if pdf.GetY()+height > pageh-mbottom &#123; pdf.AddPage() y = pdf.GetY() &#125; for i, txt := range row &#123; width := cols[i] pdf.Rect(x, y, width, height, \"\") pdf.MultiCell(width, lineHt+marginCell, txt, \"\", \"\", false) x += width pdf.SetXY(x, y) &#125; pdf.SetXY(curx, y+height) &#125; fileStr := example.Filename(\"Fpdf_WrappedTableCells\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_WrappedTableCells.pdf &#125; 演示在文档中包含JavaScript// ExampleFpdf_SetJavascript demonstrates including JavaScript in the document. func ExampleFpdf_SetJavascript() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.SetJavascript(\"print(true);\") pdf.AddPage() pdf.SetFont(\"Arial\", \"\", 12) pdf.Write(10, \"Auto-print.\") fileStr := example.Filename(\"Fpdf_SetJavascript\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_SetJavascript.pdf &#125; 演示专色的使用// ExampleFpdf_AddSpotColor demonstrates spot color use func ExampleFpdf_AddSpotColor() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.AddSpotColor(\"PANTONE 145 CVC\", 0, 42, 100, 25) pdf.AddPage() pdf.SetFillSpotColor(\"PANTONE 145 CVC\", 90) pdf.Rect(80, 40, 50, 50, \"F\") fileStr := example.Filename(\"Fpdf_AddSpotColor\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_AddSpotColor.pdf &#125; 演示如何使用’ RegisterAlias ‘创建目录表// ExampleFpdf_RegisterAlias demonstrates how to use `RegisterAlias` to create a table of // contents. func ExampleFpdf_RegisterAlias() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.SetFont(\"Arial\", \"\", 12) pdf.AliasNbPages(\"\") pdf.AddPage() // Write the table of contents. We use aliases instead of the page number // because we don't know which page the section will begin on. numSections := 3 for i := 1; i &lt;= numSections; i++ &#123; pdf.Cell(0, 10, fmt.Sprintf(\"Section %d begins on page &#123;mark %d&#125;\", i, i)) pdf.Ln(10) &#125; // Write the sections. Before we start writing, we use `RegisterAlias` to // ensure that the alias written in the table of contents will be replaced // by the current page number. for i := 1; i &lt;= numSections; i++ &#123; pdf.AddPage() pdf.RegisterAlias(fmt.Sprintf(\"&#123;mark %d&#125;\", i), fmt.Sprintf(\"%d\", pdf.PageNo())) pdf.Write(10, fmt.Sprintf(\"Section %d, page %d of &#123;nb&#125;\", i, pdf.PageNo())) &#125; fileStr := example.Filename(\"Fpdf_RegisterAlias\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_RegisterAlias.pdf &#125; 演示如何使用’ RegisterAlias ‘创建目录表这个特殊的示例演示了UTF-8别名的使用。 // ExampleFpdf_RegisterAlias_utf8 demonstrates how to use `RegisterAlias` to // create a table of contents. This particular example demonstrates the use of // UTF-8 aliases. func ExampleFpdf_RegisterAlias_utf8() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.AddUTF8Font(\"dejavu\", \"\", example.FontFile(\"DejaVuSansCondensed.ttf\")) pdf.SetFont(\"dejavu\", \"\", 12) pdf.AliasNbPages(\"&#123;entute&#125;\") pdf.AddPage() // Write the table of contents. We use aliases instead of the page number // because we don't know which page the section will begin on. numSections := 3 for i := 1; i &lt;= numSections; i++ &#123; pdf.Cell(0, 10, fmt.Sprintf(\"Sekcio %d komenciĝas ĉe paĝo &#123;ĉi tiu marko %d&#125;\", i, i)) pdf.Ln(10) &#125; // Write the sections. Before we start writing, we use `RegisterAlias` to // ensure that the alias written in the table of contents will be replaced // by the current page number. for i := 1; i &lt;= numSections; i++ &#123; pdf.AddPage() pdf.RegisterAlias(fmt.Sprintf(\"&#123;ĉi tiu marko %d&#125;\", i), fmt.Sprintf(\"%d\", pdf.PageNo())) pdf.Write(10, fmt.Sprintf(\"Sekcio %d, paĝo %d de &#123;entute&#125;\", i, pdf.PageNo())) &#125; fileStr := example.Filename(\"Fpdf_RegisterAliasUTF8\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_RegisterAliasUTF8.pdf &#125; 演示图形网格的生成// ExampleNewGrid demonstrates the generation of graph grids. func ExampleNewGrid() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.SetFont(\"Arial\", \"\", 12) pdf.AddPage() gr := gofpdf.NewGrid(13, 10, 187, 130) gr.TickmarksExtentX(0, 10, 4) gr.TickmarksExtentY(0, 10, 3) gr.Grid(pdf) gr = gofpdf.NewGrid(13, 154, 187, 128) gr.XLabelRotate = true gr.TickmarksExtentX(0, 1, 12) gr.XDiv = 5 gr.TickmarksContainY(0, 1.1) gr.YDiv = 20 // Replace X label formatter with month abbreviation gr.XTickStr = func(val float64, precision int) string &#123; return time.Month(math.Mod(val, 12) + 1).String()[0:3] &#125; gr.Grid(pdf) dot := func(x, y float64) &#123; pdf.Circle(gr.X(x), gr.Y(y), 0.5, \"F\") &#125; pts := []float64&#123;0.39, 0.457, 0.612, 0.84, 0.998, 1.037, 1.015, 0.918, 0.772, 0.659, 0.593, 0.164&#125; for month, val := range pts &#123; dot(float64(month)+0.5, val) &#125; pdf.SetDrawColor(255, 64, 64) pdf.SetAlpha(0.5, \"Normal\") pdf.SetLineWidth(1.2) gr.Plot(pdf, 0.5, 11.5, 50, func(x float64) float64 &#123; // http://www.xuru.org/rt/PR.asp return 0.227 * math.Exp(-0.0373*x*x+0.471*x) &#125;) pdf.SetAlpha(1.0, \"Normal\") pdf.SetXY(gr.X(0.5), gr.Y(1.35)) pdf.SetFontSize(14) pdf.Write(0, \"Solar energy (MWh) per month, 2016\") pdf.AddPage() gr = gofpdf.NewGrid(13, 10, 187, 274) gr.TickmarksContainX(2.3, 3.4) gr.TickmarksContainY(10.4, 56.8) gr.Grid(pdf) fileStr := example.Filename(\"Fpdf_Grid\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_Grid.pdf &#125; 演示页面框的使用// ExampleFpdf_SetPageBox demonstrates the use of a page box func ExampleFpdf_SetPageBox() &#123; // pdfinfo (from http://www.xpdfreader.com) reports the following for this example: // ~ pdfinfo -box pdf/Fpdf_PageBox.pdf // Producer: FPDF 1.7 // CreationDate: Sat Jan 1 00:00:00 2000 // ModDate: Sat Jan 1 00:00:00 2000 // Tagged: no // Form: none // Pages: 1 // Encrypted: no // Page size: 493.23 x 739.85 pts (rotated 0 degrees) // MediaBox: 0.00 0.00 595.28 841.89 // CropBox: 51.02 51.02 544.25 790.87 // BleedBox: 51.02 51.02 544.25 790.87 // TrimBox: 51.02 51.02 544.25 790.87 // ArtBox: 51.02 51.02 544.25 790.87 // File size: 1053 bytes // Optimized: no // PDF version: 1.3 const ( wd = 210 ht = 297 fontsize = 6 boxmargin = 3 * fontsize ) pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") // 210mm x 297mm pdf.SetPageBox(\"crop\", boxmargin, boxmargin, wd-2*boxmargin, ht-2*boxmargin) pdf.SetFont(\"Arial\", \"\", pdf.UnitToPointConvert(fontsize)) pdf.AddPage() pdf.MoveTo(fontsize, fontsize) pdf.Write(fontsize, \"This will be cropped from printed output\") pdf.MoveTo(boxmargin+fontsize, boxmargin+fontsize) pdf.Write(fontsize, \"This will be displayed in cropped output\") fileStr := example.Filename(\"Fpdf_PageBox\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_PageBox.pdf &#125; 演示下标和上标文本改编自http://www.fpdf.org/en/script/script61.php // ExampleFpdf_SubWrite demonstrates subscripted and superscripted text // Adapted from http://www.fpdf.org/en/script/script61.php func ExampleFpdf_SubWrite() &#123; const ( fontSize = 12 halfX = 105 ) pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") // 210mm x 297mm pdf.AddPage() pdf.SetFont(\"Arial\", \"\", fontSize) _, lineHt := pdf.GetFontSize() pdf.Write(lineHt, \"Hello World!\") pdf.SetX(halfX) pdf.Write(lineHt, \"This is standard text.\\n\") pdf.Ln(lineHt * 2) pdf.SubWrite(10, \"H\", 33, 0, 0, \"\") pdf.Write(10, \"ello World!\") pdf.SetX(halfX) pdf.Write(10, \"This is text with a capital first letter.\\n\") pdf.Ln(lineHt * 2) pdf.SubWrite(lineHt, \"Y\", 6, 0, 0, \"\") pdf.Write(lineHt, \"ou can also begin the sentence with a small letter. And word wrap also works if the line is too long, like this one is.\") pdf.SetX(halfX) pdf.Write(lineHt, \"This is text with a small first letter.\\n\") pdf.Ln(lineHt * 2) pdf.Write(lineHt, \"The world has a lot of km\") pdf.SubWrite(lineHt, \"2\", 6, 4, 0, \"\") pdf.SetX(halfX) pdf.Write(lineHt, \"This is text with a superscripted letter.\\n\") pdf.Ln(lineHt * 2) pdf.Write(lineHt, \"The world has a lot of H\") pdf.SubWrite(lineHt, \"2\", 6, -3, 0, \"\") pdf.Write(lineHt, \"O\") pdf.SetX(halfX) pdf.Write(lineHt, \"This is text with a subscripted letter.\\n\") fileStr := example.Filename(\"Fpdf_SubWrite\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_SubWrite.pdf &#125; 演示了SetPage()方法该方法允许将内容生成延迟到添加了所有页面之后 // ExampleFpdf_SetPage demomstrates the SetPage() method, allowing content // generation to be deferred until all pages have been added. func ExampleFpdf_SetPage() &#123; rnd := rand.New(rand.NewSource(0)) // Make reproducible documents pdf := gofpdf.New(\"L\", \"cm\", \"A4\", \"\") pdf.SetFont(\"Times\", \"\", 12) var time []float64 temperaturesFromSensors := make([][]float64, 5) maxs := []float64&#123;25, 41, 89, 62, 11&#125; for i := range temperaturesFromSensors &#123; temperaturesFromSensors[i] = make([]float64, 0) &#125; for i := 0.0; i &lt; 100; i += 0.5 &#123; time = append(time, i) for j, sensor := range temperaturesFromSensors &#123; dataValue := rnd.Float64() * maxs[j] sensor = append(sensor, dataValue) temperaturesFromSensors[j] = sensor &#125; &#125; var graphs []gofpdf.GridType var pageNums []int xMax := time[len(time)-1] for i := range temperaturesFromSensors &#123; //Create a new page and graph for each sensor we want to graph. pdf.AddPage() pdf.Ln(1) //Custom label per sensor pdf.WriteAligned(0, 0, \"Temperature Sensor \"+strconv.Itoa(i+1)+\" (C) vs Time (min)\", \"C\") pdf.Ln(0.5) graph := gofpdf.NewGrid(pdf.GetX(), pdf.GetY(), 20, 10) graph.TickmarksContainX(0, xMax) //Custom Y axis graph.TickmarksContainY(0, maxs[i]) graph.Grid(pdf) //Save references and locations. graphs = append(graphs, graph) pageNums = append(pageNums, pdf.PageNo()) &#125; // For each X, graph the Y in each sensor. for i, currTime := range time &#123; for j, sensor := range temperaturesFromSensors &#123; pdf.SetPage(pageNums[j]) graph := graphs[j] temperature := sensor[i] pdf.Circle(graph.X(currTime), graph.Y(temperature), 0.04, \"D\") &#125; &#125; fileStr := example.Filename(\"Fpdf_SetPage\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_SetPage.pdf &#125; 演示如何在多个转换中正确分配图形属性// ExampleFpdf_SetFillColor demonstrates how graphic attributes are properly // assigned within multiple transformations. See issue #234. func ExampleFpdf_SetFillColor() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.AddPage() pdf.SetFont(\"Arial\", \"\", 8) draw := func(trX, trY float64) &#123; pdf.TransformBegin() pdf.TransformTranslateX(trX) pdf.TransformTranslateY(trY) pdf.SetLineJoinStyle(\"round\") pdf.SetLineWidth(0.5) pdf.SetDrawColor(128, 64, 0) pdf.SetFillColor(255, 127, 0) pdf.SetAlpha(0.5, \"Normal\") pdf.SetDashPattern([]float64&#123;5, 10&#125;, 0) pdf.Rect(0, 0, 40, 40, \"FD\") pdf.SetFontSize(12) pdf.SetXY(5, 5) pdf.Write(0, \"Test\") pdf.TransformEnd() &#125; draw(5, 5) draw(50, 50) fileStr := example.Filename(\"Fpdf_SetFillColor\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_SetFillColor.pdf &#125; 演示如何旋转标题内的文本以使水印显示在每个页面上// ExampleFpdf_TransformRotate demonstrates how to rotate text within a header // to make a watermark that appears on each page. func ExampleFpdf_TransformRotate() &#123; loremStr := lorem() + \"\\n\\n\" pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") margin := 25.0 pdf.SetMargins(margin, margin, margin) fontHt := 13.0 lineHt := pdf.PointToUnitConvert(fontHt) markFontHt := 50.0 markLineHt := pdf.PointToUnitConvert(markFontHt) markY := (297.0 - markLineHt) / 2.0 ctrX := 210.0 / 2.0 ctrY := 297.0 / 2.0 pdf.SetHeaderFunc(func() &#123; pdf.SetFont(\"Arial\", \"B\", markFontHt) pdf.SetTextColor(206, 216, 232) pdf.SetXY(margin, markY) pdf.TransformBegin() pdf.TransformRotate(45, ctrX, ctrY) pdf.CellFormat(0, markLineHt, \"W A T E R M A R K D E M O\", \"\", 0, \"C\", false, 0, \"\") pdf.TransformEnd() pdf.SetXY(margin, margin) &#125;) pdf.AddPage() pdf.SetFont(\"Arial\", \"\", 8) for j := 0; j &lt; 25; j++ &#123; pdf.MultiCell(0, lineHt, loremStr, \"\", \"L\", false) &#125; fileStr := example.Filename(\"Fpdf_RotateText\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_RotateText.pdf &#125; 演示如何使用utf-8模式的字体// ExampleFpdf_AddUTF8Font demonstrates how use the font // with utf-8 mode func ExampleFpdf_AddUTF8Font() &#123; var fileStr string var txtStr []byte var err error pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.AddPage() pdf.AddUTF8Font(\"dejavu\", \"\", example.FontFile(\"DejaVuSansCondensed.ttf\")) pdf.AddUTF8Font(\"dejavu\", \"B\", example.FontFile(\"DejaVuSansCondensed-Bold.ttf\")) pdf.AddUTF8Font(\"dejavu\", \"I\", example.FontFile(\"DejaVuSansCondensed-Oblique.ttf\")) pdf.AddUTF8Font(\"dejavu\", \"BI\", example.FontFile(\"DejaVuSansCondensed-BoldOblique.ttf\")) fileStr = example.Filename(\"Fpdf_AddUTF8Font\") txtStr, err = ioutil.ReadFile(example.TextFile(\"utf-8test.txt\")) if err == nil &#123; pdf.SetFont(\"dejavu\", \"B\", 17) pdf.MultiCell(100, 8, \"Text in different languages :\", \"\", \"C\", false) pdf.SetFont(\"dejavu\", \"\", 14) pdf.MultiCell(100, 5, string(txtStr), \"\", \"C\", false) pdf.Ln(15) txtStr, err = ioutil.ReadFile(example.TextFile(\"utf-8test2.txt\")) if err == nil &#123; pdf.SetFont(\"dejavu\", \"BI\", 17) pdf.MultiCell(100, 8, \"Greek text with alignStr = \\\"J\\\":\", \"\", \"C\", false) pdf.SetFont(\"dejavu\", \"I\", 14) pdf.MultiCell(100, 5, string(txtStr), \"\", \"J\", false) err = pdf.OutputFileAndClose(fileStr) &#125; &#125; example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_AddUTF8Font.pdf &#125; 演示如何生成TrueType字体子集// ExampleUTF8CutFont demonstrates how generate a TrueType font subset. func ExampleUTF8CutFont() &#123; var pdfFileStr, fullFontFileStr, subFontFileStr string var subFont, fullFont []byte var err error pdfFileStr = example.Filename(\"Fpdf_UTF8CutFont\") fullFontFileStr = example.FontFile(\"calligra.ttf\") fullFont, err = ioutil.ReadFile(fullFontFileStr) if err == nil &#123; subFontFileStr = \"calligra_abcde.ttf\" subFont = gofpdf.UTF8CutFont(fullFont, \"abcde\") err = ioutil.WriteFile(subFontFileStr, subFont, 0600) if err == nil &#123; y := 24.0 pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") fontHt := 17.0 lineHt := pdf.PointConvert(fontHt) write := func(format string, args ...interface&#123;&#125;) &#123; pdf.SetXY(24.0, y) pdf.Cell(200.0, lineHt, fmt.Sprintf(format, args...)) y += lineHt &#125; writeSize := func(fileStr string) &#123; var info os.FileInfo var err error info, err = os.Stat(fileStr) if err == nil &#123; write(\"%6d: size of %s\", info.Size(), fileStr) &#125; &#125; pdf.AddPage() pdf.AddUTF8Font(\"calligra\", \"\", subFontFileStr) pdf.SetFont(\"calligra\", \"\", fontHt) write(\"cabbed\") write(\"vwxyz\") pdf.SetFont(\"courier\", \"\", fontHt) writeSize(fullFontFileStr) writeSize(subFontFileStr) err = pdf.OutputFileAndClose(pdfFileStr) os.Remove(subFontFileStr) &#125; &#125; example.Summary(err, pdfFileStr) // Output: // Successfully generated pdf/Fpdf_UTF8CutFont.pdf &#125; 演示如何调整文本下划线的厚度// ExampleFpdf_SetUnderlineThickness demonstrates how to adjust the text // underline thickness. func ExampleFpdf_SetUnderlineThickness() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") // 210mm x 297mm pdf.AddPage() pdf.SetFont(\"Arial\", \"U\", 12) pdf.SetUnderlineThickness(0.5) pdf.CellFormat(0, 10, \"Thin underline\", \"\", 1, \"\", false, 0, \"\") pdf.SetUnderlineThickness(1) pdf.CellFormat(0, 10, \"Normal underline\", \"\", 1, \"\", false, 0, \"\") pdf.SetUnderlineThickness(2) pdf.CellFormat(0, 10, \"Thicker underline\", \"\", 1, \"\", false, 0, \"\") fileStr := example.Filename(\"Fpdf_UnderlineThickness\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_UnderlineThickness.pdf &#125; 演示删除的文本// ExampleFpdf_Cell_strikeout demonstrates striked-out text func ExampleFpdf_Cell_strikeout() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") // 210mm x 297mm pdf.AddPage() for fontSize := 4; fontSize &lt; 40; fontSize += 10 &#123; pdf.SetFont(\"Arial\", \"S\", float64(fontSize)) pdf.SetXY(0, float64(fontSize)) pdf.Cell(40, 10, \"Hello World\") &#125; fileStr := example.Filename(\"Fpdf_Cell_strikeout\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_Cell_strikeout.pdf &#125; 演示pdf中的呈现模式// ExampleFpdf_SetTextRenderingMode demonstrates rendering modes in PDFs. func ExampleFpdf_SetTextRenderingMode() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") // 210mm x 297mm pdf.AddPage() fontSz := float64(16) lineSz := pdf.PointToUnitConvert(fontSz) pdf.SetFont(\"Times\", \"\", fontSz) pdf.Write(lineSz, \"This document demonstrates various modes of text rendering. Search for \\\"Mode 3\\\" \"+ \"to locate text that has been rendered invisibly. This selection can be copied \"+ \"into the clipboard as usual and is useful for overlaying onto non-textual elements such \"+ \"as images to make them searchable.\\n\\n\") fontSz = float64(125) lineSz = pdf.PointToUnitConvert(fontSz) pdf.SetFontSize(fontSz) pdf.SetTextColor(170, 170, 190) pdf.SetDrawColor(50, 60, 90) write := func(mode int) &#123; pdf.SetTextRenderingMode(mode) pdf.CellFormat(210, lineSz, fmt.Sprintf(\"Mode %d\", mode), \"\", 1, \"\", false, 0, \"\") &#125; for mode := 0; mode &lt; 4; mode++ &#123; write(mode) &#125; write(0) fileStr := example.Filename(\"Fpdf_TextRenderingMode\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_TextRenderingMode.pdf &#125; 在顶层演示了在pdf中嵌入文件// ExampleFpdf_SetTextRenderingMode demonstrates embedding files in PDFs, // at the top-level. func ExampleFpdf_SetAttachments() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") // Global attachments file, err := ioutil.ReadFile(\"grid.go\") if err != nil &#123; pdf.SetError(err) &#125; a1 := gofpdf.Attachment&#123;Content: file, Filename: \"grid.go\"&#125; file, err = ioutil.ReadFile(\"LICENSE\") if err != nil &#123; pdf.SetError(err) &#125; a2 := gofpdf.Attachment&#123;Content: file, Filename: \"License\"&#125; pdf.SetAttachments([]gofpdf.Attachment&#123;a1, a2&#125;) fileStr := example.Filename(\"Fpdf_EmbeddedFiles\") err = pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_EmbeddedFiles.pdf &#125; 添加附件注释func ExampleFpdf_AddAttachmentAnnotation() &#123; pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") pdf.SetFont(\"Arial\", \"\", 12) pdf.AddPage() // Per page attachment file, err := ioutil.ReadFile(\"grid.go\") if err != nil &#123; pdf.SetError(err) &#125; a := gofpdf.Attachment&#123;Content: file, Filename: \"grid.go\", Description: \"Some amazing code !\"&#125; pdf.SetXY(5, 10) pdf.Rect(2, 10, 50, 15, \"D\") pdf.AddAttachmentAnnotation(&amp;a, 2, 10, 50, 15) pdf.Cell(50, 15, \"A first link\") pdf.SetXY(5, 80) pdf.Rect(2, 80, 50, 15, \"D\") pdf.AddAttachmentAnnotation(&amp;a, 2, 80, 50, 15) pdf.Cell(50, 15, \"A second link (no copy)\") fileStr := example.Filename(\"Fpdf_FileAnnotations\") err = pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_FileAnnotations.pdf &#125; 设置修改日期func ExampleFpdf_SetModificationDate() &#123; // pdfinfo (from http://www.xpdfreader.com) reports the following for this example : // ~ pdfinfo -box pdf/Fpdf_PageBox.pdf // Producer: FPDF 1.7 // CreationDate: Sat Jan 1 00:00:00 2000 // ModDate: Sun Jan 2 10:22:30 2000 pdf := gofpdf.New(\"\", \"\", \"\", \"\") pdf.AddPage() pdf.SetModificationDate(time.Date(2000, 1, 2, 10, 22, 30, 0, time.UTC)) fileStr := example.Filename(\"Fpdf_SetModificationDate\") err := pdf.OutputFileAndClose(fileStr) example.Summary(err, fileStr) // Output: // Successfully generated pdf/Fpdf_SetModificationDate.pdf &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://shuangdeyu.github.io/tags/Go/"},{"name":"PDF","slug":"PDF","permalink":"https://shuangdeyu.github.io/tags/PDF/"}]},{"title":"vue学习-小技巧记录","slug":"vue学习-小技巧记录","date":"2024-01-18T16:00:00.000Z","updated":"2024-01-30T03:29:52.426Z","comments":true,"path":"2024/01/19/vue-xue-xi-xiao-ji-qiao-ji-lu/","link":"","permalink":"https://shuangdeyu.github.io/2024/01/19/vue-xue-xi-xiao-ji-qiao-ji-lu/","excerpt":"","text":"基础class和style的绑定除了普通字符串之外，class和style的绑定还特别支持了对象和数组 &lt;p :class=\"&#123; red: isRed &#125;\" @click=\"toggleRed\"> This should be red... but click me to toggle it. &lt;/p> &lt;p :style=\"&#123; color &#125;\" @click=\"toggleColor\"> This should be green, and should toggle between green and blue on click. &lt;/p> // 一般绑定 &lt;div v-bind:id=\"dynamicId\" class=\"container\">&lt;/div> 字符串处理字符串反转message.value.split(‘’).reverse().join(‘’) const message = ref('Hello World!') function reverseMessage() &#123; message.value = message.value.split('').reverse().join('') &#125; 如果是数组反转，直接调用 reverse() 就行了 数组处理数组过滤对数组 data 中的每个对象 row，检查其属性值是否包含过滤关键字 filterKey，如果包含，则保留该对象，最终得到一个经过过滤的新数组 data = data.filter((row) => &#123; return Object.keys(row).some((key) => &#123; return String(row[key]).toLowerCase().indexOf(filterKey) > -1 &#125;); &#125;); 根据前缀字符串过滤数组const prefix = ref('') const filteredNames = computed(() => names.filter((n) => n.toLowerCase().startsWith(prefix.value.toLowerCase()) ) ) 数组排序对数组 data 中的对象根据指定的属性 key 进行排序，排序顺序由变量 order 控制。并且通过 slice 创建了一个原数组的浅拷贝，以免改变原始数据 data = data.slice().sort((a, b) => &#123; a = a[key]; b = b[key]; return (a === b ? 0 : a > b ? 1 : -1) * order; &#125;); [持续补充中……]","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://shuangdeyu.github.io/tags/vue/"}]},{"title":"vue开发文档查找手册","slug":"vue开发文档查找手册","date":"2024-01-10T16:00:00.000Z","updated":"2024-01-18T03:01:49.372Z","comments":true,"path":"2024/01/11/vue-kai-fa-wen-dang-cha-zhao-shou-ce/","link":"","permalink":"https://shuangdeyu.github.io/2024/01/11/vue-kai-fa-wen-dang-cha-zhao-shou-ce/","excerpt":"","text":"对于前端不是很熟悉，刚开始学vue很多概念还是很模糊的，官方文档的一些前端术语对于我这个后端来说第一世间不是很能理解 所以把官方文档里面的目录整理了下，每个条目下都有哪些内容，当做一个查找手册，至少遇到问题能够快速在文档中进行定位 官网地址：https://cn.vuejs.org/guide/introduction.html 基础模板语法模板（HTML）的相关操作 动态文本插值：&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; v-html 指令：插入一个html，而不是纯文本 v-bind 指令：将html中的元素的值跟变量进行动态绑定，比如给 div 动态设置 class 操作 指令 v-： 带有 v- 前缀的，见内置指令，有各种功能 有些能简写，比如用 :、@ 就行 还能绑定动态属性，比如： &lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt; 数据绑定支持 js 表达式写法：比如&#123;&#123; number + 1 &#125;&#125;，但不支持复杂的写法 响应式基础指自动追踪数据变化的功能，更新机制是 每当数据有变化时才会重现渲染DOM ref()：最常用的 Ref 可以持有任何类型的值，包括深层嵌套的对象、数组或者 JavaScript 内置的数据结构 Ref 会使它的值具有深层响应性。这意味着即使改变嵌套对象或数组时，变化也会被检测到 &lt;script setup&gt;： reactive()：另一种响应式，是对象本身具有响应性 返回的是一个原始对象的 Proxy(代理)，它和原始对象是不相等 局限性多 ref 解包细节 计算属性是一种在模板中声明数据的衍生属性的方式 将复杂逻辑放在 script 中计算输出，然后直接在模板中引用，不用在模板中进行复杂逻辑计算 计算属性缓存 vs 方法 计算属性值会基于其响应式依赖被缓存。一个计算属性仅会在其响应式依赖更新时才重新计算 方法调用总是会在重渲染发生时再次执行函数 可写计算属性：计算属性默认是只读的 可以通过同时提供 getter 和 setter 来支持计算 类与样式绑定讲述的是html中 class 的绑定和 css 样式的一些动态操作 Vue 专门为 class 和 style 的 v-bind 用法提供了特殊的功能增强。除了字符串外，表达式的值也可以是对象或数组 绑定html class 绑定对象 绑定数组 在组件上使用绑定 绑定内联样式 style 绑定对象 绑定数组 条件渲染条件运算 v-if v-else v-else-if &lt;template&gt; 上的 v-if 可以同时切换template包裹的多个元素 v-show v-if vs. v-show 列表渲染比如后端返回列表，前端用这个渲染 v-for v-for与对象 &lt;template&gt; 上的 v-for v-if 和 v-for 通过key管理状态 key是内置的特殊指令 类似于id，根据key的变化顺序重新排列元素 推荐在任何可行的时候为 v-for 提供一个 key 组件上使用v-for 数组变化侦测 Vue 能够侦听响应式数组的变更方法，并在它们被调用时触发相关的更新 展示过滤或排序后的结果 事件处理 监听事件：v-on:[触发动作] 指令 (简写为 @) 内联事件处理器：通常用于简单场景 方法事件处理器：v-on 也可以接受一个方法名或对某个方法的调用 在内联处理器中调用方法 在内联事件处理器中访问事件参数：在内联事件处理器中访问原生 DOM 事件 事件修饰符：修饰符是用 . 表示的指令后缀，比如 @click.stop 按键修饰符：监听按了哪个按键 鼠标按键修饰符 表单输入绑定在前端处理表单时，我们常常需要将表单输入框的内容同步给 JavaScript 中相应的变量。手动连接值绑定和更改事件监听器可能会很麻烦，v-model 指令帮我们简化了这一步骤 基本用法 文本 多行文本 复选框 单选按钮 选择器 值绑定 复选框 单选按钮 选择器选项 修饰符 .lazy .number .trim 组件上的 v-model 生命周期 注册周期钩子 举例来说，onMounted 钩子可以用来在组件完成初始渲染并创建 DOM 节点后运行代码 生命周期图示 还有其他一些钩子，会在实例生命周期的不同阶段被调用，最常用的是 onMounted、onUpdated 和 onUnmounted。所有生命周期钩子的完整参考及其用法请参考 API 索引 侦听器计算属性允许我们声明性地计算衍生值。然而在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。 在组合式 API 中，我们可以使用 watch 函数在每次响应式状态发生变化时触发回调函数 侦听数据源类型 深层侦听器：deep: true 即时回调的侦听器：immediate: true watchEffect() 回调的触发时机 默认情况下，用户创建的侦听器回调，都会在 Vue 组件更新之前被调用 想在侦听器回调中能访问被 Vue 更新之后的 DOM，你需要指明 flush: ‘post’ 选项 停止侦听器 如果用异步回调创建一个侦听器，那么它不会绑定到当前组件上，你必须手动停止它，以防内存泄漏 模板引用ref 是一个特殊的 attribute，和 v-for 章节中提到的 key 类似。它允许我们在一个特定的 DOM 元素或子组件实例被挂载后，获得对它的直接引用 访问模板引用​ v-for 中的模板引用 函数模板引用 除了使用字符串值作名字，ref attribute 还可以绑定为一个函数，会在每次组件更新时都被调用 组件上的ref 组件基础组件允许我们将 UI 划分为独立的、可重用的部分，并且可以对每个部分进行单独的思考。在实际应用中，组件常常被组织成层层嵌套的树状结构 定义一个组件 使用组件 传递 props Props 是一种特别的 attributes，你可以在组件上声明注册 当一个 prop 被注册后，可以像这样以自定义 attribute 的形式传递数据给它 以博客文章举例 监听事件 通过插槽来分配内容 &lt;slot /&gt;：占位符，父组件传递进来的内容就会渲染在这里 动态组件：有些场景会需要在两个组件间来回切换，比如 Tab 界面 &lt;component&gt; 元素和特殊的 is attribute DOM内模板解析注意事项 大小写区分：需要转换为相应等价的 kebab-case (短横线连字符) 形式 闭合标签：必须显式地写出关闭标签 元素位置限制 深入组件注册组件注册有两种方式：全局注册和局部注册 全局注册 .component() 方法 局部注册 组件名格式 使用 PascalCase 作为组件名的注册格式 Props Props声明 使用 &lt;script setup&gt; 的单文件组件中：使用 defineProps() 宏来声明 没有使用 &lt;script setup&gt; 的组件中：使用 props 选项来声明 传递prop的细节 Prop名字格式：camelCase 驼峰式，传递时写为 kebab-case 形式 静态VS动态 Prop 传递不同的值类型 使用一个对象绑定多个 prop 单向数据流 props 都遵循着单向绑定原则 更改对象 / 数组类型的 props，对象和数组是按引用传递，可以改值，但VUE中不推荐改 Prop 校验：即参数校验 Boolean 类型转换 组件事件 触发与监听事件 使用 $emit 方法触发自定义事件 父组件可以通过 v-on (缩写为 @) 来监听事件 组件的事件监听器也支持 .once 修饰符 事件参数 所有传入 $emit() 的额外参数都会被直接传向监听器 声明触发的事件 组件可以显式地通过 defineEmits() 宏来声明它要触发的事件 事件校验 组件v-modelv-model 可以在组件上使用以实现双向绑定 v-model 的参数 多个 v-model 绑定 处理 v-model 修饰符 带参数的 v-model 修饰符 透传 Attributes“透传 attribute”指的是传递给一个组件，却没有被该组件声明为 props 或 emits 的 attribute 或者 v-on 事件监听器。最常见的例子就是 class、style 和 id Attributes 继承 对 class 和 style 的合并 v-on 监听器继承 深层组件继承 禁用属性继承 多根节点的Attributes继承 在 JavaScript 中访问透传 Attributes 插槽 Slots 插槽内容与出口 &lt;slot&gt; 元素是一个插槽出口 (slot outlet)，标示了父元素提供的插槽内容 (slot content) 将在哪里被渲染 渲染作用域 默认内容：可以为插槽指定默认内容 具名插槽 动态插槽名：v-slot 作用域插槽 具名作用域插槽 高级列表组件示例 无渲染组件 依赖注入 Prop 逐级透传问题 provide、inject 一个父组件相对于其所有的后代组件，会作为依赖提供者。任何后代的组件树，无论层级有多深，都可以注入由父组件提供给整条链路的依赖 Provide (提供)：为组件后代提供数据 应用层 Provide Inject (注入) 注入默认值 和响应式数据配合使用 如果你想确保提供的数据不能被注入方的组件更改，你可以使用 readonly() 来包装提供的值 使用 Symbol 作注入名 异步组件在大型项目中，我们可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件 基本用法：defineAsyncComponent 加载与错误状态 搭配 Suspense 使用 逻辑复用组合式函数是一个利用 Vue 的组合式 API 来封装和复用有状态逻辑的函数 鼠标跟踪器示例 异步状态示例 接收响应式状态：watchEffect() 、 toValue() 约定和最佳实践 命名、输入参数、返回值、副作用、使用限制 通过抽取组合式函数改善代码结构 在选项式API中使用组合式函数 与其他模式的比较 延伸阅读 深入响应式原理：理解 Vue 响应性系统的底层细节 状态管理：多个组件间共享状态的管理模式 测试组合式函数：组合式函数的单元测试技巧 VueUse：一个日益增长的 Vue 组合式函数集合。源代码本身就是一份不错的学习资料 自定义指令除了 Vue 内置的一系列指令 (比如 v-model 或 v-show) 之外，Vue 还允许你注册自定义的指令 在 &lt;script setup&gt; 中，任何以 v 开头的驼峰式命名的变量都可以被用作一个自定义指令 在没有使用 &lt;script setup&gt; 的情况下，自定义指令需要通过 directives 选项注册 指令钩子 简化形式 对象字面量 在组件上使用 插件插件 (Plugins) 是一种能为 Vue 添加全局功能的工具代码 编写一个插件 内置组件TransitionVue 提供了两个内置组件，可以帮助你制作基于状态变化的过渡和动画，见以下两个组件： &lt;Transition&gt; 组件 基于CSS的过渡效果 JavaScript 钩子 可复用过渡效果 出现时过渡 元素间过渡 过渡模式 组件间过渡 动态过渡 TransitionGroup用于对 v-for 列表中的元素或组件的插入、移除和顺序改变添加动画效果 和 &lt;Transition&gt; 的区别 进入/离开动画 移动动画 渐进延迟列表动画 KeepAlive它的功能是在多个组件间动态切换时缓存被移除的组件实例 基本使用 包含/排除 最大缓存实例数 缓存实例的生命周期 Teleport它可以将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去 modal弹窗可以使用这个组件实现 基本用法 搭配组件使用 禁用Teleport 多个Teleport共享目标 Suspense是一个实验性功能 用来在组件树中协调对异步依赖的处理。它让我们可以在组件树上层等待下层的多个嵌套异步依赖项解析完成，并可以在等待时渲染一个加载状态 异步依赖 加载中状态 事件 错误处理 和其他组件结合 应用规模化单文件组件我们能够将一个 Vue 组件的模板、逻辑与样式封装在单个文件中，叫做单文件组件，简称SFC 为什么要使用SFC SFC是如何工作的 如何看待关注点分离 工具链介绍Vue相关的插件，脚手架，格式化等工具链 项目脚手架 Vite：优先选项 Vue CLI 代码规范 路由 客户端vs服务端路由 官方路由 从头开始实现一个简单的路由 状态管理 用响应式 API 做简单状态管理 SSR相关细节 Pinia 测试服务端渲染(SSR) 总览 什么是SSR 为什么要用SSR SSR vs. SSG 基础教程 渲染一个应用 客户端激活 代码结构 更通用的解决方案 Nuxt Quasar Vite SSR 书写SSR友好的代码 服务端响应性 组件生命周期钩子 访问平台特有API 跨请求状态污染 激活不匹配 自定义指令 Teleports 最佳实践生产部署 开发环境 vs. 生产环境 不使用构建工具 使用构建工具 追踪运行时错误 性能优化 分析选项 页面加载优化 选用正确的架构 包体积与 Tree-shaking 优化 代码分割 更新优化 Props 稳定性 v-once v-memo 计算属性稳定性 通用优化 大型虚拟列表 减少大型不可变数据的响应性开销 避免不必要的组件抽象 无障碍访问 跳过链接 内容结构 语义化表单 规范 资源 安全 首要规则：不要使用无法信赖的模板 Vue 自身的安全机制 潜在的危险 注入 HTML URL 注入 样式注入 JavaScript 注入 最佳实践 后端协调 服务端渲染 (SSR) TypeScript进阶主题","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://shuangdeyu.github.io/tags/vue/"}]},{"title":"年会不能停","slug":"《年会不能停》","date":"2024-01-09T16:00:00.000Z","updated":"2024-01-11T06:54:26.923Z","comments":true,"path":"2024/01/10/nian-hui-bu-neng-ting/","link":"","permalink":"https://shuangdeyu.github.io/2024/01/10/nian-hui-bu-neng-ting/","excerpt":"","text":"这部电影真的值得，当从电影出来的时候，脑子里想法很多，心想今天一定要为这部电影写点什么，无奈胸中无墨，一坐到电脑前却什么也写不出来，就简单说两点吧 因为现实题材的原因，它天然就容易引起人的共鸣，所谓好电影大概就是如此之一吧，源自生活，贴近生活。有笑有哭，不尬煽，不牵强，一切水到渠成，看得人特别过瘾，意犹未尽 我觉得喜剧的内核就该是批判，不然笑过了，然后呢，什么也没有记住，什么也没有得到，这是空虚的，这部电影则当得起一声优秀喜剧片的夸奖，笑料当中不断穿插批判，圆融自洽 这部电影的核心我觉得可以用两个成语概括：踏踏实实，脚踏实地，其实两者意思相似，年会不能停，奋斗不能息，还得是踏踏实实打工啊，别整虚的 最后，下面这首歌浓缩了整部电影的精华思想，当然，也是电影年会上的压轴曲目，献给大家，献给广大打工人，去获得一丝慰藉吧！ “我的未来不是梦，我认真地过每一分钟， 我的未来不是梦，我的心跟着希望在动。 我的未来不是梦，我认真地过每一分钟， 我的未来不是梦，我的心跟着希望在动。 跟着希望在动。” “你是不是像我在裁员中忐忑，守着岗位加班加点地工作。 你是不是像我就算每天背锅，也放不下五险一金的枷锁。 你是不是像我整体幻想能够，不用再看上司的脸色生活。 你是不是像我只会懦弱退缩，面对不公就应该打破沉默。” “我是马杰克，不是Magic，在K8待了几年没涨钱也没尊严， 落个头痛失眠，身体一年不如一年， 我干得兢兢业业，上司在莺莺燕燕。” “我是外包潘妮潘，脏活累活都我干， 功劳簿与我无关，说话从不兜弯弯， 我不算理想主义，我只想无愧自己， 油腻的酒局get off me，掌权黑手can’t beat off me。” “我是HR经理庄尼胡，标准件厂钳工胡师傅， 调任升职、没人在乎，不懂装懂、心里没谱， 啥叫颗粒度啊，整得我挺恍惚， 但是没关系，只要站对队伍、拍对马屁就保住前途。” “众和是众志成城天地人和， 其实不过是众星捧月、一唱一和。 基层人心惶惶，中层拉帮结党， 黑话说得很棒，表面风光，全是假象。” “总裁放个屁，总监翻成句，经理接到命令不能解密， 只想逃避，丢给基层，今晚OT，你做个PPT。” “做不满意，把他开除，万事大吉。 花天酒地，整体称兄道弟， 财务危机，贪污腐败不停， 自称扁平，等级像丛林。” “高楼大厦平地起，埋多少蝼蚁， 我是员工，不是奴隶，也想做我自己， 这么心酸压抑，有什么意义， 公司是一台机器，没有人性，只有目的地。” “我们不是螺丝钉，我们是人！ 人！被无故泄愤。 愤！也会恨，不能忍。 生活很累，不要气馁， 有时会颓，不进则退， 但对你们我不会跪。 胡师傅说真话从不后悔！” “请相信，你的未来不是梦，你认真地过每一分钟， 你的未来不是梦，你的坚持都不会落空。 我的未来不是梦，从九八年到这一分钟， 我的未来不是梦，风雨过后盼一道彩虹。 盼一道彩虹！”","categories":[{"name":"影评","slug":"影评","permalink":"https://shuangdeyu.github.io/categories/%E5%BD%B1%E8%AF%84/"}],"tags":[{"name":"电影","slug":"电影","permalink":"https://shuangdeyu.github.io/tags/%E7%94%B5%E5%BD%B1/"}]},{"title":"2024展望","slug":"2024展望","date":"2024-01-03T16:00:00.000Z","updated":"2024-01-04T05:14:40.151Z","comments":true,"path":"2024/01/04/2024-zhan-wang/","link":"","permalink":"https://shuangdeyu.github.io/2024/01/04/2024-zhan-wang/","excerpt":"","text":"又到新的一年啦，2023好赖怎样且不去说太多，总结一句话就是：不太好。 经历过裁员，艰难找工作，孩子确诊可能影响终生的病，家庭工作学习节奏紊乱……糟心事一件件，又一件件一堆堆，生活受挫了，心气磨平了，心也跟着彷徨了，好的会越来越好，差的会越来越差，我并不推崇挫折和磨难，能将他们当做踏脚石一飞冲天的无一不是人中龙凤，我自问做不到，很多人都做不到，但是他们又不会因为你不喜欢而不来找你，烦！ 说来奇怪，随着这一年走到终点，新的一年在烟花声中被敲开门户，这一切，好像都烟消云散一般，随着终年的黑幕悄悄褪去，仿佛整个人都迎来了崭新的人生，充满光明。 呵，颇有点自欺欺人的味道。这里就不给自己打气喝鸡汤了，底气来源于底蕴，再多再好的黄金鸡汤都不及一点点积累的，看得见的底蕴来得踏实。 所以啊，新的一年，我没有给自己定什么高大上，必须完成的目标，这一年，我给自己的规划只有一个：积累。 厚积薄发我是相信的，当你对未来感到迷茫的时候，与其想破头皮思考怎么破局，还不如不断积累，吃过的苦总有一天会用上，哪怕只有一部分。 希望到达2024终点的时候再回过头来看，能做到无愧于自己，更无愧于家庭即可。 虽说没有明确要完成的目标，但该有的计划还是要有的，积累也得有方向才对，只谈计划，不谈目标。 更新：2024-01-04 时间段 要做什么 想要得到什么 6:00 ~ 7:00 写小说/写文章 锻炼笔力，锻炼写作能力 上班途中 小说，短视频 娱乐放松一下 9:00 ~ 10:00 熟悉使用 etcd学习 vue 开始正式工作前充一下电，吃饭的技能不能落下 12:00 ~ 12:30 学习写作技巧(小红书)，笔记 扩展写作面的知识和技巧 下班途中 看书现重点：自闭症类 充电，扩展一下知识面 下班 ~ 睡前 孩子干预/学习干预方式 培养家庭干预能力，早日脱帽 阶段总结：","categories":[{"name":"生活","slug":"生活","permalink":"https://shuangdeyu.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://shuangdeyu.github.io/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"docker安装etcd集群","slug":"docker安装etcd集群","date":"2023-12-27T16:00:00.000Z","updated":"2024-01-04T02:22:18.684Z","comments":true,"path":"2023/12/28/docker-an-zhuang-etcd-ji-qun/","link":"","permalink":"https://shuangdeyu.github.io/2023/12/28/docker-an-zhuang-etcd-ji-qun/","excerpt":"","text":"相比起手动安装etcd，使用docker进行安装简直不要太简单，快多了，还不用怎么踩坑，遂记录下。 参考原文：https://blog.csdn.net/zuokaopuqingnian/article/details/87344662 1、环境规划本机：Apple M2 Pro 提前规划要安装的 etcd IP: 容器 组网内IP 客户端通信端口 peer通信端口 etcd0 192.167.0.168 2379 2380 etcd1 192.167.0.170 2479 2480 etcd2 192.167.0.172 2579 2580 前提：安装好docker 2、创建docker网络组docker network ls NETWORK ID NAME DRIVER SCOPE c5bd3f92c0f7 bridge bridge local ee5b4bb58cf5 etcdnet bridge local 9ec6da6b44ce host host local e7a8cfd630a6 none null local 可以看到当前机器下有哪些docker网络组 要将3个etcd容器装在一台机器上，创建一个子网络，将3个容器运行在同一个网络中进行通信 docker network create --subnet=192.167.0.0/16 etcdnet docker network create: 创建 Docker 网络的命令。 –subnet=192.167.0.0/16: 指定了该网络的子网。这个网络的 IP 地址范围是从 192.167.0.0 到 192.167.255.255。这是一个用于定义网络中可用 IP 地址的 CIDR（Classless Inter-Domain Routing）表示法。 etcdnet: 是为该网络指定的名称。在这个例子中，网络的名称被设置为 “etcdnet”。 总体而言，这个命令创建了一个名为 “etcdnet” 的 Docker 网络，该网络的 IP 地址范围是 192.167.0.0 到 192.167.255.255。容器连接到同一自定义网络的话，它们可以使用在该网络内定义的主机名或 IP 地址相互通信。这使得容器能够形成一个逻辑上隔离的网络群组。 以下来自GPT： 192.167.0.0/16 是一个 CIDR 表示法的 IP 地址范围，用于定义 Docker 自定义网络的子网。这个地址范围的选择通常基于你的网络规划和需求。在 CIDR 表示法中，**/16** 表示子网掩码的长度，即在这个范围内有 16 位用于网络地址，剩下的 16 位用于主机地址。这允许定义 2^16（65536）个主机地址。你可以根据你的实际需求选择一个适当的 IP 地址范围。有几个常见的私有 IP 地址范围，其中 192.168.0.0/16 是最常用的。192.167.0.0/16 是一个类似的私有地址范围，但并不像 192.168.0.0/16 一样广泛被用于家庭网络或企业网络。在你的场景中，你可以根据需要选择一个合适的范围。总的来说，选择 IP 地址范围时，确保它不会与你实际网络中的其他地址冲突，而且最好遵循标准的私有地址范围，以避免与全球互联网上的公共 IP 地址冲突。 3、安装etcd因为我是M1系统，ARM64架构的，所以特地找了一个ARM64架构的镜像（MAC可以通过开启Rosetta来运行AMD64架构的镜像），镜像下载地址在这： https://quay.io/repository/coreos/etcd?tab=tags 拉取镜像： docker pull quay.io/coreos/etcd:v3.5.11-arm64 完成后分别运行三个容器： docker run -d -p 2379:2379 -p 2380:2380 --restart=no --net etcdnet --ip 192.167.0.168 --name etcd0 quay.io/coreos/etcd:v3.5.11-arm64 /usr/local/bin/etcd --name autumn-client0 -advertise-client-urls http://192.167.0.168:2379 -listen-client-urls http://0.0.0.0:2379 -initial-advertise-peer-urls http://192.167.0.168:2380 -listen-peer-urls http://0.0.0.0:2380 -initial-cluster-token etcd-cluster -initial-cluster autumn-client0=http://192.167.0.168:2380,autumn-client1=http://192.167.0.170:2480,autumn-client2=http://192.167.0.172:2580 -initial-cluster-state new docker run -d -p 2479:2479 -p 2480:2480 --restart=no --net etcdnet --ip 192.167.0.170 --name etcd1 quay.io/coreos/etcd:v3.5.11-arm64 /usr/local/bin/etcd --name autumn-client1 -advertise-client-urls http://192.167.0.170:2479 -listen-client-urls http://0.0.0.0:2479 -initial-advertise-peer-urls http://192.167.0.170:2480 -listen-peer-urls http://0.0.0.0:2480 -initial-cluster-token etcd-cluster -initial-cluster autumn-client0=http://192.167.0.168:2380,autumn-client1=http://192.167.0.170:2480,autumn-client2=http://192.167.0.172:2580 -initial-cluster-state new docker run -d -p 2579:2579 -p 2580:2580 --restart=no --net etcdnet --ip 192.167.0.172 --name etcd2 quay.io/coreos/etcd:v3.5.11-arm64 /usr/local/bin/etcd --name autumn-client2 -advertise-client-urls http://192.167.0.172:2579 -listen-client-urls http://0.0.0.0:2579 -initial-advertise-peer-urls http://192.167.0.172:2580 -listen-peer-urls http://0.0.0.0:2580 -initial-cluster-token etcd-cluster -initial-cluster autumn-client0=http://192.167.0.168:2380,autumn-client1=http://192.167.0.170:2480,autumn-client2=http://192.167.0.172:2580 -initial-cluster-state new -d: 表示以“后台”或“守护进程”模式运行容器。 -p 2379:2379 -p 2380:2380: 将容器的2379和2380端口映射到主机的相应端口，使得可以通过主机上的这些端口与etcd服务进行交互。 –restart=no: 禁用容器的自动重启。 –net etcdnet –ip 192.167.0.168: 将容器连接到名为 “etcdnet” 的自定义网络，并指定容器的IP地址为 “192.167.0.168”。 –name etcd0: 为容器指定名称为 “etcd0”。 quay.io/coreos/etcd: 使用的Docker镜像，其中包含了etcd服务。 /usr/local/bin/etcd: 在容器内执行的etcd二进制文件的路径。 接下来是一系列的etcd配置参数： -advertise-client-urls http://192.167.0.168:2379: 指定etcd服务用于向客户端宣告自己的地址的URL。 -listen-client-urls http://0.0.0.0:2379: 指定etcd服务监听客户端请求的地址。 -initial-advertise-peer-urls http://192.167.0.168:2380: 指定etcd节点用于向集群宣告自己的地址的URL。 -listen-peer-urls http://0.0.0.0:2380: 指定etcd节点监听其他节点发来的请求的地址。 -initial-cluster-token etcd-cluster: 指定集群的令牌，确保不同的etcd集群之间不会发生冲突。 -initial-cluster autumn-client0=http://192.167.0.168:2380,autumn-client1=http://192.167.0.170:2480,autumn-client2=http://192.167.0.172:2580: 指定etcd集群的初始节点信息，包括各节点的名称和地址。 -initial-cluster-state new: 指定初始集群状态为新集群。 这个命令配置了一个etcd节点，它将在192.167.0.168地址上监听客户端和集群请求，并通过2379和2380端口对外提供服务。同时，它会加入一个初始集群，其中包括三个节点，分别是 “autumn-client0”、”autumn-client1” 和 “autumn-client2”，它们的地址分别是192.167.0.168、192.167.0.170和192.167.0.172。这个etcd集群使用了名为 “etcd-cluster” 的令牌，并且处于新集群的初始状态。 OK，三个都顺利跑起来了 关于验证，一般是进入容器，执行etcd相关指令进行验证是否安装成功： docker exec -it etcd0 /bin/sh 或者 docker exec -it 容器ID /bin/sh 执行 etcdctl put mykey \"hello world\" 或者 etcdctl endpoint health 等 但是我在机器上验证却报错： OCI runtime exec failed: exec failed: unable to start container process: exec: \"/bin/sh\": stat /bin/sh: no such file or directory: unknown 找了一圈，最后还是通过镜像信息发现了端倪镜像中有一个名为“distroless”的基础镜像，是一个轻量级的 Docker 镜像，它的设计目标是最小化容器的大小并提供足够的环境来运行特定类型的应用程序。由于 distroless 镜像中不包含标准的 Linux 发行版，因此通常不包含常见的 shell，例如 Bash。因此，直接进入 distroless 容器可能需要使用其他方法而不是使用 docker exec。 换种方式，可以通过直接在后面添加shell指令来运行，只不过麻烦了点而已： docker exec -it etcd0 etcdctl member list 4、安装可视化工具这里使用的是一个界面相对丰富，功能相对完善的etcd工具： https://github.com/gohutool/boot4go-etcdv3-browser 同样，直接使用docker安装： docker image pull joinsunsoft/etcdv3-browser 运行： docker run -d -p 9980:80 --name etcdv3-browser joinsunsoft/etcdv3-browser 搞定，新增上那三个etcd连接，然后添加集合、键值进行验证，成功默认登录账户密码是：ginghan/123456","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://shuangdeyu.github.io/tags/docker/"},{"name":"etcd","slug":"etcd","permalink":"https://shuangdeyu.github.io/tags/etcd/"}]},{"title":"Go连接Oracle，godror驱动使用记录","slug":"Go连接Oracle，godror驱动使用记录","date":"2023-12-14T16:00:00.000Z","updated":"2023-12-20T08:24:42.201Z","comments":true,"path":"2023/12/15/go-lian-jie-oracle-godror-qu-dong-shi-yong-ji-lu/","link":"","permalink":"https://shuangdeyu.github.io/2023/12/15/go-lian-jie-oracle-godror-qu-dong-shi-yong-ji-lu/","excerpt":"","text":"Go连接Oracle数据库用到的驱动主要有三个： https://github.com/sijms/go-ora：开箱即用，不用额外安装客户端驱动程序，真跨平台，但据说稳定性没其它几个好 https://github.com/mattn/go-oci8：安装驱动包本身之外，还要安装oracle客户端 https://github.com/godror/godror：安装驱动包本身之外，还要安装oracle客户端，跟oci8的区别是没安装oracle客户端的时候编译通过没问题，但使用会报错，而oci8是连编译的时候就会报错 因为要支持Oracle(OCI)连接模式，所以采用godror驱动进行开发，比较坑的是oracle不支持macOS-arm64…… 另外，OCI连接模式是指：在本地安装oracle客户端，通过客户端配置数据库的连接地址，而项目程序中连接的时候只要写配置名称即可，不用再显示编辑连接地址了，略显麻烦…… 1、安装godror咱先把测试程序写好 package main import ( \"database/sql\" \"fmt\" \"os\" _ \"github.com/godror/godror\" ) func main() &#123; db, err := sql.Open(\"godror\", `user=\"userName\" password=\"pass\" connectString=\"host:port/service_name\"`) if err != nil &#123; fmt.Println(err) os.Exit(1) &#125; err = db.Ping() if err != nil &#123; fmt.Println(\"oracle连接失败\") os.Exit(2) &#125; fmt.Println(\"oracle连接成功\") &#125; 如果开启了go.mod的话直接同步下依赖就行了，如果没有开启的话执行以下命令安装驱动包： go get github.com/godror/godror 这时候运行的话会报错，别急，往下走。 2、安装Oracle Client先放两个网址：Oracle的Instant Client套件下载地址Oracle的Instant Client套件安装文档 这里选择linux的，我是在linux上验证成功的选择基础包就行，比如：instantclient-basic-linux.x64-21.12.0.0.0dbru.zip 上传到服务器上解压，最后得到client包，比如：**/usr/local/instantclient_21_12** 然后设置环境变量，让驱动能找到客户端可以是这样，将 Instant Client 永久添加到运行时链接路径： sudo sh -c \"echo /usr/local/instantclient_21_12 > /etc/ld.so.conf.d/oracle-instantclient.conf\" sudo ldconfig 也可以添加到环境变量配置： vim ~/.bashrc // 最后面添加这一行 export LD_LIBRARY_PATH=/usr/local/instantclient_21_12:$LD_LIBRARY_PATH 这样就安装好了，再次运行程序就不会报错了，因为是后面写的文档，所以不贴运行图了 3、OCI连接方式到了最终目的，支持OCI连接方式了，其实也很简单 oracle常用的配置文件有： tnsnames.ora：定义用于建立连接的数据库别名的配置文件。 sqlnet.ora：这个比较全，可能包含有关连接故障转移、网络加密、日志记录和跟踪等功能的信息。 这里使用tnsnames.ora就好，没有的话新建一个文件即可 另外注意，这两个文件必须放到oracle能调用到的地方，主要有两种方式来发现配置文件： 直接设置环境变量TNS_ADMIN，这样的话配置文件随便你怎么放，通过变量指向即可 放到默认的network/admin目录下，这是oracle默认读取的目录，在下载的client下，比如：**/usr/local/instantclient_21_12/network/admin** 这里简单点，直接放到默认目录下就行了，然后编辑： ORCLPDB1 = (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = ORCLPDB1) ) ) 其中最头上的 ORCLPDB1 就是这个配置的名称然后就是修改一下 HOST 和 PORT 配置还之后修改下代码中的连接 dsn := `user=\"lalala\" password=\"123456\" connectString=\"ORCLPDB1\"` 可以看到 connectString 里面不再需要配置连接地址，而是直接配置上tnsnames.ora文件配置的名称即可 最后再次运行代码，success","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://shuangdeyu.github.io/tags/Go/"},{"name":"database","slug":"database","permalink":"https://shuangdeyu.github.io/tags/database/"}]},{"title":"macOS上使用踩坑DB2记录","slug":"macOS上使用踩坑DB2记录","date":"2023-12-12T16:00:00.000Z","updated":"2023-12-20T08:34:12.435Z","comments":true,"path":"2023/12/13/macos-shang-shi-yong-cai-keng-db2-ji-lu/","link":"","permalink":"https://shuangdeyu.github.io/2023/12/13/macos-shang-shi-yong-cai-keng-db2-ji-lu/","excerpt":"","text":"由于项目需求，需要对接很多种类的数据库，包括一些平时比较冷门甚至听都没听过的，而开发环境是MAC的M2，开发语言是Golang。 不得不说，这个开发环境对于很多数据库对接是很有难度的，首先很多数据库不支持在ARM架构系统上安装，而且Golang的数据库驱动除了主流的几个数据库之外，支持度并不是很好，很多甚至还不支持，就算支持也存在arm系统的问题，总的来说有点痛苦，踩了很多坑。 以下就记录下对接BD2的时候遇到的问题。 DB2就是IBM开发的一种大型关系型数据库平台。 一、安装安装就不说了，不要在mac M1 M2上安装，ibm官方只提供mac intel的安装包，docker镜像也都是amd系统的，在arm系统上运行会有问题。 所以我在公司申购了一台linux服务器专门用来支持各种开发环境用。 安装就略过了，直接docker安装即可。 直接贴上地址：https://www.yuque.com/shuangyu-rcged/network/bb7p905taxmm56sh 二、安装Go驱动IBM有提供针对Golang语言的DB2数据库驱动：https://github.com/ibmdb/go_ibm_db 其安装步骤如下：1、下载golang驱动包，使用下面任一指令即可，项目中有mod模块的话就更方便了，直接同步下依赖就行 go get -d github.com/ibmdb/go_ibm_db go install github.com/ibmdb/go_ibm_db/installer@latest go install github.com/ibmdb/go_ibm_db/installer@v0.4.5 2、安装odbc驱动除了下载安装golang程序驱动包之外，DB2的使用还需要安装odbc的驱动并进行一些相关配置 首先，设置驱动下载地址的环境变量，安装的时候会自动去这个地址下载，或者你也可以自己下载下来放到自己指定的目录 export IBM_DB_DOWNLOAD_URL=https://public.dhe.ibm.com/ibmdl/export/pub/software/data/db2/drivers/odbc_cli/v11.5.4/macos64_odbc_cli.tar.gz 下一步，如果你已经手动下载了的话就不用进行了，需要自动下载就进行下一步进入到第一步安装的golang驱动包里面的installer目录，比如我的是/Users/jyj/goproject/pkg/mod/github.com/ibmdb/go_ibm_db@v0.4.5/installer，里面有安装脚本 然后执行这条指令，自动下载驱动包： go run setup.go 这时执行完之后的目录，下载并解压完成驱动包 最后还要设置环境变量可以手动设置： export IBM_DB_HOME=/home/uname/go/src/github.com/ibmdb/clidriver export CGO_CFLAGS=-I$IBM_DB_HOME/include export CGO_LDFLAGS=-L$IBM_DB_HOME/lib export DYLD_LIBRARY_PATH=$DYLD_LIBRARY_PATH:$IBM_DB_HOME/lib 也可以运行脚本自动设置，在installer目录下： source setenv.sh 注意：但是，强烈建议将环境变量的设置放到’~/.zshrc‘中，因为写代码的时候编辑器可能会读取不到环境变量 整个驱动安装大致就是以上步骤了，其它windows、linux系统的看官方的github就可以了 三、问题安装完成，那剩下的就是开跑验证了，连接代码参考官方给出的示例： package main import ( \"database/sql\" \"fmt\" _ \"github.com/ibmdb/go_ibm_db\" ) func main() &#123; con := \"HOSTNAME=host;DATABASE=name;PORT=number;UID=username;PWD=password\" db, err := sql.Open(\"go_ibm_db\", con) if err != nil &#123; fmt.Println(err) &#125; db.Close() &#125; 1、github.com/ibmdb/go_ibm_db@v0.4.5/api/api_unix.go:14:11: fatal error: ‘sqlcli1.h’ file not found在goland里面运行可能会报这个错误，这是因为没有读取到环境变量，而我在goland的运行配置里面加上这些驱动的环境变量也没有生效，所以上面我建议将驱动的环境变量配置到系统文件’~/.zshrc’中，作为全局，可以取消这个报错如果你一开始就用命令行直接运行则没问题 另外，还可能会有这个提示：很明显是’CGO_CFLAGS’这个环境变量的问题，按照提示修改成这样 export CGO_CFLAGS=\"-I$IBM_DB_HOME/include -O0 -g\" 当然，上面这两个错误基本是在使用goland编辑器运行程序的时候会报错，因为想要开发调试方便，所以必须要解决 2、building for macOS-arm64 but attempting to link with file built for macOS-x86_64根据错误描述可知，这个驱动其实是不兼容macOS-arm64的，在我将项目部署到linux-amd64上运行成功之后，验证了这一事实的准确性。 那么如何在macOS-arm64上跑起来呢？ 查询资料有说是用Rosetta 2模拟x86架构去跑的： arch -x86_64 go run main.go 决定试一试，经过一番试验之后，得出结论，当前arm64系统安装的golang版本也是arm架构的，那么我再安装一个amd64版本的golang，用它去跑程序是不是就行了。 首先，在Rosetta总安装brew： arch -x86_64 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 然后安装golang，放心安装，不会影响之前安装的golang环境： arch -x86_64 brew install go@1.19 因为在命令行下运行会涉及到环境变量的修改等问题，再次借助goland可以很方便切换运行环境，并成功运行，可以达到我在mac-arm64方便开发调试的目的： // 命令行运行会报错 arch -x86_64 /usr/local/Cellar/go@1.19/1.19.13/libexec/bin/go run main.go 在这里切换goroot： 切换完再运行程序就顺利跑起来了，唯一有缺憾的是切换成amd64的golang的话，在arm64下的goland中无法使用debug功能，只能通过打印的方式进行调试了。","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"database","slug":"database","permalink":"https://shuangdeyu.github.io/tags/database/"},{"name":"mac","slug":"mac","permalink":"https://shuangdeyu.github.io/tags/mac/"}]},{"title":"k8s学习笔记(1)—kubeadm安装k8s","slug":"k8s学习笔记(1)—kubeadm安装k8s","date":"2023-12-07T16:00:00.000Z","updated":"2023-12-20T08:34:12.424Z","comments":true,"path":"2023/12/08/k8s-xue-xi-bi-ji-1-kubeadm-an-zhuang-k8s/","link":"","permalink":"https://shuangdeyu.github.io/2023/12/08/k8s-xue-xi-bi-ji-1-kubeadm-an-zhuang-k8s/","excerpt":"","text":"k8s万里长征的第一步 一、前置步骤 服务器规划 节点名称 IP 配置 k8s-master1 192.168.2.124 centos7，4G，2CPU k8s-node1 192.168.2.105 centos7，2G，2CPU k8s-node2 192.168.2.106 centos7，2G，2CPU 关闭系统防火墙 systemctl stop firewalld systemctl disable firewalld 关闭selinux sed -i 's/enforcing/disabled/' /etc/selinux/config #永久 setenforce 0 # 临时 关闭swap swapoff -a #临时 sed -ri 's/.*swap.*/#&amp;/' /etc/fstab #永久 根据规划设置主机名 hostnamectl set-hostname k8s-master1 hostnamectl set-hostname k8s-node1 hostnamectl set-hostname k8s-node2 添加hosts cat >> /etc/hosts &lt;&lt; EOF 192.168.2.124 k8s-master1 192.168.2.105 k8s-node1 192.168.2.116 k8s-node2 EOF 时间同步 yum install chrony -y systemctl start chronyd systemctl enable chronyd chronyc sources 配置ssh互信 # 直接一直回车就行 ssh-keygen ssh-copy-id -i ~/.ssh/id_rsa.pub root@k8s-master1 ssh-copy-id -i ~/.ssh/id_rsa.pub root@k8s-node1 ssh-copy-id -i ~/.ssh/id_rsa.pub root@k8s-node2 更换yum源 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup wget -O Centos-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo yum clean all yum makecache yum -y install update 允许 iptables 检查桥接流量 允许 iptables 检查桥接流量（可选，所有节点） 若要显式加载此模块，请运行 sudo modprobe br_netfilter，通过运行 lsmod | grep br_netfilter 来验证 br_netfilter 模块是否已加载 sudo modprobe br_netfilter lsmod | grep br_netfilter 为了让你的 Linux 节点上的 iptables 能够正确地查看桥接流量，你需要确保在你的 sysctl 配置中将 net.bridge.bridge-nf-call-iptables 设置为 1。例如： cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf br_netfilter EOF cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sudo sysctl --system 升级内核 3.10内核在大规模集群具有不稳定性,所以需要升级内核 。(所有机器都要升级到一样) #查看内核版本 $ uname -sr #系统更新 $ yum update #载入公钥 $ rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org #安装 ELRepo 最新版本 $ yum install -y https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm #列出可以使用的 kernel 包版本 $ yum list available --disablerepo=* --enablerepo=elrepo-kernel #安装指定的 kernel 版本：(已查看版本为准,采用lt长期支持版本) $ yum install -y kernel-lt-5.4.251-1.el7.elrepo --enablerepo=elrepo-kernel #查看系统可用内核 $ cat /boot/grub2/grub.cfg | grep menuentry #设置开机从新内核启动 $ grub2-set-default \"CentOS Linux (5.4.251-1.el7.elrepo.x86_64) 7 (Core)\" #查看内核启动项 $ grub2-editenv list saved_entry=CentOS Linux (5.4.251-1.el7.elrepo.x86_64) 7 (Core) #重启系统使内核生效： $ reboot #启动完成查看内核版本是否更新： $ uname -r 5.4.188-1.el7.elrepo.x86_64 二、安装docker# 安装yum-config-manager配置工具 yum -y install yum-utils # 设置yum源 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 安装docker-ce版本 yum install -y docker-ce # 启动 systemctl start docker # 开机自启 systemctl enable docker # 查看版本号 docker --version # 查看版本具体信息 docker version # Docker镜像源设置 # 修改文件 /etc/docker/daemon.json，没有这个文件就创建 # 添加以下内容后，重启docker服务： cat >/etc/docker/daemon.json&lt;&lt;EOF &#123; \"registry-mirrors\": [ \"https://docker.mirrors.ustc.edu.cn\", \"https://registry.docker-cn.com\", \"https://5tdtrypx.mirror.aliyuncs.com\" ] &#125; EOF # 加载 systemctl reload docker # 查看 systemctl status docker containerd 三、配置 k8s yum 源（所有节点）cat &lt;&lt;EOF &gt; &#x2F;etc&#x2F;yum.repos.d&#x2F;kubernetes.repo [kubernetes] name&#x3D;Kubernetes baseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;repos&#x2F;kubernetes-el7-x86_64&#x2F; enabled&#x3D;1 gpgcheck&#x3D;0 repo_gpgcheck&#x3D;0 gpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;yum-key.gpg https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;rpm-package-key.gpg EOF 四、将 sandbox_image 镜像源设置为阿里云 google_containers 镜像源（所有节点）# 导出默认配置，config.toml这个文件默认是不存在的 containerd config default &gt; &#x2F;etc&#x2F;containerd&#x2F;config.toml grep sandbox_image &#x2F;etc&#x2F;containerd&#x2F;config.toml sed -i &quot;s#k8s.gcr.io&#x2F;pause#registry.aliyuncs.com&#x2F;google_containers&#x2F;pause#g&quot; &#x2F;etc&#x2F;containerd&#x2F;config.toml grep sandbox_image &#x2F;etc&#x2F;containerd&#x2F;config.toml 五、配置 containerd cgroup 驱动程序 systemd（所有节点）kubernets 自ｖ 1.24.0 后，就不再使用 docker.shim，替换采用 containerd 作为容器运行时端点。因此需要安装 containerd（在 docker 的基础下安装），上面安装 docker 的时候就自动安装了 containerd 了。这里的 docker 只是作为客户端而已。容器引擎还是 containerd。 sed -i &#39;s#SystemdCgroup &#x3D; false#SystemdCgroup &#x3D; true#g&#39; &#x2F;etc&#x2F;containerd&#x2F;config.toml # 应用所有更改后,重新启动containerd systemctl restart containerd 六、开始安装 kubeadm，kubelet 和 kubectl（所有节点）# 不指定版本就是最新版本 yum install -y kubelet-1.19.5 kubeadm-1.19.5 kubectl-1.19.5 # 设置为开机自启并现在立刻启动服务 --now：立刻启动服务 systemctl enable --now kubelet # 查看状态，这里需要等待一段时间再查看服务状态，启动会有点慢 systemctl status kubelet journalctl -xefu kubelet 查看日志，发现有报错，报错如下：kubelet.service: Main process exited, code=exited, status=1/FAILURE kubelet.service: Failed with result ‘exit-code’. 【解释】重新安装（或第一次安装）k8s，未经过 kubeadm init 或者 kubeadm join 后，kubelet 会不断重启，这个是正常现象……，执行 init 或 join 后问题会自动解决，对此官网有如下描述，也就是此时不用理会 kubelet.service。 于是，先进行下面的kubeadm init后再来启动。采用1.19.5版本，其它高版本的报错报错太多，安装失败 七、使用 kubeadm 初始化集群（master 节点）kubeadm init \\ --apiserver-advertise-address&#x3D;192.168.2.124 \\ --image-repository registry.aliyuncs.com&#x2F;google_containers \\ --control-plane-endpoint&#x3D;cluster-endpoint \\ --kubernetes-version v1.19.5 \\ --service-cidr&#x3D;10.1.0.0&#x2F;16 \\ --pod-network-cidr&#x3D;10.244.0.0&#x2F;16 # –image-repository string： 这个用于指定从什么位置来拉取镜像（1.13版本才有的），默认值是k8s.gcr.io，我们将其指定为国内镜像地址：registry.aliyuncs.com&#x2F;google_containers # –kubernetes-version string： 指定kubenets版本号，默认值是stable-1，会导致从https:&#x2F;&#x2F;dl.k8s.io&#x2F;release&#x2F;stable-1.txt下载最新的版本号，我们可以将其指定为固定版本（v1.22.1）来跳过网络请求。 # –apiserver-advertise-address 指明用 Master 的哪个 interface 与 Cluster 的其他节点通信。如果 Master 有多个 interface，建议明确指定，如果不指定，kubeadm 会自动选择有默认网关的 interface。这里的ip为master节点ip，记得更换。 # –pod-network-cidr 指定 Pod 网络的范围。Kubernetes 支持多种网络方案，而且不同网络方案对 –pod-network-cidr有自己的要求，这里设置为10.244.0.0&#x2F;16 是因为我们将使用 flannel 网络方案，必须设置成这个 CIDR。 # --control-plane-endpoint cluster-endpoint 是映射到该 IP 的自定义 DNS 名称，这里配置hosts映射：192.168.0.113 cluster-endpoint。 这将允许你将 --control-plane-endpoint&#x3D;cluster-endpoint 传递给 kubeadm init，并将相同的 DNS 名称传递给 kubeadm join。 稍后你可以修改 cluster-endpoint 以指向高可用性方案中的负载均衡器的地址。 首次初始化的时候会失败，因为之前的 kubelet 没有运行，但这次初始化之后则运行了，于是： 重置再初始化 kubeadm reset rm -fr ~&#x2F;.kube&#x2F; &#x2F;etc&#x2F;kubernetes&#x2F;* var&#x2F;lib&#x2F;etcd&#x2F;* kubeadm init \\ --apiserver-advertise-address&#x3D;192.168.2.124 \\ --image-repository&#x3D;registry.aliyuncs.com&#x2F;google_containers \\ --control-plane-endpoint&#x3D;cluster-endpoint \\ --kubernetes-version v1.19.5 \\ --service-cidr&#x3D;10.1.0.0&#x2F;16 \\ --pod-network-cidr&#x3D;10.244.0.0&#x2F;16 # –image-repository string： 这个用于指定从什么位置来拉取镜像（1.13版本才有的），默认值是k8s.gcr.io，我们将其指定为国内镜像地址：registry.aliyuncs.com&#x2F;google_containers # –kubernetes-version string： 指定kubenets版本号，默认值是stable-1，会导致从https:&#x2F;&#x2F;dl.k8s.io&#x2F;release&#x2F;stable-1.txt下载最新的版本号，我们可以将其指定为固定版本（v1.22.1）来跳过网络请求。 # –apiserver-advertise-address 指明用 Master 的哪个 interface 与 Cluster 的其他节点通信。如果 Master 有多个 interface，建议明确指定，如果不指定，kubeadm 会自动选择有默认网关的 interface。这里的ip为master节点ip，记得更换。 # –pod-network-cidr 指定 Pod 网络的范围。Kubernetes 支持多种网络方案，而且不同网络方案对 –pod-network-cidr有自己的要求，这里设置为10.244.0.0&#x2F;16 是因为我们将使用 flannel 网络方案，必须设置成这个 CIDR。 # --control-plane-endpoint cluster-endpoint 是映射到该 IP 的自定义 DNS 名称，这里配置hosts映射：192.168.0.113 cluster-endpoint。 这将允许你将 --control-plane-endpoint&#x3D;cluster-endpoint 传递给 kubeadm init，并将相同的 DNS 名称传递给 kubeadm join。 稍后你可以修改 cluster-endpoint 以指向高可用性方案中的负载均衡器的地址。 按提示执行下面的指令 mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config 记住提示中node节点加入集群的命令，格式如下 kubeadm join 192.168.2.116:6443 --token bx6dlx.30zedu4gg6co3vsp --discovery-token-ca-cert-hash sha256:0736b1babd378116c2e436a73815b1013b20c58f3277b72f0a5f6e0ad2fdac5a 如忘了可以这样获取 kubeadm token create --print-join-command 查看节点状态，为noready，需要安装网络插件 kubectl get nodes 安装网络插件flannel，官网在github https://github.com/flannel-io/flannel上等待一段时间，直到所有的flannel容器都运行起来 kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml 八、初始化node节点执行kubeadm joinkubeadm join 192.168.2.10:6443 ……（见上方master记录的kubeadm join指令） 在master节点上查看状态 kubectl get nodes 九、测试kubernetes集群在Kubernetes集群中创建一个pod，验证是否正常运行： 创建nginx容器 kubectl create deployment nginx --image=nginx 暴露对外端口 kubectl expose deployment nginx --port=80 --type=NodePort 查看nginx是否运行成功 kubectl get pod,svc 在浏览器访问。三个结点都可访问，说明集群已经搭建完成， 十、k8s 管理平台 dashboard 环境部署GitHub 地址：https://github.com/kubernetes/dashboard kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;dashboard&#x2F;v2.6.0&#x2F;aio&#x2F;deploy&#x2F;recommended.yaml kubectl get pods -n kubernetes-dashboard 但是这个只能内部访问，所以要外部访问，要么部署 ingress，要么就是设置 service NodePort 类型。这里选择 service 暴露端口。 wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;dashboard&#x2F;v2.6.0&#x2F;aio&#x2F;deploy&#x2F;recommended.yaml 修改后的内容如下： 部署并查看： kubectl apply -f recommended.yaml kubectl get svc,pods -n kubernetes-dashboard 访问 Dashboard的web界面访问地址：https://NodeIP:30001 【必须是https】，部署在node节点的，用node节点的ip，而且google浏览器因为证书问题无法访问，用360极速可以访问 创建service account并绑定默认cluster-admin管理员集群角色：【依次执行】 kubectl create serviceaccount dashboard-admin -n kube-system kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin kubectl describe secrets -n kube-system $(kubectl -n kube-system get secret | awk '/dashboard-admin/&#123;print $1&#125;') 然后介绍一个更好的管理工具：https://www.kuboard.cn/","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://shuangdeyu.github.io/tags/docker/"},{"name":"k8s","slug":"k8s","permalink":"https://shuangdeyu.github.io/tags/k8s/"}]},{"title":"如何在Mac上安装oracle","slug":"如何在Mac上安装oracle","date":"2023-12-06T16:00:00.000Z","updated":"2023-12-20T08:35:53.964Z","comments":true,"path":"2023/12/07/ru-he-zai-mac-shang-an-zhuang-oracle/","link":"","permalink":"https://shuangdeyu.github.io/2023/12/07/ru-he-zai-mac-shang-an-zhuang-oracle/","excerpt":"","text":"使用电脑是Mac M1，Arm架构的，使用docker安装，网上搜了一下，发现网上公开的oracle镜像都不是Arm架构的，oracle对Arm的支持度不高，尝试了几个一直无法使用，连接的时候一直报错：Lost contact。 大多数人的解决方案都是如下几种： 方法1免费，安装utm然后在utm 里面安装虚拟机，debian或者ubuntu 一定要x86-64的版本，推荐debian然后在虚拟机里面安装docker 环境，就可以用oracle linux的镜像了。方法2收费安装parallels desktop for arm版本，安装windows11然后在里面安装oracle12c 测试可以。方法3收费安装utm，在里面安装windows11然后在里面安装oracle12c 测试可以。 方法1比较慢，性能差，用做测试都比较勉强。推荐2，2和3性能差不多，2方便一些。 我还是觉得太麻烦了，毕竟只是轻度使用，最终找到一个靠谱的解决方案，并且安装连接成功： 下面就记录下安装过程。 1、下载 Oracle Database 19c 安装文件 访问 Oracle 官网: https://www.oracle.com/cn/database/technologies/oracle-database-software-downloads.html#19c 往下翻，找到ARM架构的包 下载并保存到你的机器上，不需要解压。 2、下载 Docker Images 源码 访问 Docker 官方 GitHub 仓库：https://github.com/oracle/docker-images 直接下载zip包，不需要clone。 解压缩下载的 ZIP 文件。 资源准备完成： 3、构建 Oracle 19c Docker 镜像 进入 docker-images-main/OracleDatabase/SingleInstance/dockerfiles/19.3.0 目录 将下载的 LINUX.ARM64_1919000_db_home.zip 文件复制到该目录下。 打开目录下的 Dockerfile 文件，修改将安装包换成自己下载的 ARG INSTALL_FILE_1=\"LINUX.ARM64_1919000_db_home.zip\" 然后在该目录下执行命令，构建镜像，等待构建完成 ./buildContainerImage.sh -v 19.3.0 -e 4、运行 Oracle 19c Docker 容器构建完成后能看到这个镜像，表示镜像构建成功，然后就是运行它： docker run -d -p 1521:1521 --name oracle-local oracle/database:19.3.0-ee 进入容器执行命令，不需要用root身份进入，直接进入即可： docker exec -it [容器id] /bin/bash 在容器中依次执行以下命令： // 登录oracle sqlplus /nolog // 连接到 sysdba 数据库，这次成功了，之前就是卡在这里，报‘Lost contact’错误 conn /as sysdba // 修改system用户的密码为system alter user system identified by system; // 修改sys用户的密码为sys alter user sys identified by sys; // 本来是想创建一个用户用来连接的，但是报‘ORA-65096: invalid common user or role name’这个错误 // 查询说是当前数据库是容器数据库(CDB)，它不允许创建任何本地用户。要切换到可插拔数据库(PDB)，然后执行该操作或创建一个普通用户 // 这里只是测试用，能保证连接就行了，就不继续尝试了 create user jyj identified by 123456; **** 这里更正一个错误 **** 最新两版的oracle CDB容器中用户名必须加 'c##' 前缀才能创建成功，授权也一样，比如下面所示： create user c##jyj identified by 123456; // 修改密码规则为永不过期 ALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED; // 重启下数据库 shutdown immediate; startup; // 退出，搞定 exit 5、连接oracle数据库这里服务名或SID不知道的话，重新登录容器中数据库上，查询一下即可： // 服务名查询 show parameter service_name; // SID查询 select instance_name from v$instance; // 版本号查询 select version from v$instance; 6、补充：创建用户上面说了CDB容器中用户名必须加 ‘c##’ 前缀才能创建成功，这里不推荐使用这个方法，因为我用Golang程序的驱动去连接，会出现问题，url解析会报错，因为连接的时候用户名也得带上c##所以还是老老实实按照常规方法创建用户连接 以下是创建步骤： 切换到 PDB： 使用 ALTER SESSION 语句来切换到指定的 PDB。假设你要切换到名为 your_pdb_name 的 PDB： // 查看PDB列表 show pdbs; ALTER SESSION SET CONTAINER = your_pdb_name; 创建用户： 在所选的 PDB 中创建用户。以下是创建用户的示例： CREATE USER your_username IDENTIFIED BY your_password; 替换 your_username 和 your_password 为实际的用户名和密码。 授予权限： 给新创建的用户授予适当的权限。以下是授予权限的示例： GRANT CONNECT, RESOURCE TO your_username; 根据需要，你可能需要授予其他权限。 连接到数据库： 使用客户端连接到数据库。在连接字符串中指定所选的 PDB、用户名和密码。例如，如果使用 SQL*Plus： sqlplus your_username&#x2F;your_password@your_pdb_name 或者使用其他数据库客户端工具，确保在连接字符串中正确指定了 PDB 名称、用户名和密码。 注意：连接的时候服务名就是你所选的PDB的名称，因为你是在这个PDB下操作的。 还有一个坑：实际使用的时候可能会遇到ORA-01918、ORA-01950等等问题，按照网上别人的案例操作怎么都不成功，主要原因还是CDB和PDB的问题，在PDB中创建的用户记得要先切换到PDB中才能进行下一步操作，不然会遇到用户不存在等问题即上面的第一步：切换到 PDB","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"database","slug":"database","permalink":"https://shuangdeyu.github.io/tags/database/"},{"name":"mac","slug":"mac","permalink":"https://shuangdeyu.github.io/tags/mac/"}]},{"title":"Teamcity自动部署Go项目初尝试","slug":"Teamcity自动部署Go项目初尝试","date":"2023-12-05T16:00:00.000Z","updated":"2023-12-28T02:58:12.275Z","comments":true,"path":"2023/12/06/teamcity-zi-dong-bu-shu-go-xiang-mu-chu-chang-shi/","link":"","permalink":"https://shuangdeyu.github.io/2023/12/06/teamcity-zi-dong-bu-shu-go-xiang-mu-chu-chang-shi/","excerpt":"","text":"首先介绍一下TeamCity是什么： TeamCity 是一款由 JetBrains 开发的强大的持续集成（Continuous Integration，CI）和持续部署（Continuous Deployment，CD）工具。它帮助开发团队自动化构建、测试和部署过程，以确保软件项目的质量和快速交付。 其实就是类似于Jenkins的CI/CD工具，但界面更加美化，操作更简单，今天就来尝试一下使用teamcity自动构建部署Go程序。 一、安装安装就不多说了，网上教程很多，各个环境的都有，我是mac环境，通过docker方式安装，按照下面这个教程来安装的：https://www.yuque.com/shuangyu-rcged/network/ueyyn4quawwbeyiw安装的镜像主要包含两部分： teamcity-server：:::tipsteamcity的服务端部分，提供管理和操作::: teamcity-agent：:::tips作用是在 CI/CD 流程中负责具体的构建、测试和部署任务。TeamCity 是一个分布式 CI/CD 系统，可以在多个 Agent 上并行执行构建任务，提高了构建和测试的效率 构建代码： TeamCity Agent 负责拉取源代码，并在本地环境中进行编译、构建、打包等操作，生成可执行文件、库文件或者其他构建产物。 运行测试： Agent 可以运行单元测试、集成测试等各种测试用例。它会执行预先配置好的测试任务，并将测试结果反馈给 TeamCity 服务器。 代码分析： TeamCity Agent 可以执行代码静态分析、代码质量检查等任务，帮助开发团队发现代码中的问题，提供代码质量报告。 部署应用程序： 在持续交付流程中，Agent 可以负责将构建好的应用程序部署到测试环境、预生产环境或生产环境中。这包括复制文件、设置配置、运行数据库迁移等操作。 执行自动化任务： TeamCity Agent 可以执行各种自动化任务，例如数据库迁移、静态文件生成、文档生成等，以便将应用程序部署到可运行状态。 TeamCity Agent 与 TeamCity 服务器进行通信，接收来自服务器的构建任务，执行任务，然后将结果报告给服务器。它可以运行在不同的操作系统上，并且支持多种编程语言和构建工具。通过分布式部署，TeamCity Agent 能够提供高度可扩展性，以适应不同规模的项目和团队需求。::: 如果是在本机安装则简单多了，直接解压运行即可：https://www.yuque.com/shuangyu-rcged/network/bwosfkchn7pwdatg 区别：相较于docker安装，本机安装则更加简单，踩的坑很少，因为docker安装的话会缺少环境，导致go程序无法构建，要做很多步骤，这下面会说到但折腾一番也不失为是件有意义的事情，折腾的过程其实就是学习新知识的过程 二、在teamcity-agent上安装go环境这对我来说应该不是第二步，因为我踩过坑，知道有这么个问题，所以提前放到这里了 因为执行编译和构建的是teamcity-agent，所以只需要在agent上安装环境即可，安装方式就是进入docker容器的指令模式，进行安装： docker exec -it -u root &#123;容器id&#125; /bin/bash 注意登录的时候使用root身份登录，因为会有权限问题 然后就是正常的，在linux中安装go环境的步骤： cd /usr/local wget https://dl.google.com/go/go1.20.5.linux-arm64.tar.gz tar -xvf go1.20.5.linux-arm64.tar.gz rm -rf go1.20.5.linux-arm64.tar.gz export GOROOT=/usr/local/go export PATH=$PATH:$GOROOT/bin export GOPATH=/home/goproject export GOPROXY=https://goproxy.cn export GO111MODULE=on go env 能打印出go的环境信息就说明安装成功了 ok，本以为万事大吉，回到teamcity执行构建，发现还是报错：go not found 再次进入docker容器，执行 go env 发现环境没有生效，期间找了很多网上资料，什么在 /root/.bashrc 中设置环境变量，在 /etc/bash.bashrc 中设置环境变量，虽然最后重新进入或者重启容器的确都能打印出环境变量，但到了teamcity中构建的时候还是 go not found 着实费了一番功夫，其实要解决这个问题很简单，请看下面。 三、在teamcity中创建项目并添加构建步骤在左上角创建一个项目，然后进入设置 1、VCS设置其实就是代码仓库，根据自己实际使用的平台设置即可，其它还有很多项目设置，因为是初步尝试，所以没有深入研究，就先不管了，这个就够用了 2、构建步骤设置这一步就是真正对构建部署的设置，也是最重要的设置，点击 Build 设置里面的 Build Steps 即可出现设置界面，下面是我已经设置好的界面，总共有4个步骤： 构建流程规划：这里没有打包成docker，走的还是最原始的编译运行的形式，其大致流程如下 然后看下我的测试项目结构：dockerfile忽略，这次还没用到，主要的就是main.go、和start.sh这两个文件，前者是程序，后者是快速运行程序的脚本，注意开启go.mod，不然在agent中编译的时候还得自己手动下载包 package main import \"github.com/gin-gonic/gin\" func main() &#123; router := gin.Default() router.GET(\"/test\", func(c *gin.Context) &#123; c.JSON(200, gin.H&#123; \"message\": \"Luckly Successful!\", &#125;) &#125;) err := router.Run(\":7788\") if err != nil &#123; panic(\"Run services error\") &#125; &#125; #!/bin/sh current_date=`date +%Y-%m-%d` sudo kill -9 $(pidof /Users/yuyuyu/tmp/test_go_teamcity/test_go_teamcity) sudo nohup /Users/yuyuyu/tmp/test_go_teamcity/test_go_teamcity > /Users/yuyuyu/tmp/test_go_teamcity/test_go_teamcity-$&#123;current_date&#125;.log 2>&amp;1 &amp; 再回到构建步骤，一步步分析： 2.1 编译 export GOROOT=/usr/local/go export PATH=$PATH:$GOROOT/bin export GOPATH=/home/goproject export GOPROXY=https://goproxy.cn export GO111MODULE=on rm -rf .git rm -rf .gitignore rm -rf README.md go mod tidy GOOS=darwin GOARCH=arm64 go build -a -o test_go_teamcity main.go 上面不是说在agent中装好go环境后，怎么构建都报 go not found 的错误吗，这里只要每次构建的时候加上设置环境变量的指令就行了agent会将代码仓库的代码拉取到它本地，/opt/buildagent/work 中的某个项目目录，然后执行 go build 编译就行了这里我加了交叉编译，因为远程服务器设置的是我自己的电脑，要在mac上执行，不加的话是运行不了的 2.2 打包构建类型跟上一步一样，也选择 ‘Command Line’类型，执行指令如下： tar -cvf test_go_teamcity.tar.gz start.sh test_go_teamcity 最终编译好之后我们需要的只有执行程序test_go_teamcity和start.sh，将这两个文件打包就行了 2.3 上传将打包好的压缩包上传到远程服务器，就是线上环境，这里测试我用的是自己的电脑，其中Target：格式是 [服务器ip:上传文件放置的位置]，是服务器的地址Paths to sources：源文件的位置，%system.teamcity.build.workingDir% 就是这个项目工作目录，最终就是 /opt/buildagent/work/aebbfdbb93b9d7dc/test_go_teamcity.tar.gz用户名密码就是远程服务器的用户名密码 2.4 运行 cd /Users/jyj/tmp/test_go_teamcity sudo tar -zxvf test_go_teamcity.tar.gz sudo rm -rf test_go_teamcity.tar.gz sudo chmod +x test_go_teamcity sudo chmod +x start.sh sudo ./start.sh 在远程服务器上执行的命令，也就是解压缩刚才传过来的包，然后运行程序即可，注意权限问题 四、结束最后在浏览器输入 http://localhost:7788看一下运行成功了没 teamcity初尝试就到此为止了，总体用下来操作还是很简单的，界面也美观，跟jenkins比各有优劣，还有很多功能后续慢慢再试验 如果想要以先编译再上传运行的方式部署Go程序的话，可以把go环境安装好的teamcity-agent容器打包成镜像，上传到自己的仓库，方便下次使用","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://shuangdeyu.github.io/tags/Go/"},{"name":"CI/CD","slug":"CI-CD","permalink":"https://shuangdeyu.github.io/tags/CI-CD/"}]},{"title":"mysql开发规范","slug":"mysql开发规范","date":"2021-01-25T16:00:00.000Z","updated":"2023-12-21T06:48:45.914Z","comments":true,"path":"2021/01/26/mysql-kai-fa-gui-fan/","link":"","permalink":"https://shuangdeyu.github.io/2021/01/26/mysql-kai-fa-gui-fan/","excerpt":"","text":"非原创，引用自阿里的《java开发手册》中的mysql数据库规范，这里做个记录和参考。 建表规约1、 【强制】 表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否）。或者无其他表示类型、状态的情况下，也可以用 status 命名，数据类型是 enum （Y 表示是，N 表示否）。 说明：任何字段如果为非负数，必须是 unsigned 。注意： 数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取值含义与取值范围。正例：表达逻辑删除的字段名 is_deleted ，1 表示删除，0 表示未删除。 2、【强制】 表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。 说明： MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。正例： aliyun_admin ， rdc_config ，level3_name反例： AliyunAdmin ， rdcConfig ， level_3_name 3、 【强制】 表名不使用复数名词。 说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。 4、 【强制】 禁用保留字，如 desc 、 range 、 match 、 delayed 等，请参考 MySQL 官方保留字。 5、 【强制】 主键索引名为 pk_ 字段名；唯一索引名为 uk_字段名 ； 普通索引名则为 idx_字段名。 说明： pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。 6、 【强制】 小数类型为 decimal ，禁止使用 float 和 double 。 说明： float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。 7、 【强制】 如果存储的字符串长度几乎相等，使用 char 定长字符串类型。 8、 【强制】 varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text ，独立出来一张表，用主键来对应，避免影响其它字段索引效率。 9、 【强制】 表必备三字段： id , gmt_create , gmt_modified 。 说明：其中 id 必为主键，类型为 bigint unsigned 、单表时自增、步长为 1。 gmt_create,gmt_modified 的类型均为 datetime 类型，前者现在时表示主动创建，后者过去分词表示被动更新。 10、 【推荐】 表的命名最好是加上“业务名称_表的作用”，或者加上表示库名的前缀。 正例： alipay_task / force_project / trade_config / s_config 11、 【推荐】 库名与应用名称尽量一致。 12、 【推荐】 如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。 13、 【推荐】 字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循： 不是频繁修改的字段。 不是 varchar 超长字段，更不能是 text 字段。正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。 14、 【推荐】 单表行数超过 500 万行或者单表容量超过 2 GB ，才推荐进行分库分表。 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。 15、 【推荐】 合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。 正例：如下表，其中无符号值可以避免误存负数，且扩大了表示范围。 对象 年龄区间 类型 字节 表示范围 人 150岁之内 tinyint unsigned 1 无符号值：0 到 255 龟 数百岁 smallint unsigned 2 无符号值：0 到 65535 恐龙化石 数千万年 int unsigned 4 无符号值：0 到约 42.9 亿 太阳 约 50 亿年 bigint unsigned 8 无符号值：0 到约 10 的 19 次方 索引规约1、 【强制】 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的 ； 另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。 2、 【强制】 超过三个表禁止 join 。需要 join 的字段，数据类型必须绝对一致 ； 多表关联查询时，保证被关联的字段需要有索引。 说明：即使双表 join 也要注意表索引、 SQL 性能。 3、 【强制】 在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。 说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left( 列名, 索引长度 )) / count( * ) 的区分度来确定。 4、 【强制】 页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。 说明：索引文件具有 B - Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。 5、 【推荐】 如果有 order by 的场景，请注意利用索引的有序性。 order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。 正例： where a =? and b =? order by c; 索引： a_b_c反例：索引中有范围查找，那么索引有序性无法利用，如： WHERE a &gt;10 ORDER BY b; 索引a_b 无法排序。 6、 【推荐】 利用覆盖索引来进行查询操作，避免回表。 说明：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。正例：能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用 explain 的结果， extra 列会出现： using index 。 7、 【推荐】 利用延迟关联或者子查询优化超多分页场景。 说明： MySQL 并不是跳过 offset 行，而是取 offset + N 行，然后返回放弃前 offset 行，返回N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。正例：先快速定位需要获取的 id 段，然后再关联：SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id 8、 【推荐】 SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts最好。 说明： consts 单表中最多只有一个匹配行 （ 主键或者唯一索引 ） ，在优化阶段即可读取到数据。 ref 指的是使用普通的索引 （normal index） 。 range 对索引进行范围检索。反例： explain 表的结果， type = index ，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range 还低，与全表扫描是小巫见大巫。 9、 【推荐】 建组合索引的时候，区分度最高的在最左边。 正例：如果 where a =? and b =? ，如果 a 列的几乎接近于唯一值，那么只需要单建 idx_a索引即可。说明：存在非等号和等号混合时，在建索引时，请把等号条件的列前置。如： where c &gt;? and d =? 那么即使 c 的区分度更高，也必须把 d 放在索引的最前列，即索引 idx_d_c。 10、 【推荐】 防止因字段类型不同造成的隐式转换，导致索引失效。 11、 【参考】 创建索引时避免有如下极端误解： 宁滥勿缺。认为一个查询就需要建一个索引。 宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。 抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。 SQL语句1、 【强制】 不要使用 count(列名) 或 count(常量) 来替代 count(＊) ， count(＊) 是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。 说明： count(*) 会统计值为 NULL 的行，而 count( 列名 ) 不会统计此列为 NULL 值的行。 2、 【强制】 count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col 1, col 2 ) 如果其中一列全为 NULL ，那么即使另一列有不同的值，也返回为 0。 3、 【强制】 当某一列的值全是 NULL 时， count(col) 的返回结果为 0，但 sum(col) 的返回结果为NULL ，因此使用 sum() 时需注意 NPE 问题。 正例：可以使用如下方式来避免 sum 的 NPE 问题： SELECT IF(ISNULL(SUM(g)) ,0, SUM(g)) FROM table; 4、 【强制】使用 ISNULL() 来判断是否为 NULL 值。 说明： NULL 与任何值的直接比较都为 NULL。1 ） NULL&lt;&gt;NULL 的返回结果是 NULL ，而不是 false 。2 ） NULL=NULL 的返回结果是 NULL ，而不是 true 。3 ） NULL&lt;&gt;1 的返回结果是 NULL ，而不是 true 。 5、 【强制】 在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。 6、 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。 说明：以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id ，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群 ； 级联更新是强阻塞，存在数据库更新风暴的风险 ； 外键影响数据库的插入速度。 7、 【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。 8、 【强制】数据订正（特别是删除、修改记录操作）时，要先 select ，避免出现误删除，确认无误才能执行更新语句。 9、 【推荐】 in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。 10、 【参考】如果有国际化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数的区别。 说明：SELECT LENGTH( “轻松工作” )； 返回为 12SELECT CHARACTER _ LENGTH( “轻松工作” )； 返回为 4如果需要存储表情，那么选择 utf8mb 4 来进行存储，注意它与 utf-8 编码的区别。 11、 【参考】 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 trigger ，有可能造成事故，故不建议在开发代码中使用此语句。 说明： TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。 ORM 映射以下有众多名词属于java技术栈，请根据自己使用的语言对照参考 1、 【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。 说明：1 ） 增加查询分析器解析成本。2 ） 增减字段容易与 resultMap 配置不一致。3）无用字段增加网络消耗，尤其是 text 类型的字段。 2、 【强制】 POJO 类的布尔属性不能加 is ，而数据库字段必须加 is_，要求在 resultMap 中进行字段与属性之间的映射。 说明：参见定义 POJO 类以及数据库字段定义规定，在 resultMap 中 增加映射，是必须的。在 MyBatis Generator 生成的代码中，需要进行对应的修改。 3、 【强制】不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义 ； 反过来，每一个表也必然有一个 POJO 类与之对应。 说明：配置映射关系，使字段与 DO 类解耦，方便维护。 4、 【强制】sql. xml 配置参数使用：#{}，#param# 不要使用 ${} 此种方式容易出现 SQL 注入。 5、 【强制】 iBATIS 自带的 queryForList(String statementName , int start , int size) 不推荐使用。 说明：其实现方式是在数据库取到 statementName 对应的 SQL 语句的所有记录，再通过 subList 取 start , size 的子集合。正例： Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(“start”, start); map.put(“size”, size); 6、 【强制】不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。 说明： resultClass=”Hashtable” ，会置入字段名和属性值，但是值的类型不可控。 7、 【强制】更新数据表记录时，必须同时更新记录对应的 gmt _ modified 字段值为当前时间。 8、 【推荐】不要写一个大而全的数据更新接口。传入为 POJO 类，不管是不是自己的目标更新字段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL 时，不要更新无改动的字段，一是易出错 ； 二是效率低 ； 三是增加 binlog 存储。 9、 【参考】@Transactional 事务不要滥用。事务会影响数据库的 QPS ，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。 10、 【参考】&lt; isEqual &gt;中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带上此条件 ； 表示不为空且不为 null 时执行 ； 表示不为 null 值时执行。 其它1、 【强制】 数据库设计过程中需要做好注释，记录设计文档，文档类型不限，可以是excel也可以是其它，方便浏览整体的数据库结构。 2、 【强制】 数据库设计好之后由设计人员进行讲解，讲解方式不限，可以是开会，也可以是单独讲解，但必须有讲解过程让参与开发的人员熟悉。 3、 【强制】 由于多人协作开发，所以任何的数据修改都必须在指定的项目群里通知到位，有歧义的需要讨论之后才能确定修改。","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://shuangdeyu.github.io/tags/Mysql/"}]},{"title":"记录平时遇到的问题(1)","slug":"记录平时遇到的问题(1)","date":"2021-01-20T16:00:00.000Z","updated":"2023-12-21T06:59:20.599Z","comments":true,"path":"2021/01/21/ji-lu-ping-shi-yu-dao-de-wen-ti-1/","link":"","permalink":"https://shuangdeyu.github.io/2021/01/21/ji-lu-ping-shi-yu-dao-de-wen-ti-1/","excerpt":"","text":"记录一下自己平时开发过程中遇到的问题，和一些思考总结，有些问题可能是反复遇到的，有个记录下次查找起来也方便。 mysql连接数调不上去修改mysql的配置文件my.cnf，发现其中的连接数、打开文件数等多个配置怎么调都是固定的，起初以为是my.cnf未生效导致的，所以按照这个思路花了大量的时间去寻找解决方法。 最后还是没有解决问题，后来偶然的实验下，发现通过SET GLOBAL max_connections = 100000;指令设置的方式也无法改变连接数。 再往下实验，发现设置为一个小一点的数值却成功了，这时候才发觉应该是哪里有一个最大数限制了，循着这个思路去找，果然找到了真正的原因，原来是mysqld.service服务文件中有一个’LimitNOFILE‘参数限制了最大文件数。 但是 max_connections 上限为100000，目前mysql最新版本是8，其上限值也是100000。 解决方法： 查找 mysqld.service 启动文件，将文件中的参数LimitNOFILE调整为系统允许范围内的较高数值，然后通过systemctl daemon-reload更新下启动文件，再重启mysql服务即可。 总结： 查找，定位问题的时候，需要灵活反向思考，如果一个方向很久都查不出问题，那就往反方向思考一下，既然往高了调参数没什么变化，那么，试一下往低了调？ 数据库大量并发写操作会导致程序堵塞很卡实际项目中发现mysql的写性能很低，大量并发写的时候会很慢，导致程序卡死，接口响应慢等问题。 解决方法： 避免并发写，销峰处理，可以使用队列的方式，等请求完成后延后写入数据库。 已经实践并解决的方式是使用redis的list格式进行处理，将定时读取时间内的缓存队列读取出来，拼接成批量插入的sql语句，直到本次读取队列中没有数据的时候，执行插入语句，既避免了接口处理的时候执行插入操作，也避免了单条数据的插入。 redis并发写入数据丢失使用 redis 的 list 类型做消息队列，通过这个队列将要写到 mysql 的数据延后批量写入。 使用 jmeter 测并发的时候发现，10000 线程的时候，写到 redis 的数据会丢失，而且丢失数量是不规则的； 5000 线程以内则一切正常。 首先查看连接数是否配置足够高，发现redis.conf中的连接数往高了调不会生效，与mysql连接数调不上去的问题类似，果然发现redis还有个隐藏的limit.conf限制了最高连接数，参数同样是LimitNOFILE。 连接数调整后发现还是没解决问题，继续观察发现代码没有打印抛出错误信息，加上后打印错误信息是connection pool timeout，应该是连接池的问题。 解决方法： 修改redis的limit.conf中的LimitNOFILE参数，配置文件参考路径为/etc/systemd/system/redis-sentinel.service.d/limit.conf。 程序中建立连接的时候在redis.Options中配置连接池等属性即可，参考代码如下： RedisClient = redis.NewClient(&amp;redis.Options&#123; Network: \"tcp\", Addr: LoadIni(\"Redis\", \"redis_host\"), Password: LoadIni(\"Redis\", \"redis_password\"), DB: comhelper.StringToInt(LoadIni(\"Redis\", \"redis_database\")), DialTimeout: time.Duration(comhelper.StringToInt(LoadIni(\"Redis\", \"redis_timeout\"))) * time.Second, PoolSize: 10, PoolTimeout: 2 * time.Minute, IdleTimeout: 10 * time.Minute, ReadTimeout: 2 * time.Minute, WriteTimeout: 1 * time.Minute, &#125;) 总结： 写测试程序的时候也要严谨，抛出错误信息，观察测试结果要深入，发现测试结果的规律。 后端的灵活配置后端需要做一些灵活配置的工作，来应对随时可能变动的需求 比如，将一些触发事件配置到数据库中，初始化的时候读取这些配置的事件，打入到代码中运行，然后做一个管理界面来管理这些事件的配置，一旦有增删改之后，重置程序中运行的事件信息即可，做到了灵活管控。 其它还有一些会变动的信息，比如帮助，协议等内容，也做到数据库中进行管控，这样需要改变的时候只要修改数据库中的数据就行了，不需要app上修改然后再次发布版本。 TCP长连接采坑问题描述：物联网设备与后端建立tcp长连接进行通信，车辆定时会上报车辆状态指令到服务器。 但这不是心跳，所以服务器没有回应车辆，一段时间之后（测下来是1小时多点），发现车辆中途自身ip会变，所以导致通信连接资源还是旧的，服务器发到车辆的数据实际上是发不出去的。 tcp_keepalive_time tcp长连接的时候除了代码层面需要有心跳监测机制外，服务器(linux)内核也有个参数会对长连接进行监测，这个参数是net.ipv4.tcp_keepalive_time。 它指示TCP发送keepalive探测消息的间隔时间（秒），用于确认TCP连接是否有效，防止两边建立连接但不发送数据的攻击。超过这个值设定的时间未向服务器端发送数据，将会被‘切断’。 所以服务器内核keepalive相关参数需要配置合理。 运营商问题 车辆的连接ip是网络运营商提供的，国内运营商的超时时间一般是5分钟，超过时间未进行通信连接就会断开，这个因素也排除了，因为可以设置车辆小于5分钟上报指令。 但不排除运营商中途切换连接ip的行为，所以可能是运营商中途强制切了ip 设备问题 设备定时上报的时间间隔太长，导致连接被运营商或服务器断开，这个问题上面也描述过，可以修改定时上报的间隔； 看门狗问题，看门狗会导致设备重启重连等操作，这个也可以通过指令设置，可以排除掉。 服务器问题 服务器正常情况下不会主动踢掉连接，测试的时候本地开了四个客户端保持长连接，长时间之后没有发生断线的情况，而且收发正常。 所以考虑大概率是运营商强制切换了ip或者设备中控的问题（这些测试都是在心跳包没有开启的情况，即设备定时上报服务端没有回应应答）。 服务端优化：因为客户端中途换了ip，但是服务端检测到断线是在换ip之后的，所以没有执行掉线这个逻辑来清空连接的socket资源和重新建立连接资源。 所以在客户端换了ip之后服务端下发指令不成功，需要检测到掉线然后等到客户端下一条指令上报才能建立新的连接资源；优化根据客户端的ip判断服务端存储的资源是否匹配，不匹配的更新资源。 TCP 连接出现大量的 connection timed out 错误前提条件：服务器可打开文件数，最大连接数已经调到百万级别了，发起的tcp连接数是20000，为什么还会出现这么多连接超时呢？ 什么是connect timeout ? 也就是client 发出 syn 包，server端在你指定的时间内没有回复ack，一直连不上就导致连接超时了。server 端为什么没有回复ack。 因为syn包的回复是内核层的，要么网络层丢包，要么就是内核层back_log的queue(队列)满了。 然后查看TCP的内核参数 tcp_max_syn_backlog cat /proc/sys/net/ipv4/tcp_max_syn_backlog 发现只有128，这个参数的作用是设置对于还未获得对方确认的连接请求，可保存在队列中的最大数目，也就是连接等待队列的长度，数值越大，可容纳的连接数越多。 同时控制等待连接数的参数还有一个 somaxconn，光设置一个是不行的，这个参数定义了系统中每一个端口最大的监听队列的长度。 同时设置好以上两个参数的适当值后，就没出现连接超时了。 慎用Golang的锁操作在测试物联网设备TCP服务器高并发的时候遇到接口访问特别慢的问题，通过打时间点定位到了两个主要的问题 一 是大量的数据库操作随着并发增大拖垮了整体性能 二 发现有大量的时间卡在UserConnInfo.Lock.Lock()这条语句上，这是一个互斥锁的操作 所谓互斥锁，就是加锁之后，这个资源其它人就不能操作了，在大并发下，很容易在这里卡住时间 后来优化使用了读写锁，因为我们的TCP连接资源是读多写少的情况，写只是在客户端连接和离线的时候才会进行操作，而读却是每条指令上报上来都会进行操作的 所以这种情况更适合使用读写锁，读锁的时候并不会阻塞其它进程协程对同一个资源的读取，所以不会发生上面这种卡在Lock的情况。 其它需要注意的是： 1、锁操作用好后一定要释放 2、减少锁的持有时间，一般释放锁我们喜欢用defer来释放，但在return之前我们可能有很多不需要锁的操作，造成了时间上的浪费，看下面这个例子就清楚了 func doSomething() &#123; m.Lock() defer m.Unlock() item := ... http.Get() // 各种耗时的 IO 操作 &#125; // 改为 func doSomething() &#123; m.Lock() item := ... m.Unlock() http.Get() &#125; 善用解耦手段，保证主业务流程畅通还是以物联网设备TCP项目为例，高并发下写和更新数据库发生阻塞，这中间有竞争资源的锁操作，因为数据库的阻塞而造成程序中锁等待时间过长。 这时候客户调用api响应时间达到十秒这么长，造成了灾难性的体验。 所以需要考虑在调用设备控制api的这段过程中，能不能将数据库的相关业务解耦开，因为客户的主要体验是调用api，达到控制设备的目的，很多数据库操作是不需要实时的。 所以在数据库操作和设备指令的收发时的锁处理做了一个解耦操作，通过MQ队列到事件服务中处理数据库业务的操作。 在不考虑数据库的性能上，api可以非常快速的响应给客户，实现tcp通信的无阻塞，极大改善api的体验。 但数据库的阻塞会造成其它服务响应出现问题，也无法做到全部解耦，所以根源上解决还是需要处理大并发下的数据库优化问题 Rabbitmq使用注意事项Rabbitmq（以下简称mq）具有高并发的特性（天生具备高并发高可用的erlang语言编写），除此之外，还可以持久化，保证消息不易丢失，高可用，实现集群部署，提供灵活的路由和可靠性，可视化管理等等的优点，所以用它来做消息队列的处理具有足够可靠性。 在使用mq做消息延时功能的时候发现死信消息到期后无法转移的问题。 先解释下什么是死信消息，mq本身是不具备延时功能的，我们还可以通过ttl（设置超时时间）+ DLX（一个死信队列）+ Router（转发队列）的方式来实现延时功能。ttl可以设置在消息上，也可以设置在队列上。 那死信其实也就是一个普通的消息队列而已，它没有消费者，用来存储有超时时间的消息，并设置过期时间路由到哪一个队列，当消息到期后就会自动转移到转移队列中，转移队列有消费者进行消费，就实现了一个延时队列的功能。 上面说到ttl（过期时间）可以设置在消息上，也可以设置在队列上，无法转移的原因是过期时间设置在消息上了，但是每个消息的过期时间是不一致的，有可能过期时间长的消息先进入到队列里，队列是先进先出的，那么正常情况下所有的消息必须得等到头消息到期后，后续的过期消息才会自动转移到其它队列中。 优化方法： 以过期时间为节点在队列上设置过期时间，比如有三条消息时间都为20秒，那么创建一个队列‘queue—20’，在队列上设置消息的过期时间为20秒。 并将消息推到‘queue—20’这个队列上，那么当不同时间的消息很多的话，创建的队列也会很多，所以这些队列都算临时队列，需要删除机制。 但是不能通过“auto_delete”这个属性来设置，因为死信队列是没有消费者的，“auto_delete”需要消费者解除绑定才会生效，只能通过队列的“x-expires”参数来设置。 但这个参数的数值要比过期时间长，不然最后一条消息会因为队列的删除而不会转移到转移队列中。","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"经验","slug":"经验","permalink":"https://shuangdeyu.github.io/tags/%E7%BB%8F%E9%AA%8C/"}]},{"title":"2020回顾","slug":"2020回顾","date":"2021-01-12T16:00:00.000Z","updated":"2023-12-21T07:27:05.852Z","comments":true,"path":"2021/01/13/2020-hui-gu/","link":"","permalink":"https://shuangdeyu.github.io/2021/01/13/2020-hui-gu/","excerpt":"","text":"又到了一年的结尾，最近几年除了应付公司的年终总结，没有自发地好好做过总结了，以致于一年一年就这样不明不白得过去了，回顾起来…都不知道能回顾啥，往往觉着这几年就像一片空白的历史，不可知，不可追溯，这是很可怕的一件事情，人生短短几十年，这些蒸发的年月日就像是我削减的寿命，不求事事俱细，但总得留下和记得些什么，总结和记录也不是非得年终来做。 2020是极其特殊的一年，不管是对我个人来说还是对全世界来说，疫情当头，生活多少都受到了点影响，好在国内都顺利过来了，虽然现在也挺严峻，现在回想起来也挺不真实的，这一年见证了多少个足以载入史册的重大事件，新冠疫情席卷全球、股市多次熔断、美国各种暴乱、英国完成脱欧、民典法颁布……总的来说，2020年对全世界来说并不好过，值得纪念吗？很值得，但并不愉快。 对我而言，这一年同样极其特殊，实现了我人生中的几大突破，当然也有迷茫过、不愉快过、怀疑过、放弃过等等负面情绪，我觉得我这一年可以用一个词来总结，那就是“幸福”。 家庭 我想在往后的生活中，家庭会排在我心目中的第一位。 1月领证，合法同居，男女朋友升级为夫妻，当天也是惊心动魄，先是跑错了地方，再是户口本太旧需要换新，前后耽搁了许多时间，做完体检再跑去办事大厅已经是踩着他们下班的点了，好在复印店的小哥和民政工作人员善良，为我们加班办理，终于在这个相识7周年之日结为夫妻了，从此我算是有了真正意义上属于自己的家庭。 然后是国庆举办了我们的婚礼，不得不说办婚礼真是个费钱又费力的事情，更何况我还是两边各办一次，难怪之前参加同学朋友的婚礼的时候，他们都说累，这次算是切身体会到了，办完婚礼，这个婚也就圆满了，我的身份完成了一次突破和升级，从此我身上多了一个丈夫的标签。 万万没想到，我的身份即将再次迎来重大突破。 10月中旬发现老婆怀孕了，而且已经一个半月了，后知后觉的我们既惊喜又后怕，惊喜的是一个生命突然的降临，生活持续不断得有盼头，有期待，后怕的是这一个半月内她经历了两次婚礼的劳累，还有一次时长半天的爬山运动，明明已经有先兆流产的迹象了，我们还以为是太过劳累所致，怀孕的前三个月是最容易流产的，经过这一番折腾，这小东西还能如此顽强地成长，真想给他取名叫“坚强”。 有了孩子(虽然还没出生)之后，我自身发生了很多变化，首先是随之而来的压力，让我真正认识到我在这个家庭中需要担当的责任 —— 一切为了家人的幸福，有时候成长的确是一瞬间的事情，毕竟结完婚之后我还是没有那么强烈的紧迫感，整体还是很懒散的状态，现在不一样了，孩子还没出生，未来的很多事情都得开始思考和准备了。 其次是对待父母的心态发生了改变，说实话我跟父母的关系不是很亲密，马上就要成为父亲这个角色了，现在跟他们的很多交流会有意识地站在父亲的角度来思考，这也算是一种和解吧。 工作 这一年，工作上面有突破，而且是挺重要的突破，虽然这个突破不是很大。 但我觉得我今年的工作仍旧是“失败”的，因为对于工作的总结，总是不足大于收获，好坏都记个账吧。 收获 今年应该是我职业生涯以来最有突破性的一年，从纯开发转型到了技术管理（后端），当然开发在日常工作中占比仍旧很重。 很多之前理论性的知识在这一年中也得到了足够的实践： 搭建了自动化部署系统，极大节省了人力、 搭建成熟的内部测试环境，方便开发人员的同时，避免出现环境不一致引起的无意义bug 进行了微服务的实践并且已经实现，成功搭建基于Go的一套微服务开发模式 向团队输出我觉得很有帮助的一些技术、理念和方法，比如自动部署的重要性、代码版本管理方式、大中台小前台的理念（没明确提出，但是一直在实践，比如微服务）、灵活配置的重要性等 。。。。。。 在以上这些实践过程中，我自身的技术肯定是得到了一定的沉淀和积累，以前我只是这些技术中的一个纯使用者，现在，自信点，我能说我是一个初级架构者。 最宝贵的是，作为一个技术管理，我几乎参与了所有项目立项开始以来的讨论和整体的后端设计，任务分发等工作，这是很难得的经验，因为很多公司，大部分开发人员都只是执行者，没有很全面地参与到整个项目的流程中来，一般都是开发老大或者组长设计好相关架构后，再分配任务给相应的开发人员，那么开发人员实现的过程中由于没有了解项目整个的细节，往往会出现很多逻辑性的错误。 以上就是这一年的收获了吧，我觉得不多，更多的是自身个人技术的一个小突破，至于带给公司的帮助，应该说没有达到公司目前发展速度下近未来规划应有的技术支持。 不足 说实话，诚惶诚恐。 我觉得我还没有准备好做一个管理者，特别是技术管理者，因为我自身的技术还是比较浅薄的，远没有达到作为一个技术老大该有的储备，所以我常常在自我怀疑，我能够胜任这个职位吗？我能够把握住这个机会吗？我能够带好我的团队吗？ 再加上我自身的性格和交流缺陷，就更让我深陷这种迷茫和怀疑，也让我对以后要走的路捉摸不定。 一方面想全身心的投入到技术提升上，毕竟过硬的技术是一切技术人员的基石，没有足够的技术储备，不管是提升技术研发的高度还是转型做技术管理，都会显得捉襟见肘。 另一方面又想抓住机会做管理，毕竟有了家庭，年龄也上来了，全身心研究技术的话肯定不像以前那样有那么多的时间和精力了，技术的瓶颈可能管理的瓶颈刻度更低，来得更快。 所以目前我仍旧处于一个非常尴尬的境地，做管理的同时也做了过多的研发工作，捉襟见肘之下导致两个都没有做的很好，我想不管是继续深入技术研发还是转型做技术管理，这是我目前急待解决的问题，有限的精力之下天平必定只能侧重一边。 生活和学习 今年的生活是美满的，干成了两件大事，买房和结婚，虽然日常偶尔也会有点烦恼和争吵，但大部分时候都是和谐的，和家里也没发生大的矛盾，总之，就是未来可期。 理财是我继家庭和工作之后计划投入的最重要的事情，今年可支配的资金一直很少，所以理财财报没有什么值得说道的地方，也没有继续深入地学习，但我觉得理财是可以做一辈子的事情，也是可以应对未来很多危机的方式，前提是学好理财，至少让自己在忙碌的工作之外还能有一份其它收入，多少暂且不论。 关于学习，今年算是毕业以来最糟糕的一年，没有完整地看完一本书，没有完整地看完一部学习视频，没有学习其它新东西，反而深陷游戏，虽然游戏之外写过游戏文章，做过游戏摄影，还想着做游戏视频，但基于本人比较浮躁，看不到短期的成果后逐渐放弃了。 计划 明年就要当爸爸了，留给我的空余时间应该不会很多，这里就少立几个flag好了。 看完至少五本书，小说不算 理财收益较今年翻一番，多研究，少操作 技术上实现至少一到两个大突破，方向还没想好 如果是个女儿，重新捡起摄影的爱好，给她拍美美的照片","categories":[{"name":"闲谈","slug":"闲谈","permalink":"https://shuangdeyu.github.io/categories/%E9%97%B2%E8%B0%88/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://shuangdeyu.github.io/tags/%E7%94%9F%E6%B4%BB/"},{"name":"总结","slug":"总结","permalink":"https://shuangdeyu.github.io/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"塞尔达传说.英杰之诗","slug":"塞尔达传说.英杰之诗","date":"2020-04-17T16:00:00.000Z","updated":"2023-12-22T07:12:02.956Z","comments":true,"path":"2020/04/18/sai-er-da-chuan-shuo.ying-jie-zhi-shi/","link":"","permalink":"https://shuangdeyu.github.io/2020/04/18/sai-er-da-chuan-shuo.ying-jie-zhi-shi/","excerpt":"","text":"米法 —— 最柔之水乌尔波扎 —— 最强之刀达尔克尔 —— 最坚之盾力巴尔 —— 最疾之箭 敬四英杰","categories":[{"name":"游戏","slug":"游戏","permalink":"https://shuangdeyu.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"Nintendo","slug":"Nintendo","permalink":"https://shuangdeyu.github.io/tags/Nintendo/"}]},{"title":"centos7 安装golang环境","slug":"centos7 安装golang环境","date":"2020-04-02T16:00:00.000Z","updated":"2023-12-20T08:34:12.413Z","comments":true,"path":"2020/04/03/centos7-an-zhuang-golang-huan-jing/","link":"","permalink":"https://shuangdeyu.github.io/2020/04/03/centos7-an-zhuang-golang-huan-jing/","excerpt":"","text":"由于经常需要在各个服务器上安装golang的环境，每次安装的时候都要在网上找教程，还会遇到一些问题，所以还是自己记录一下，防止浪费时间在寻找完整教程上，当然最好是特意加强记忆，下次就不用看教程了。 安装方法一、yum安装 这种方法简单方便，而且安装的go版本也是最新版本，所以不必担心自动安装版本过低的问题。 # yum install golang 但是安装过程中可能会出现 没有可用软件包 golang 的情况，这是因为缺少 EPEL源 ，所以软件仓库中找不到安装的软件包，只要先安装一下erel源即可。 # yum install epel-release 安装完成后查看go版本号，成功显示就表示安装成功。 # go version go version go1.13 linux&#x2F;amd64 方法二、二进制包安装 安装包在官网可以下载。 由于之前安装了go1.13，所以我下载的是go1.12的包，以进行区分。 # wget -P &#x2F;var&#x2F;download https:&#x2F;&#x2F;dl.google.com&#x2F;go&#x2F;go1.12.10.linux-amd64.tar.gz 然后解压到 /usr/lib 目录，这里跟之前安装的版本所在目录相同，但是需要将之前安装的go文件夹名称改成’golang-1.13’，以免产生冲突。 # tar -zxf &#x2F;var&#x2F;download&#x2F;go1.12.10.linux-amd64.tar.gz -C &#x2F;usr&#x2F;lib&#x2F; 然后将解压的go文件夹名改成’golang’，进行一个简单的版本切换，再执行查看版本号的指令，发现变成了1.12版本。 # go version go version go1.12.10 linux&#x2F;amd64 配置环境变量通过编辑 /etc/profile 文件配置环境变量。 # vim &#x2F;etc&#x2F;profile 在文件的末尾添加如下代码： export GOROOT&#x3D;&#x2F;usr&#x2F;lib&#x2F;golang export GOPATH&#x3D;&#x2F;var&#x2F;goproject export PATH&#x3D;$PATH:$GOROOT&#x2F;bin # source &#x2F;etc&#x2F;profile 其中工作路径为 ‘/var/goproject’ ，即我们编写的代码放到这个目录下面运行。 这样golang的环境就搭建好了，可以通过以下指令查看环境参数。 # go env","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://shuangdeyu.github.io/tags/Go/"}]},{"title":"jenkins自动部署范例","slug":"jenkins自动部署范例","date":"2020-04-02T16:00:00.000Z","updated":"2023-12-20T08:34:12.444Z","comments":true,"path":"2020/04/03/jenkins-zi-dong-bu-shu-fan-li/","link":"","permalink":"https://shuangdeyu.github.io/2020/04/03/jenkins-zi-dong-bu-shu-fan-li/","excerpt":"","text":"自动化部署的必要性：纯手工部署项目势必会造成重复工作，工序繁多，容易出错等问题，这时候就需要用到自动化部署了，虽然前期做的准备工作也挺多的，但是后面只需要一键提交即可自动完成编译、打包、部署等一系列流程，省去了大量重复工作，节省大量时间，还不容易出错。 架构简介 公司内部搭建git代码管理平台(这里是gitea)，写好的代码提交到gitea。 Jenkins可实现自动化部署，配置好jenkins和gitea的hook，并且配置好对应项目在jenkins中的部署工作，代码提交的时候，gitea触发hook，然后jenkins开始根据项目此前配置好的方式工作，自动将代码编译打包上传到对应服务器，并在服务器上解压包，运行执行文件。 目前该项目是由Go语言编写，以Go项目为示范，配置好的jenkins会将Go项目编译，并打包相关运行文件成一个包，然后jenkins将这个包上传到服务器解压，并运行启动文件，这个服务就能自动开始运行了。 配置jenkins构建Go工程首先在同一台服务器安装好jenkins以及Go的运行环境。 jenkins上安装Go Plugin插件，然后配置Go的安装目录，这样jenkins就能编译Go工程了，当然这只能指定GOROOT的路径，我们在执行构建时还要指定GOPATH的路径，这个下面会说到。 创建jenkins工程首先创建一个工程，并选择自由风格的类型。 关联giteagitea通过webhook钩子将提交事件推送到jenkins，这里也需要进行一下简单的配置。 jenkins安装一下Gogs Plugin这个插件即可，具体的插件配置后面在对应的项目里面会讲到，主要介绍下gitea的webhook配置。 主要说明下webhook的URL，其中 192.168.1.146:8080 是jenkins的访问地址，job=scooter_api 中的 scooter_api 是刚才jenkins中创建的工程的名字，其它默认即可，其实也很好理解，即指向 jenkins 的 scooter_api 工程。 配置jenkins工程jenkins工程有General、Gogs Webhook、源码管理、构建触发器、构建环境、构建、构建后操作等配置项，但不需要每个都配置，根据工程需求来，不需要配置的项下面就不进行说明了。 General 填写工程描述，主要是设定保持构建的最大个数和天数，方便追踪旧版本的构建，回溯版本。 Gogs Webhook 这里保持默认，不需要额外配置 源码管理 这里也简单，填写一下项目的git地址，配置git账号密码，指定需要构建的分支。 构建环境 选择之前Go Plugin配置的版本。 构建 这个模块可以说是jenkins工程配置的核心模块，项目的构建、编译、打包、部署均在这个模块中配置，下面就一一说明。 Execute shell 这里主要做的是构建代码编译环境，并且编译这个Go工程，完整指令如下： export GOPATH&#x3D;&#x2F;opt&#x2F;go export PATH&#x3D;$PATH:$GOPATH echo &quot;GOPATH: $&#123;GOPATH&#125;&quot; sudo rm -fr &#x2F;opt&#x2F;go&#x2F;src&#x2F;scooter_api&#x2F;conf sudo rm -fr &#x2F;opt&#x2F;go&#x2F;src&#x2F;scooter_api&#x2F;controller sudo rm -fr &#x2F;opt&#x2F;go&#x2F;src&#x2F;scooter_api&#x2F;model sudo rm -fr &#x2F;opt&#x2F;go&#x2F;src&#x2F;scooter_api&#x2F;router sudo rm -fr &#x2F;opt&#x2F;go&#x2F;src&#x2F;scooter_api&#x2F;server sudo rm -fr &#x2F;opt&#x2F;go&#x2F;src&#x2F;scooter_api&#x2F;service sudo mkdir -p &#x2F;opt&#x2F;go&#x2F;src&#x2F;scooter_api sudo ln -s $&#123;WORKSPACE&#125;&#x2F;conf &#x2F;opt&#x2F;go&#x2F;src&#x2F;scooter_api&#x2F;conf sudo ln -s $&#123;WORKSPACE&#125;&#x2F;controller &#x2F;opt&#x2F;go&#x2F;src&#x2F;scooter_api&#x2F;controller sudo ln -s $&#123;WORKSPACE&#125;&#x2F;model &#x2F;opt&#x2F;go&#x2F;src&#x2F;scooter_api&#x2F;model sudo ln -s $&#123;WORKSPACE&#125;&#x2F;router &#x2F;opt&#x2F;go&#x2F;src&#x2F;scooter_api&#x2F;router sudo ln -s $&#123;WORKSPACE&#125;&#x2F;server &#x2F;opt&#x2F;go&#x2F;src&#x2F;scooter_api&#x2F;server sudo ln -s $&#123;WORKSPACE&#125;&#x2F;service &#x2F;opt&#x2F;go&#x2F;src&#x2F;scooter_api&#x2F;service go build -a -o sc_api main.go sudo rm -fr &#x2F;opt&#x2F;go&#x2F;src&#x2F;scooter_api&#x2F;conf sudo rm -fr &#x2F;opt&#x2F;go&#x2F;src&#x2F;scooter_api&#x2F;controller sudo rm -fr &#x2F;opt&#x2F;go&#x2F;src&#x2F;scooter_api&#x2F;model sudo rm -fr &#x2F;opt&#x2F;go&#x2F;src&#x2F;scooter_api&#x2F;router sudo rm -fr &#x2F;opt&#x2F;go&#x2F;src&#x2F;scooter_api&#x2F;server sudo rm -fr &#x2F;opt&#x2F;go&#x2F;src&#x2F;scooter_api&#x2F;service 以上指令的说明，以段落空格为一个模块进行说明，请注意区分。 上面说过，Go Plugin插件只配置了GOROOT这项，然而Go的运行环境还需要GOPATH，就是在这里指定其路径的，这里是’/opt/go’。 删除工程中之前已经构建过留下的文件(有的话)，然后创建工程路径，这里是’/opt/go/src/scooter_api’。 jenkins默认会将git提交的代码转移到它的工作路径’WORKSPACE’中，我们需要将他们转移到GOPATH工程目录中，不然无法编译工程。 编译工程 编译好之后删除文件，减少磁盘占用容量，并且打包的时候这些无用的文件就不会打包进去了。 Invoke Phing targets Phing插件的配置，需要下载Phing Plugin插件，而且服务器需要安装好’php phing’等php环境，用于将工程打包。 注意，Phing 打包需要在工程中创建脚本文件’build.xml’，这个脚本文件是在代码中一起提交上去的，代码如下所示，这是一个标准模板，只需替换下工程名即可，这里是’sc_api’，打包好之后的包名就是’sc_api.tar.gz’。 &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt; &lt;project name&#x3D;&quot;sc_api&quot; default&#x3D;&quot;build&quot;&gt; &lt;target name&#x3D;&quot;build&quot; depends&#x3D;&quot;make_runtime&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;version-m&quot; value&#x3D;&quot;1.1&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;version&quot; value&#x3D;&quot;1.1.0&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;stability&quot; value&#x3D;&quot;stable&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;releasenotes&quot; value&#x3D;&quot;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;tarfile&quot; value&#x3D;&quot;$&#123;phing.project.name&#125;.$&#123;buildnumber&#125;.$&#123;buildid&#125;.tar.gz&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;pkgfile&quot; value&#x3D;&quot;$&#123;phing.project.name&#125;.$&#123;version&#125;.tgz&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;distfile&quot; value&#x3D;&quot;dist&#x2F;$&#123;tarfile&#125;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;tests.dir&quot; value&#x3D;&quot;test&quot;&#x2F;&gt; &lt;fileset id&#x3D;&quot;sc_api.tar.gz&quot; dir&#x3D;&quot;.&quot;&gt; &lt;include name&#x3D;&quot;sc_api&quot;&#x2F;&gt; &lt;include name&#x3D;&quot;start.sh&quot;&#x2F;&gt; &lt;&#x2F;fileset&gt; &lt;target name&#x3D;&quot;make_runtime&quot;&gt; &lt;mkdir dir&#x3D;&quot;$&#123;project.basedir&#125;&#x2F;Runtime&quot;&#x2F;&gt; &lt;mkdir dir&#x3D;&quot;$&#123;project.basedir&#125;&#x2F;build&#x2F;logs&quot;&#x2F;&gt; &lt;mkdir dir&#x3D;&quot;$&#123;project.basedir&#125;&#x2F;build&#x2F;pdepend&quot;&#x2F;&gt; &lt;mkdir dir&#x3D;&quot;$&#123;project.basedir&#125;&#x2F;build&#x2F;code-browser&quot;&#x2F;&gt; &lt;&#x2F;target&gt; &lt;target name&#x3D;&quot;check&quot; description&#x3D;&quot;Check variables&quot;&gt; &lt;fail unless&#x3D;&quot;version&quot; message&#x3D;&quot;Version not defined!&quot;&#x2F;&gt; &lt;fail unless&#x3D;&quot;buildnumber&quot; message&#x3D;&quot;buildnumber not defined!&quot;&#x2F;&gt; &lt;fail unless&#x3D;&quot;buildid&quot; message&#x3D;&quot;buildid not defined!&quot;&#x2F;&gt; &lt;delete dir&#x3D;&quot;dist&quot; failonerror&#x3D;&quot;false&quot;&#x2F;&gt; &lt;mkdir dir&#x3D;&quot;dist&quot;&#x2F;&gt; &lt;&#x2F;target&gt; &lt;target name&#x3D;&quot;tar&quot; depends&#x3D;&quot;check&quot; description&#x3D;&quot;Create tar file for release&quot;&gt; &lt;echo msg&#x3D;&quot;Creating distribution tar for $&#123;phing.project.name&#125; $&#123;version&#125;&quot;&#x2F;&gt; &lt;delete file&#x3D;&quot;$&#123;distfile&#125;&quot; failonerror&#x3D;&quot;false&quot;&#x2F;&gt; &lt;tar destfile&#x3D;&quot;$&#123;distfile&#125;&quot; compression&#x3D;&quot;gzip&quot;&gt; &lt;fileset refid&#x3D;&quot;sc_api.tar.gz&quot;&#x2F;&gt; &lt;&#x2F;tar&gt; &lt;&#x2F;target&gt; &lt;&#x2F;project&gt; Send files or execute commands over SSH 这步就是将打包好的包通过ssh服务上传到其它服务器上,然后解压并启动编译文件，即启动程序，提供服务。 Source files：打包好之后的文件的位置 Remove prefix：去除路径前缀，只取tar.gz的包 Remote directory：远程目录，将包传送到远程服务器的目录 Exec command：在远程服务器执行的指令 sudo mkdir &#x2F;opt&#x2F;bin&#x2F;sc_api sudo cp &#x2F;tmp&#x2F;dist&#x2F;sc_api.$&#123;BUILD_NUMBER&#125;.$&#123;BUILD_ID&#125;.tar.gz &#x2F;opt&#x2F;bin&#x2F;sc_api&#x2F;sc_api.tar.gz cd &#x2F;opt&#x2F;bin&#x2F;sc_api sudo tar -zxvf sc_api.tar.gz sudo rm -rf &#x2F;tmp&#x2F;dist&#x2F;sc_api.$&#123;BUILD_NUMBER&#125;.$&#123;BUILD_ID&#125;.tar.gz sudo chmod +x &#x2F;opt&#x2F;bin&#x2F;sc_api&#x2F;sc_api sudo chmod +x &#x2F;opt&#x2F;bin&#x2F;sc_api&#x2F;start.sh sudo &#x2F;opt&#x2F;bin&#x2F;sc_api&#x2F;start.sh echo &quot;OK&quot; 同样以段落空格为模块进行说明： 在远程服务器中创建工程文件夹，并将包转移到工程文件夹中 进入工程文件夹，解压包 执行启动文件，程序就开始跑了，其中’start.sh’启动文件也是提前写在代码工程中随git一起提交上去的 注意：工程自动部署到这里算是完成了，这里说明一下，远程服务器的工程文件夹可以提前创建，放入一些程序配置文件，配置文件最好手动部署，因为不同环境下配置内容是不一样的 构建后操作 构建后将打包的文件存档。","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://shuangdeyu.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"vm虚拟机安装centos","slug":"vm虚拟机安装centos","date":"2020-04-02T16:00:00.000Z","updated":"2023-12-22T07:13:44.571Z","comments":true,"path":"2020/04/03/vm-xu-ni-ji-an-zhuang-centos/","link":"","permalink":"https://shuangdeyu.github.io/2020/04/03/vm-xu-ni-ji-an-zhuang-centos/","excerpt":"","text":"记录虚拟机安装centos步骤 按图片顺序操作1、创建虚拟机，选择稍后安装操作系统 2、选择linux系统，版本centos 7 64位 3、命名虚拟机，选择位置 4、确定磁盘大小，选择拆分成多个文件 5、自定义硬件配置，主要配置红框内参数 6、播放虚拟机，安装centos系统，配置设置项 7、配置网络，配合路由器固定静态ip 8、手动配置分区 swap：建议是内存的两倍，swap格式，LVM类型 /boot：引导分区，建议1G，ext4格式，标准分区类型 /：根分区，建议大点，ext4格式，LVM类型 /home：用户数据区，稍大，ext4格式，LVM类型 9、点击开始安装，并设置用户密码，等待安装完成即可","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://shuangdeyu.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"常用linux指令整理","slug":"常用linux指令整理","date":"2020-04-02T16:00:00.000Z","updated":"2023-12-22T07:17:39.808Z","comments":true,"path":"2020/04/03/chang-yong-linux-zhi-ling-zheng-li/","link":"","permalink":"https://shuangdeyu.github.io/2020/04/03/chang-yong-linux-zhi-ling-zheng-li/","excerpt":"","text":"常用linux指令记录 系统相关： 查看系统版本： cat &#x2F;proc&#x2F;version 查看CPU信息 cat &#x2F;proc&#x2F;cpuinfo 查看socket连接数 cat &#x2F;proc&#x2F;net&#x2F;sockstat 查看当前tcp连接情况 netstat -n 查看磁盘空间占用情况 df -l 修改网卡信息 cd &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F; ls 上面的指令列出所有网卡，然后编辑网卡信息即可 vim ifcfg-eno1 显示当前用户进程限制数，如最大打开文件数： ulimit -a 临时修改最大文件句柄数： ulimit -n 2048 永久修改方法： 在&#x2F;etc&#x2F;security&#x2F;limits.conf中添加配置 * soft nofile 2048 * hard nofile 2048 或者 * - nofile 2048 查询TCP相关内核参数： sysctl -a|grep ipv4|grep -i --color tcp 进程/服务相关 查看所有进程 ps -ef 指定进程/服务名查询 ps -ef | grep python 根据进程名查看进程信息 ps aux | grep sc_app_api 查看进程占用的句柄数 lsof -n|awk &#39;&#123;print $2&#125;&#39;|sort|uniq -c|sort -nr|more 重载所有修改过的配置文件 systemctl daemon-reload 设置服务开机启动 systemctl enable redis 查看服务状态 systemctl status redis 服务启动、停止、重启 systemctl start redis systemctl stop redis systemctl restart redis 端口相关 查看端口占用 netstat -anp|grep 80 列出所有端口情况 netstat -ntlp 权限相关 更改文件权限： 用法：chmod [-cfvR] [--help] [--version] [权限值] [文件或文件夹] 参数选项说明： - -c : 若该文件权限确实已经更改，才显示其更改动作 - -f : 若该文件权限无法被更改也不要显示错误讯息 - -v : 显示权限变更的详细资料 - -R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更) - --help : 显示辅助说明 - --version : 显示版本 权限值说明： 比如：chmod -R abc file 其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。 r&#x3D;4，w&#x3D;2，x&#x3D;1 分别表示读、写、执行 若要rwx属性则4+2+1&#x3D;7； 若要rw-属性则4+2&#x3D;6； 若要r-x属性则4+1&#x3D;5。 防火墙相关 CentOS7彻底关闭防火墙： sudo systemctl status firewalld.service &#x2F;&#x2F; 查看防火墙状态 sudo systemctl stop firewalld.service &#x2F;&#x2F; 停止防火墙服务 sudo systemctl disable firewalld.service &#x2F;&#x2F; 禁止防火墙开机启动 查看防火墙端口 firewall-cmd --list-ports 防火墙开启端口 firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanent 重启防火墙 firewall-cmd --reload 文件操作相关 实时查看最后 n 条日志的情况 tail -f -n 200 app.log 查看文件内容 cat sc_app_api-2020-03-03.log cat - 由第一行开始显示档案内容 tac - 从最后一行开始显示，可以看出 tac 是 cat 的反向显示 解压压缩包 tar -zxvf sc_app_api.tar.gz -c ：新建打包文件 -t ：查看打包文件的内容含有哪些文件名 -x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中 -j ：通过bzip2的支持进行压缩&#x2F;解压缩 -z ：通过gzip的支持进行压缩&#x2F;解压缩 -v ：在压缩&#x2F;解压缩过程中，将正在处理的文件名显示出来 -f filename ：filename为要处理的文件 -C dir ：指定压缩&#x2F;解压缩的目录dir 压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称 查询：tar -jtv -f filename.tar.bz2 解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录 查找文件 find &#x2F; -name redis whereis redis 其它 查看etcd健康状态 etcdctl cluster-health etcdctl ls","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://shuangdeyu.github.io/tags/linux/"}]},{"title":"通用软件项目结构分享","slug":"通用软件项目结构分享","date":"2019-05-30T16:00:00.000Z","updated":"2023-12-22T07:18:33.524Z","comments":true,"path":"2019/05/31/tong-yong-ruan-jian-xiang-mu-jie-gou-fen-xiang/","link":"","permalink":"https://shuangdeyu.github.io/2019/05/31/tong-yong-ruan-jian-xiang-mu-jie-gou-fen-xiang/","excerpt":"","text":"还记得刚开始写程序的时候，那时候用的是PHP，没有使用任何框架，所有文件几乎堆在一两个文件夹中，杂乱不堪，一旦项目变大，光找找对应的文件都得花费一大堆时间，严重影响效率，而且可扩展性为零，更别说让别人看你的代码了，只怕你自己都会看晕掉。 所以，拥有一个结构清晰的文档结构对一个软件项目来说至关重要，清晰的文档结构使得我们的源码可扩展性高，容易理解和阅读，也能提高我们写代码的效率。 例如，我们使用的各种框架都拥有良好的文档结构，各个模块各司其职，将相应的代码文件放入对应模块的文件夹中，有条有理，当然，在框架的基础上还需要我们根据实际情况来扩展定制我们自己的文档结构。 程序设计的时候有一种叫“MVC”的模式，对应的文档结构也会遵循这种模式来进行设计，下面就介绍基于“MVC”的一种通用软件项目结构设计。 结构图如下： 入口文件单一入口模式的入口文件，会对请求进行路由，转发到对应的控制器方法，go里面的一般是 main.go ，php中的就是 index.php 了。 conf配置文件夹，存放系统配置相关参数，比如redis地址配置、数据库地址配置、日志结构配置、rpc配置等 controller控制器，MVC中的C，参数输入输出的入口，入口文件将路由解析到具体的控制器方法进行处理，控制器再去调用相关服务获取结果，输出到前端 data存放一些数据文件，比如产生的日志文件，上传文件缓存区等 helpers可以将全局使用到的函数放在这里，即辅助函数 model模型，MVC中的M，应用程序中用于处理应用程序数据逻辑的部分，通常模型对象负责在数据库中存取数据，但在细分出一层专门处理逻辑的service层之后，model一般只设置表数据结构，整合一些通用数据库操作函数 service服务层，专门用来处理逻辑的一层，它的直接上级是controller，输入数据来自controller，输出数据返回给controller public公共层，或者叫 common，一般用来存放静态文件，比如js、css、图片等 views视图，MVC中的V，存放html，xml等前端文件 test测试用例，日常编写测试用例是一个好习惯","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"软件技术","slug":"软件技术","permalink":"https://shuangdeyu.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"}]},{"title":"塞尔达美图欣赏.一","slug":"塞尔达美图欣赏.一","date":"2019-05-23T16:00:00.000Z","updated":"2023-12-28T02:02:00.448Z","comments":true,"path":"2019/05/24/sai-er-da-mei-tu-xin-shang.yi/","link":"","permalink":"https://shuangdeyu.github.io/2019/05/24/sai-er-da-mei-tu-xin-shang.yi/","excerpt":"","text":"最近入了令每个男人感到快乐的switch，当然是沉迷传说中的神作《塞尔达.荒野之息》了，毫不夸张的说，这是我玩过的最伟大的游戏，特别是游戏里大气磅礴的画面，令人十分震撼，特截了一些图，让我们来欣赏下这款神作的魅力。","categories":[{"name":"游戏","slug":"游戏","permalink":"https://shuangdeyu.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"Nintendo","slug":"Nintendo","permalink":"https://shuangdeyu.github.io/tags/Nintendo/"}]},{"title":"基于Go的Rabbitmq实践","slug":"基于Go的Rabbitmq实践","date":"2019-04-15T16:00:00.000Z","updated":"2023-12-22T07:21:46.345Z","comments":true,"path":"2019/04/16/ji-yu-go-de-rabbitmq-shi-jian/","link":"","permalink":"https://shuangdeyu.github.io/2019/04/16/ji-yu-go-de-rabbitmq-shi-jian/","excerpt":"","text":"学会使用消息队列是后端程序员进阶的必备技能之一，消息队列可以异步处理请求，缓解系统的压力，从而达到解耦、削峰等目的，大大提高系统的可用性以及扩展性。 Rabbitmq是使用Erlang语言实现AMQP协议的消息中间件，具有易用、高扩展、高可用、持久化等方面特点，由于成熟优秀的表现和拥有活跃的文档跟社区，Rabbitmq成为很多人开发消息队列的首选。 环境安装参考https://blog.csdn.net/u013219624/article/details/83412925 1、安装erlang由于是基于Erlang开发的，所以必须先安装Erlang环境，从官网可以看到安装源码包，使用wget下载的话会很慢，推荐使用三方下载器下载，然后通过ssh工具传到服务器上，我的软件下载目录一般是 /usr/local/，这里就安装在 /usr/local/erlang。 然后解压安装包，安装。 # wget http://erlang.org/download/otp_src_21.3.tar.gz # tar -xvzf otp_src_21.3.tar.gz # cd otp_src_21.3 # ./configure --prefix=/usr/local/erlang --without-javac # make &amp;&amp; make install 验证一下是否安装成功，切换到 /usr/local/erlang目录，执行下方指令即可看到。 # bin/erl 别忘了配置环境变量，打开 /etc/profile 进行如下编辑 export ERLPATH=/usr/local/erlang export PATH=$PATH:$ERLPATH/bin 修改好之后重新生效配置 # source /etc/profile 现在可以直接用 # erl 指令运行erlang了。 2.安装RabbitmqRabitmq安装比较省力，从官方提供的下载地址中下载rpm安装包，直接安装即可。 # wget https://www.rabbitmq.com/releases/rabbitmq-server/v3.6.15/rabbitmq-server-3.6.15-1.el7.noarch.rpm # yum -y install rabbitmq-server-3.6.15-1.el7.noarch.rpm 查看是否安装成功，首先启动服务，然后查看服务状态。 # service rabbitmq-server start # service rabbitmq-server status 以下是Rabbitmq其它常用指令： // 停止服务 # service rabbitmq-server stop // 重启服务 # service rabbitmq-server restart // 设置开机启动 # chkconfig rabbitmq-server on // 启动web管理插件(127.0.0.1:15672) # rabbitmq-plugins enable rabbitmq_management // 查看用户列表 # rabbitmqctl list_users // 添加用户 # rabbitmqctl add_user admin 123456 // 设置用户角色 # rabbitmqctl set_user_tags admin administrator // 设置权限 # rabbitmqctl set_permissions -p / admin \".*\" \".*\" \".*\" // 删除用户 # rabbitmqctl delete_user admin // 修改用户密码 # rabbitmqctl change_password admin 123456 默认的用户密码是 guest guest，但只限本地访问，远程访问的话必须先创建一个新用户，指定为管理员角色，分配管理员权限，就可以登录管理后台进行操作了。 下图就是登录后的管理界面，这上面可以看到节点、端口、交换机、队列等信息，还可以手动发送消息，管理消息，十分方便。 名词解释1、基础模块要熟练使用Rabbitmq就必须知道其名词含义和工作机制 基本流程 基本的工作流程是这样的：生产者，就是你的发送程序，通过TCP连接，创建channel(通道)向指定的exchange(交换机)发送一个消息，exchange再将消息下发到binding(绑定)的queue(队列)中，然后消费者(处理程序)监听接收queue中的消息进行处理。 这是google的一张流程图 生产者，消费者 即发送消息和接收处理消息的逻辑程序 Channel 通道，rabbitmq的本质是tcp通信，利用tcp连接创建内部的逻辑连接，注意，此通道不是tcp本身通道(tcp一个连接就是一个通道)，而是共享一个tcp连接的其内部实现的连接，至于rabbitmq内部如何实现的我也没吃透，应该是用到了多路复用，总之rabbitmq一切收发都是通过channel实现的，避免了重复连接tcp产生的资源消耗。 Exchange 交换机，相当于是一个消息中转控制中心，负责接收消息然后根据路由规则将消息下发到指定的queue。 Queue 队列，即存放消息的地方，消费的时候直接从队列里取。 2、参数说明 Routing Key 路由键，是exchange跟queue之间的桥梁，exchange根据绑定的routing key下发消息到对应的queue中，决定了消息的流向，键名可以自定义。 Type exchange的类型，有’fanout’、’direct’、’topic’、’headers’四个类型。 fanout：不需要指定路由键，直接将消息发送给exchange中的所有queue，类似于广播。 direct：将消息发给exchange中指定路由键的queue中，相当于精准投放。 topic：匹配模式，消息下发到匹配规则的routing key的queue中，有’*‘与’#’两个通配符，’*‘表示只匹配一个词，’#’表示匹配多个，比如’user.*‘只能匹配到’user.name’而不能匹配到’user.name.wang’，’user.#’则都可以匹配到。 headers：根据消息体的headers匹配，这种用到的比较少，绑定的时候指定相关header参数即可。 Durable exchange跟queue都有这个参数，类型为boolean，表示是否持久化。 Auto delete exchange跟queue都有这个参数，类型为boolean，我试了一下，当exchange绑定的queue全都解绑的时候exchange会自动删除，queue好像没什么影响。 Internal exchange有这个参数，类型为boolean，内部的，意味着不能对这个exchange发送消息，通过管理后台还是可以发送消息的。 noWait 几乎每个步骤都有这个参数，类型为boolean，不需要服务器任何返回值的意思，指服务端创建队列发送消息等，rabbitmq不需要这个返回状态即可进行下一步，正常来说不会用到这个参数，容易报异常。 Exclusive queue有这个参数，类型为boolean，排他队列，只对创建该队列的用户可见，其它用户无法访问。 延伸扩展 rabbitmq还提供了很多扩展参数，比如’x-message-ttl’给消息设置过时时间，’x-max-length-bytes’设置消息最大长度，’x-dead-letter-exchange’设置消息过时后推送到的exchange等等，具体的官方文档也提供了，也可以看管理后台创建exchange、queue的时候会有提示的额外参数。 编程实践使用Go语言操作Rabbitmq需要用到这个库：https://github.com/streadway/amqp，这是一个带Rabbitmq扩展的AMQP客户端。 下面就一步步解析下基于go的rabbitmq收发过程。 1、建立连接上面已经说过了，其本质是tcp链接，并且是基于内部通道进行的通信，所以一个完整的连接分为连接与创建通道两部分。 连接地址的格式是这种形式：amqp://admin:&#x31;&#50;&#51;&#x34;&#x35;&#54;&#64;&#x31;&#x32;&#x37;&#46;&#48;&#46;&#48;&#46;&#49;:5672/ // 建立连接 connection, err := amqp.Dial(uri) if err != nil &#123; log.Println(\"Failed to connect to RabbitMQ:\", err.Error()) return err &#125; defer connection.Close() // 创建一个Channel channel, err := connection.Channel() if err != nil &#123; log.Println(\"Failed to open a channel:\", err.Error()) return err &#125; defer channel.Close() 2、声明exchange首先声明需要发送到的exchange，如果此exchange不存在将会被自动创建。 // 声明 exchange if err := channel.ExchangeDeclare( exchange, //name \"direct\", //exchangeType true, //durable false, //auto-deleted false, //internal false, //noWait nil, //arguments ); err != nil &#123; log.Println(\"Failed to declare a exchange:\", err.Error()) return err &#125; 这里声明的exchange类型为’direct’，精准投放模式，持久化，这也是最常用的配置。 3、声明queue同样，queue也需要先声明，不存在的也会被自动创建。 // 声明一个queue if _, err := channel.QueueDeclare( queue, // name true, // durable false, // delete when unused false, // exclusive false, // no-wait nil, // arguments ); err != nil &#123; log.Println(\"Failed to declare a queue:\", err.Error()) return err &#125; 此队列为持久化队列，以上也是最常用的配置。 4、绑定queue创建好exchange和queue之后，需要建立两者的联系，即绑定，第二个参数就是指定的 routing_key。 // exchange 绑定 queue channel.QueueBind(queue, routing_key, exchange, false, nil) 5、发送消息万事俱备，只剩发送了，指定需要发送的exchange跟’routing_key’，设置好发送的消息体就可以将消息发送出去了，为什么不用指定queue呢，因为消息是先投放到exchange的，exchange会自动根据绑定的规则将消息下发到对应的queue。 // 发送 messageBody := comhelper.JsonEncode(content) if err = channel.Publish( exchange, // exchange routing_key, // routing key false, // mandatory false, // immediate amqp.Publishing&#123; Headers: amqp.Table&#123;&#125;, ContentType: \"text/plain\", ContentEncoding: \"\", Body: []byte(messageBody), //Expiration: \"60000\", // 消息过期时间 &#125;, ); err != nil &#123; log.Println(\"Failed to publish a message:\", err.Error()) return err &#125; 消息体的设置可以去程序中看’Publishing’的定义，有优先级、过期时间等诸多设置。 type Publishing struct &#123; // Application or exchange specific fields, // the headers exchange will inspect this field. Headers Table // Properties ContentType string // MIME content type ContentEncoding string // MIME content encoding DeliveryMode uint8 // Transient (0 or 1) or Persistent (2) Priority uint8 // 0 to 9 CorrelationId string // correlation identifier ReplyTo string // address to to reply to (ex: RPC) Expiration string // message expiration spec MessageId string // message identifier Timestamp time.Time // message timestamp Type string // message type name UserId string // creating user id - ex: \"guest\" AppId string // creating application id // The application specific payload of the message Body []byte &#125; 运行程序，发送一条消息，我们可以通过管理后台看到发送的消息，这时候登录管理控制台，会发现exchange、queue以及绑定关系都被自动创建了。 来到’Queues’面板，找到下面的’Get messages’，点击按钮就能看到消息了。 6、消费消息消息的消费也是从连接并且创建通道开始的，不过消费者不需要声明exchange，因为它是直接从queue中取消息的，所以只声明一个queue即可，注意配置需要跟生产者一样。 其核心代码是注册消费者。 // 注册消费者 msgs, err := ch.Consume( q.Name, // queue \"project\", // 标签 true, // auto-ack false, // exclusive false, // no-local false, // no-wait nil, // args ) if err != nil &#123; log.Println(\"Failed to register a consumer:\", err.Error()) return err &#125; 同样我们也可以在管理控制台的当前queue面板中看到’Consumers’信息。 7、完整代码生产者 package main import ( \"fmt\" \"github.com/streadway/amqp\" \"helper_go/comhelper\" \"log\" ) func main() &#123; uri := \"amqp://admin:123456@127.0.0.1:5672/\" exchange := \"project\" queue := \"pj_event\" routing_key := \"pj_event\" content := map[string]interface&#123;&#125;&#123; \"name\": \"zelda\", &#125; err := Pub_mq(uri, exchange, queue, routing_key, content) fmt.Println(err) &#125; // 生产者 func Pub_mq(uri, exchange, queue, routing_key string, content map[string]interface&#123;&#125;) error &#123; // 建立连接 connection, err := amqp.Dial(uri) if err != nil &#123; log.Println(\"Failed to connect to RabbitMQ:\", err.Error()) return err &#125; defer connection.Close() // 创建一个Channel channel, err := connection.Channel() if err != nil &#123; log.Println(\"Failed to open a channel:\", err.Error()) return err &#125; defer channel.Close() // 声明exchange if err := channel.ExchangeDeclare( exchange, //name \"direct\", //exchangeType true, //durable false, //auto-deleted false, //internal false, //noWait nil, //arguments ); err != nil &#123; log.Println(\"Failed to declare a exchange:\", err.Error()) return err &#125; // 声明一个queue if _, err := channel.QueueDeclare( queue, // name true, // durable false, // delete when unused false, // exclusive false, // no-wait nil, // arguments ); err != nil &#123; log.Println(\"Failed to declare a queue:\", err.Error()) return err &#125; // exchange 绑定 queue channel.QueueBind(queue, routing_key, exchange, false, nil) // 发送 messageBody := comhelper.JsonEncode(content) if err = channel.Publish( exchange, // exchange routing_key, // routing key false, // mandatory false, // immediate amqp.Publishing&#123; Headers: amqp.Table&#123;&#125;, ContentType: \"text/plain\", ContentEncoding: \"\", Body: []byte(messageBody), //Expiration: \"60000\", // 消息过期时间 &#125;, ); err != nil &#123; log.Println(\"Failed to publish a message:\", err.Error()) return err &#125; return nil &#125; 消费者 package main import ( \"fmt\" \"github.com/streadway/amqp\" \"log\" ) func main() &#123; uri := \"amqp://admin:123456@127.0.0.1:5672/\" exchange := \"project\" queue := \"pj_event\" err := Use_mq(uri, exchange, queue) fmt.Println(err) &#125; // 消费者 func Use_mq(uri, exchange, queue string) error &#123; // 建立连接 conn, err := amqp.Dial(uri) if err != nil &#123; log.Println(\"Failed to connect to RabbitMQ:\", err.Error()) return err &#125; defer conn.Close() // 启动一个通道 ch, err := conn.Channel() if err != nil &#123; log.Println(\"Failed to open a channel:\", err.Error()) return err &#125; // 声明一个队列 q, err := ch.QueueDeclare( queue, // name true, // durable false, // delete when usused false, // exclusive false, // no-wait nil, // arguments ) if err != nil &#123; log.Println(\"Failed to declare a queue:\", err.Error()) return err &#125; // 注册消费者 msgs, err := ch.Consume( q.Name, // queue \"project\", // 标签 true, // auto-ack false, // exclusive false, // no-local false, // no-wait nil, // args ) if err != nil &#123; log.Println(\"Failed to register a consumer:\", err.Error()) return err &#125; forever := make(chan bool) go func() &#123; for d := range msgs &#123; log.Println(d.Type) log.Println(d.MessageId) log.Printf(\"Received a message: %s\", d.Body) &#125; &#125;() log.Printf(\"Waiting for messages. To exit press CTRL+C\") &lt;-forever return nil &#125; 高级应用现在我们有一个需求，要求给消息设置过期时间，过期的消息放到另一个队列进行额外的处理，这个队列就叫死信队列。 先来看消息过期时间的设置，有两种方法，一种是声明队列的时候设置x-message-ttl参数，这样这个队列中的消息都会有一个过期时间；还有一种就是发送消息的时候单独给这条消息设置过期时间，即Expiration参数，如果两个参数都设置了，那么以时间短的那个为准。 来做个准备工作，先删除之前创建的’pj_event’队列，然后再控制台手动创建一个名为’dead’的exchange，和一个名为’de_event’的队列，将两者绑定。 然后改造生产者声明queue的代码，如下： // 声明一个queue args := amqp.Table&#123; \"x-message-ttl\": int64(60000), \"x-dead-letter-exchange\": \"dead\", \"x-dead-letter-routing-key\": \"\", &#125; if _, err := channel.QueueDeclare( queue, // name true, // durable false, // delete when unused false, // exclusive false, // no-wait args, // arguments ); err != nil &#123; log.Println(\"Failed to declare a queue:\", err.Error()) return err &#125; 其中x-message-ttl参数设置过期时间，必须是int64格式，x-dead-letter-exchange设置消息过期后下发的交换机，x-dead-letter-routing-key参数必须指定，如果私信队列绑定的时候没有routing key为空就好。 运行代码，从控制台可以看到两条队列的消息情况。 可以看到’pj_event’的消息条数为1，’de_event’死信队列的消息为0，静待一分钟之后再次观察。 这时候’pj_event’中已经没有消息了，而’de_event’中多出了一条消息，点进’de_event’，查看具体的消息内容。 可以看到消息的内容以及来源。 结语Rabbitmq的介绍告一段落，通过本教程相信应该可以领大家入门了，更多的功能我也在研究中，总之，学会使用队列是后端程序员进阶的必备知识，可一定要掌握呀。","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://shuangdeyu.github.io/tags/Go/"},{"name":"Rabbitmq","slug":"Rabbitmq","permalink":"https://shuangdeyu.github.io/tags/Rabbitmq/"}]},{"title":"goquery爬虫实践案例","slug":"goquery爬虫实践案例","date":"2019-04-03T16:00:00.000Z","updated":"2023-12-20T08:34:12.432Z","comments":true,"path":"2019/04/04/goquery-pa-chong-shi-jian-an-li/","link":"","permalink":"https://shuangdeyu.github.io/2019/04/04/goquery-pa-chong-shi-jian-an-li/","excerpt":"","text":"之前一直以为”爬虫”是一门高大上的技术，但自从遇见goquery之后，发现爬取网站也可以这么简单。 goquery是一个使用go语言写的HTML解析库，它最大的特点就是可以像使用jQuery那样，来方便地操作DOM文档，相信做过web开发的人员很快就能掌握其使用方法。 github项目地址 selector(选择器)我认为selector是这个框架的灵魂所在，就是因为实现了类似于jQuery的DOM选择功能，才使得框架非常容易使用。 以下是几个常用的选择器，看着是不是很熟悉: s.Find(\"div\") // 元素选择 s.Find(\"#Content\") // id选择 s.Find(\".content\") // class选择 s.Find(\"div[id=Content]\") // 属性选择 s.Find(\"div>p\") // 子元素选择 s.Find(\"div+p\") // 相邻元素选择 s.Find(\"div~p\") // 兄弟元素选择 s.Find(\"#Content\").Text() // 获取对象的文本内容 s.Find(\"#Content\").Html() // 获取对象的html s.Find(\"#Content\").Attr(\"src\") // 获取对象的src属性值 这里推荐一篇文章，非常详细地介绍了goquery选择器的各种用法。 实战介绍方面网上有写的很好的文章，我也没有什么新的内容补充，所以直接进入实战部分了。 页面分析 这里我用goquery爬了豆瓣电影(心疼豆瓣，好多人把豆瓣电影当爬虫练手)，通过对豆瓣电影主页进行分析，发现电影列表是通过ajax获取的，然而goquery针对的只是静态的DOM文档，对于动态的数据它就无能为力了。 通过观察，找到获取电影列表的url，发现是get方法获取的，那么我们就可以编程构造get请求获取电影列表进行处理了，其有type、tag、sort、page_limit、page_start这几个参数，操作一下页面很容易获取这几个参数值。 使用goquery爬取的是具体的电影详情页面，也没有搞得多复杂，只获取一些基本信息用于展示即可。 爬取电影详情页信息 其实文字上也没什么好描述的，看代码来的更直观明了，先讲一下步骤，首先自然是要get请求获取页面内容了，然后创建一个goquery解析器，最后使用选择器获取需要的数据即可。 func GetMovieInfo(url string) *MovieParam &#123; // get请求获取页面 res, err := http.Get(url) if err != nil &#123; log.Println(err) return nil &#125; defer res.Body.Close() if res.StatusCode != 200 &#123; log.Printf(\"status code error: %d %s\", res.StatusCode, res.Status) return nil &#125; // 创建解析器 doc, err := goquery.NewDocumentFromReader(res.Body) if err != nil &#123; log.Println(err) return nil &#125; param := MovieParam&#123;&#125; doc.Find(\"#content\").Each(func(i int, s *goquery.Selection) &#123; param.Year = s.Find(\"h1 .year\").Text() // 年份 param.Img, _ = s.Find(\"#mainpic img\").Attr(\"src\") // 图片 param.Summary, _ = s.Find(\"#link-report span[property]\").Html() // 摘要 param.Rating_people = comhelper.StringToInt(s.Find(\".rating_people span[property]\").Text()) // 评论人数 star, _ := s.Find(\".bigstar\").Attr(\"class\") // 星级值 param.Bigstar = comhelper.StringToInt(star[len(star)-2 : len(star)]) stars_five := s.Find(\".stars5+div+span\").Text() // 5星的比例值 param.Stars_five = comhelper.StringToFloat(stars_five[0:len(stars_five)-1], 64) stars_four := s.Find(\".stars4+div+span\").Text() // 4星的比例值 param.Stars_four = comhelper.StringToFloat(stars_four[0:len(stars_four)-1], 64) stars_three := s.Find(\".stars3+div+span\").Text() // 3星的比例值 param.Stars_three = comhelper.StringToFloat(stars_three[0:len(stars_three)-1], 64) stars_two := s.Find(\".stars2+div+span\").Text() // 2星的比例值 param.Stars_two = comhelper.StringToFloat(stars_two[0:len(stars_two)-1], 64) stars_one := s.Find(\".stars1+div+span\").Text() // 1星的比例值 param.Stars_one = comhelper.StringToFloat(stars_one[0:len(stars_one)-1], 64) // 图片转换成base64 img_url, _ := _download_img(param.Img) new_img, err := comhelper.ImgToBase64(img_url) if err == nil &amp;&amp; new_img != \"\" &#123; param.Img = new_img &#125; s.Find(\"#info\").Each(func(ii int, ss *goquery.Selection) &#123; info, _ := ss.Html() param.Director = ss.Find(\"a[rel*=directedBy]\").Text() // 导演 film_length, _ := ss.Find(\"span[property*=runtime]\").Attr(\"content\") // 时长 param.Film_length = comhelper.StringToInt(film_length) param.Release_date = ss.Find(\"span[property*=initialReleaseDate]\").Text() // 上映日期 // 获取类型 tags := \"\" ss.Find(\"span[property*=genre]\").Each(func(i int, s *goquery.Selection) &#123; if tags == \"\" &#123; tags += s.Text() &#125; else &#123; tags += \"/\" + s.Text() &#125; &#125;) param.Tags = tags // 获取主演 actor := \"\" ss.Find(\"a[rel*=starring]\").Each(func(i int, s *goquery.Selection) &#123; if actor == \"\" &#123; actor += s.Text() &#125; else &#123; actor += \"/\" + s.Text() &#125; &#125;) param.Actor = actor c_start := strings.Index(info, \"&lt;span class=\\\"pl\\\">制片国家/地区:&lt;/span>\") c_end := strings.Index(info, \"&lt;span class=\\\"pl\\\">语言\") param.Country = comhelper.TrimHtml(info[c_start+44 : c_end]) &#125;) &#125;) return &amp;param &#125; 那些有id、class或者特殊属性的字段最容易获取了，比较麻烦的是那些没有明显特征的字段，只能通过字符串截取的方法获取了，不过也都是些常规操作，整个流程下来没什么难点，这也说明了goquery的简单易用。 成果展示 成果展示以及源码点击这里（抱歉，服务器太贵了，已脱坑） 遇到的问题频繁访问会导致ip被锁住，不过我也只是练习，所以只是爬取了一点数据用来展示。 图片会有访问权限的问题，所以我转换成了base64格式存到数据库里，不过在页面渲染的时候由于数据量过大导致页面加载巨慢。","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://shuangdeyu.github.io/tags/Go/"},{"name":"爬虫","slug":"爬虫","permalink":"https://shuangdeyu.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Quill—心目中的最佳富文本编辑器","slug":"Quill—心目中的最佳富文本编辑器","date":"2019-03-26T16:00:00.000Z","updated":"2023-12-22T07:25:18.593Z","comments":true,"path":"2019/03/27/quill-xin-mu-zhong-de-zui-jia-fu-wen-ben-bian-ji-qi/","link":"","permalink":"https://shuangdeyu.github.io/2019/03/27/quill-xin-mu-zhong-de-zui-jia-fu-wen-ben-bian-ji-qi/","excerpt":"","text":"由于长时间使用 UEditor 编辑器，再加上 UEditor 界面实在不够清新，不符合我的审美，遂决定给网站后台换一个富文本编辑器，经过几天的寻找以及试用，终于找到了符合我这强迫症的最完美的编辑器，它就是——Quill。 几大编辑器比较UEditor链接：https://ueditor.baidu.com/website/ 这款编辑器应该很多人都用过吧，说实话，它的功能在我看来是最全面、最强大的，不仅包含丰富的文本样式编辑，还有强大的表格编辑功能，插入功能，而且接入十分简单，可惜的是官方早就不再更新了，所以样式看起来不那么“主流”，不过这个就见仁见智了，并不影响它成为一款优秀的富文本编辑器。 Simditor链接：https://simditor.tower.im/ 这款编辑器满足基本的需求，但插件不是很多，样式比较清新好看，对于我来说少了字体颜色的设置，代码高亮也不甚理想，要求不高的可以使用这款。 wangEditor链接：http://www.wangeditor.com/ 这款编辑器是国内一个开发者开源的，功能基本足够，样式主流，但文档中说明了“从编辑器中获取的 html 代码是不包含任何样式的纯 html”，就是说需要自己编写样式，但相对来说灵活多变，可以自己实现多皮肤功能 CKEditor链接：https://ckeditor.com 这款也算中规中矩吧，有基本功能，但看了一圈还是没有我需要的字体颜色跟代码高亮功能，但值得一提的是，它有行内编辑功能，编辑内容更加直观，仿佛是在编辑网页一样，这个功能还是挺强大的。 TinyMCE链接：https://www.tiny.cloud/ 这款编辑器很漂亮，功能也非常多，编辑出的文章样式也十分美观，代码高亮功能实现的也可以，但它却是我最不喜欢的一款，因为我觉得它太重了，类似于word的菜单功能虽多，但隐藏较深，操作步骤变多，这很影响编辑文章的速度以及注意力，当然最常用的几个功能还是显式，所以就见仁见智吧。 Froala链接：https://www.froala.com/ 这款被很多人称为史上最NB的编辑器，的确它功能强大，插件丰富，可自定义主题和插件，我简单使用了一下，没有我需要的代码高亮，所以果断放弃，或许它可以自定义配置，但我没有深究。 Quill链接：https://quilljs.com/ 寻寻觅觅，寻寻觅觅，终于找到你，最符合我需求的编辑器——quill，样式不用多说，也是主流的黑白清新风，美观，功能上虽然不是很多，甚至还没有表格，网络图片上传（可以通过复制网络图片并黏贴解决）等功能，但它的代码高亮是最完美的，因为它本身就支持了hignlight.js，同样支持行内编辑模式，可自定义，总的来说，这是一款优点多但缺点同样明显的编辑器，但却完美契合我的需求，所以我比较喜爱这款。 Quill 的使用快速开始开始构建一个quill编辑项目包括引入文件、创建自定义工具栏、创建编辑容器以及初始化这几部分。 &lt;!-- 引入css文件 --> &lt;link href=\"https://cdn.quilljs.com/1.0.0/quill.snow.css\" rel=\"stylesheet\"> &lt;!-- 自定义编辑器工具栏 --> &lt;div id=\"toolbar\"> &lt;button class=\"ql-bold\">Bold&lt;/button> &lt;button class=\"ql-italic\">Italic&lt;/button> &lt;/div> &lt;!-- 创建编辑容器 --> &lt;div id=\"editor\"> &lt;p>Hello World!&lt;/p> &lt;/div> &lt;!-- 引入js文件 --> &lt;script src=\"https://cdn.quilljs.com/1.0.0/quill.js\">&lt;/script> &lt;!-- 初始化编辑器，snow主题 --> &lt;script> var editor = new Quill('#editor', &#123; modules: &#123; toolbar: '#toolbar' &#125;, theme: 'snow' &#125;); &lt;/script> quill主要资源介绍&lt;!-- 主要的库文件，js --> &lt;script src=\"//cdn.quilljs.com/1.3.6/quill.js\">&lt;/script> &lt;script src=\"//cdn.quilljs.com/1.3.6/quill.min.js\">&lt;/script> &lt;!-- css文件，有两个主题，snow和bubble --> &lt;link href=\"//cdn.quilljs.com/1.3.6/quill.snow.css\" rel=\"stylesheet\"> &lt;link href=\"//cdn.quilljs.com/1.3.6/quill.bubble.css\" rel=\"stylesheet\"> &lt;!-- 没有主题的核心构建, 不必要的模块（使用不需要引入） --> &lt;link href=\"//cdn.quilljs.com/1.3.6/quill.core.css\" rel=\"stylesheet\"> &lt;script src=\"//cdn.quilljs.com/1.3.6/quill.core.js\">&lt;/script> 以上就是quill的库文件了，但要实现代码高亮的话需要自己引入highlight.js库，只需要引入就可以了，不需要额外的配置，所以完整的引入，以我的项目为参考： // 代码高亮采用dracula主题，可去highlight官网配置 &lt;link href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/dracula.min.css\" rel=\"stylesheet\"> // 采用snow主题 &lt;link href=\"https://cdn.quilljs.com/1.3.6/quill.snow.css\" rel=\"stylesheet\"> // highlight.js的主要js文件 &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js\">&lt;/script> // quill的主要js文件 &lt;script src=\"https://cdn.quilljs.com/1.3.6/quill.min.js\">&lt;/script> 创建编辑器quill的使用也很简单，引入上面的资源之后就可以开始创建编辑器了。 首先需要定义编辑器的工具栏，有两种方式，一种是直接html创建，一种是通过js创建，相对来说html更加直观一些，这里就简单的放两个示例介绍一下。 通过一个js数组来配置初始化容器： var toolbarOptions = [ ['bold', 'italic', 'underline', 'strike'], // 切换按钮 ['blockquote', 'code-block'], [&#123; 'header': 1 &#125;, &#123; 'header': 2 &#125;], // 用户自定义按钮值 [&#123; 'list': 'ordered'&#125;, &#123; 'list': 'bullet' &#125;], [&#123; 'script': 'sub'&#125;, &#123; 'script': 'super' &#125;], // 上标/下标 [&#123; 'indent': '-1'&#125;, &#123; 'indent': '+1' &#125;], // 减少缩进/缩进 [&#123; 'direction': 'rtl' &#125;], // 文本下划线 [&#123; 'size': ['small', false, 'large', 'huge'] &#125;], // 用户自定义下拉 [&#123; 'header': [1, 2, 3, 4, 5, 6, false] &#125;], [&#123; 'color': [] &#125;, &#123; 'background': [] &#125;], // 主题默认下拉，使用主题提供的值 [&#123; 'font': [] &#125;], [&#123; 'align': [] &#125;], ['clean'] // 清除格式 ]; var quill = new Quill('#editor', &#123; modules: &#123; toolbar: toolbarOptions &#125;, theme: 'snow' &#125;); 通过html来创建工具栏冰初始化容器： &lt;div id=\"toolbar-container\"> &lt;span class=\"ql-formats\"> &lt;select class=\"ql-font\">&lt;/select> &lt;select class=\"ql-size\">&lt;/select> &lt;/span> &lt;span class=\"ql-formats\"> &lt;button class=\"ql-bold\">&lt;/button> &lt;button class=\"ql-italic\">&lt;/button> &lt;button class=\"ql-underline\">&lt;/button> &lt;button class=\"ql-strike\">&lt;/button> &lt;/span> &lt;span class=\"ql-formats\"> &lt;select class=\"ql-color\">&lt;/select> &lt;select class=\"ql-background\">&lt;/select> &lt;/span> &lt;span class=\"ql-formats\"> &lt;button class=\"ql-script\" value=\"sub\">&lt;/button> &lt;button class=\"ql-script\" value=\"super\">&lt;/button> &lt;/span> &lt;span class=\"ql-formats\"> &lt;button class=\"ql-header\" value=\"1\">&lt;/button> &lt;button class=\"ql-header\" value=\"2\">&lt;/button> &lt;button class=\"ql-blockquote\">&lt;/button> &lt;button class=\"ql-code-block\">&lt;/button> &lt;/span> &lt;span class=\"ql-formats\"> &lt;button class=\"ql-list\" value=\"ordered\">&lt;/button> &lt;button class=\"ql-list\" value=\"bullet\">&lt;/button> &lt;button class=\"ql-indent\" value=\"-1\">&lt;/button> &lt;button class=\"ql-indent\" value=\"+1\">&lt;/button> &lt;/span> &lt;span class=\"ql-formats\"> &lt;button class=\"ql-direction\" value=\"rtl\">&lt;/button> &lt;select class=\"ql-align\">&lt;/select> &lt;/span> &lt;span class=\"ql-formats\"> &lt;button class=\"ql-link\">&lt;/button> &lt;button class=\"ql-image\">&lt;/button> &lt;button class=\"ql-video\">&lt;/button> &lt;button class=\"ql-formula\">&lt;/button> &lt;/span> &lt;span class=\"ql-formats\"> &lt;button class=\"ql-clean\">&lt;/button> &lt;/span> &lt;/div> &lt;div id=\"editor\">&lt;/div> &lt;script> var quill = new Quill('#editor', &#123; modules: &#123; toolbar: '#toolbar-container' &#125; &#125;); &lt;/script> ok，这样配置并初始化之后就可以完美展示编辑器了，来看一下成果图： 获取内容最终的结果是我们需要获取编辑的内容并保存到服务器中，这个不用多讲，获取容器的内容即可，但需要注意的是需要在获取的内容外包上两个div容器，不然展示页面不能展示编辑时所见的效果，同样，展示界面也需要引入quill的css以及highlight的css。 // 提交表单 function sub_post() &#123; var html = document.querySelector('#editor').children[0].innerHTML; html = '&lt;div class=\"ql-container ql-snow\">&lt;div class=\"ql-editor\">'+html+\"&lt;/div>&lt;/div>\"; $('[name=content]').val(html); $(\"#submitForm\").submit(); &#125; 完美展示，效果赏心悦目 总结更多内容可以去网上看文档，有中文翻译的。编辑器种类繁多，萝卜青菜各有所爱，找到适合自己的就好，当然有兴趣有时间的其实所有的编辑器都可以自行扩展出更好看的样式，使用之余别忘了给作者们一个赞。","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://shuangdeyu.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"分享","slug":"分享","permalink":"https://shuangdeyu.github.io/tags/%E5%88%86%E4%BA%AB/"}]},{"title":"分享一下我收藏的网站","slug":"分享一下我收藏的网站","date":"2019-03-21T16:00:00.000Z","updated":"2023-12-22T07:38:10.428Z","comments":true,"path":"2019/03/22/fen-xiang-yi-xia-wo-shou-cang-de-wang-zhan/","link":"","permalink":"https://shuangdeyu.github.io/2019/03/22/fen-xiang-yi-xia-wo-shou-cang-de-wang-zhan/","excerpt":"","text":"加精： http://www.dgtle.com/portal.php 数字尾巴 http://www.jiemian.com/ 界面新闻 https://sspai.com/ 少数派 http://www.jianshu.com/ 简书 https://www.zhihu.com/ 知乎 https://www.12306.dog/ 翻墙用的 收藏： http://www.cyzone.cn/ 创业邦 http://www.duowan.com/ 多玩游戏 https://www.taptap.com/ 手游社区 https://goimg.io/ 在线图片压缩 https://www.remove.bg/ 在线抠图 https://cowlevel.net/feed 奶牛关，游戏资讯网 http://www.ui.cn/ ui 中国 https://www.zcool.com.cn/ 站酷，设计师平台 https://bookfere.com/ 书伴，kindle伴侣 https://sonarwhal.com/ 在线扫描检查网页 https://bcy.net/ 半次元 - 二次元聚集地 http://www.woshipm.com/ 人人都是产品经理 http://www.lvyun188.com/ 古诗词收录的网站 https://tousu.sina.com.cn/ 黑猫投诉-互联网投诉平台 https://www.nowcoder.com/ 牛客网-互联网面试神器 http://sfz.ckd.cc/idcard.php 身份证号码大全 https://www.toptal.com/designers/subtlepatterns/ 网页背景图片 https://linci.co/sp/ 双拼输入法练习 http://chuangzaoshi.com/ 优秀的网站导航 有趣： https://habitica.com/ 以游戏的方式完成每日任务 http://news.kedo.gov.cn/ 蝌蚪五线谱 https://izhongchou.taobao.com/index.htm 淘宝众筹 https://www.v2ex.com/ V2EX论坛 https://www.apowersoft.cn/record-all-screen 一个好用的录屏软件 https://www.goto-mars.com/ 火星首页—上网首页导航 https://mijisou.com/ 秘迹搜索 https://www.akaxin.com/docs/ 搭建个人聊天软件 http://www.chongbuluo.com/ 虫部落 前端： https://pandao.github.io/editor.md/index.html 强大的markdown编辑器插件 http://prismjs.com/examples.html 网站代码语法高亮插件 http://zui.sexy/ zui前端框架（首选） https://www.mdui.org/ MDUI前端框架（第二备选） https://github.com/MoePlayer/APlayer 音乐播放插件 https://github.com/MoePlayer/DPlayer 视频播放插件 https://github.com/sampotts/plyr 视频播放插件2 https://github.com/abodelot/jquery.json-viewer json解析插件 http://www.getuikit.net/index.html uikit前端框架 https://cn.vuejs.org/ vue中文网 https://www.iviewui.com/ 基于vue的ui框架 http://element-cn.eleme.io/#/zh-CN 基于vue的ui框架 https://github.com/umi-soft/element-admin 基于vue+elementUI构建的admin基础脚手架 http://www.jq22.com/ jquery插件库 https://threejs.org/ 网页3D渲染JS引擎 three.js https://github.com/mqttjs/MQTT.js 一个mqtt客户端 https://fengyuanchen.github.io/viewerjs/ 图片浏览插件 https://www.vaptcha.com/ 手势验证码 http://www.geetest.com/ 极验验证码 https://canvasjs.com/ 漂亮的js开源图表库 http://travistidwell.com/jsencrypt/ js 的各种加密库 https://uigradients.com/#Summer 获取渐变色css的网站 https://qishaoxuan.github.io/css_tricks/ css常用样式大全 https://www.bootcdn.cn/ 前端开源项目CND加速服务 https://blog.csdn.net/li396864285/article/details/78095814 bootstrap3后台管理框架 技术： https://github.com/ github https://leancloud.cn/ learncloud http://www.imooc.com/ 慕课网 https://www.shiyanlou.com/ 实验楼，类似于慕课 https://leetcode-cn.com/ 算法练习网站 https://wowphp.com/index.html wowphp，php学习网 https://juejin.im/ 掘金，开发者社区 https://nwjs.io/ 桌面应用开发 NW.js http://get.ftqq.com/7870.get 桌面应用开发 electron http://emqtt.com/docs/v2/getstarted.html MQTT消息服务器 https://jsfiddle.net/ 在线编程练习 https://segmentfault.com/ 程序员问答网 http://www.freebuf.com/ 互联网安全媒体网 https://tool.lu/ 程序员实用工具网 http://www.pythontab.com/ python中文社区 https://www.swoole.com/ php-swoole通信框架 http://www.workerman.net/ php socket框架 http://www.manks.top/ yii教程网 https://codeigniter.org.cn/ ci框架中文站 http://www.php.cn/ php中文网 http://www.regexlab.com/zh/regref.htm 正则表达式教程 http://phpseclib.sourceforge.net/ php一个安全相关函数库 http://www.dockerinfo.net/document docker中文文档 https://studygolang.com/ go语言中文网 http://gorm.book.jasperxu.com/ go的一个orm库(数据库操作) https://github.com/snail007/goproxy go的一个高性能代理库 https://godoc.org/ go包.函数查询网站 https://github.com/didi/gendry 滴滴的go数据库操作库 https://github.com/CyC2018/Interview-Notebook 技术面试需要掌握的基础知识整理 https://xcrawler.yanshuju.com/ 一个php爬虫框架 https://blog.csdn.net/yuelenglingxi/article/details/41956249 常用正则表达式大全 https://github.com/gogs/gogs 一个类似于gitlab的轻量级代码管理系统 https://legacy.gitbook.com/@smallnest go-rpc开发指南 https://github.com/EDDYCJY/go-gin-example 一个gin学习案例的库 https://hellogithub.com/ github开源项目分享 https://www.infoq.cn/ 软件开发资讯站 资源： https://typora.io/ 轻量markdown编辑器 http://www.wifi-robots.com/ 机器人创客平台 https://lufficc.com/blog/useful-online-tools 实用的工具网站资源 https://yuque.com/ 语雀-阿里知识库创作工具 https://love2.io/ 一个收集开源书籍的网站 https://github.com/davideuler/architecture.of.internet-product 互联网公司技术架构整理 https://tuna.moe/ 清华大学开源镜像软件站 http://typecho.org/ typecho博客平台 http://idea.lanyus.com/ 用于phpstorm软件破解 https://github.com/ethereum/go-ethereum golang一个干货满满的包 http://www.flysnow.org/2016/12/27/golang-hot-project-in-github.html 一些优秀的go开源项目 https://github.com/chaozh/awesome-blockchain-cn 区块链教程资源 https://chai2010.gitbooks.io/advanced-go-programming-book/content/ go语言高级编程电子书 https://github.com/b3log/pipe 一款小而美的go博客平台 https://bbs.xiuno.com/ 一个轻论坛框架 https://icon.52112.com/ 矢量图标 https://i.loli.net/ 一个图床 https://hostingranking.cn/ 介绍各大平台云服务器 优秀博客： https://daimajia.com/ 代码家 http://www.ruanyifeng.com/blog/ 阮一峰博客 https://wdxtub.com/ 小士刀 https://tech.youzan.com 有赞技术团队博客 https://www.fghrsh.net/ 一个好看的二次元博客 https://github.com/MoePlayer 播放器、音视频、弹幕相关开源开发库 https://www.golangnote.com/ golang笔记 https://github.com/EDDYCJY/blog go优秀博客 https://www.cnblogs.com/vamei/ vamei博客 企业： http://www.ikonke.com/index.php 控客科技 http://www.dji.com/cn 大疆科技 http://www.eqxiu.com/home 易企秀 http://www.500d.me/ 五百丁，在线简历 http://www.mmtrix.com/ 网站、app评测 非技术类教程: https://blog.csdn.net/u011250882/article/details/49311933 phpstorm 配置 ci提示 https://juejin.im/post/5a6b1b3651882573443cea61 manjaro配置美化 技术教程: https://segmentfault.com/a/1190000011263680 rsa加解密（php,go,java） https://www.codetd.com/article/1506682 比特币钱包地址生成 https://blog.csdn.net/hjxzb/article/details/81044583 配置go程序监控系统 https://www.golangnote.com/topic/75.html go map 排序 https://yami.io/golang-prometheus/ [go程序系统性能监测] https://github.com/zsais/go-gin-prometheus https://blog.csdn.net/bruce_chou/article/details/80817888 [双系统安装manjaro] https://blog.csdn.net/daerzei/article/details/79501000 https://my.oschina.net/langxSpirit/blog/1647000 https://github.com/rpcx-ecosystem/rpcx-examples3 [golang xrpc学习结合这两个看] http://doc.rpcx.site/part4/alias.html https://blog.csdn.net/lu_embedded/article/details/81100704 [gitbook写书教程] https://gitbook.zhangjikai.com/plugins.html https://yangjh.oschina.io/gitbook/faq/Plugins.html https://www.imooc.com/article/22889?block_id=tuijian_wz https://zhuanlan.zhihu.com/p/43442012 安装manjaro deepin https://juejin.im/post/5acda89151882555867fc6b7 go的跨域处理gin https://zhuanlan.zhihu.com/p/33471484 go lua 教程 https://segmentfault.com/a/1190000015143188?hmsr=studygolang.com&amp;utm_medium=studygolang.com&amp;utm_source=studygolang.com go iban编码实现 https://github.com/rcrowley/go-metrics [性能统计研究] https://segmentfault.com/a/1190000014646203 https://jingyan.baidu.com/article/e8cdb32b136ad637052bad26.html centos安装VM tools https://blog.csdn.net/ruangong1203/article/details/73065410 gitlan+jenkins安装配置 https://www.xttblog.com/?p=3582 一套mysql开发规范","categories":[{"name":"资源","slug":"资源","permalink":"https://shuangdeyu.github.io/categories/%E8%B5%84%E6%BA%90/"}],"tags":[{"name":"分享","slug":"分享","permalink":"https://shuangdeyu.github.io/tags/%E5%88%86%E4%BA%AB/"}]},{"title":"jenkins安装以及使用","slug":"jenkins安装以及使用","date":"2019-03-06T16:00:00.000Z","updated":"2023-12-22T07:55:48.568Z","comments":true,"path":"2019/03/07/jenkins-an-zhuang-yi-ji-shi-yong/","link":"","permalink":"https://shuangdeyu.github.io/2019/03/07/jenkins-an-zhuang-yi-ji-shi-yong/","excerpt":"","text":"“Jenkins是一个独立的开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。前身是Hudson是一个可扩展的持续集成引擎。可用于自动化各种任务，如构建，测试和部署软件。” 以上是官方的介绍，专业术语较多，理解起来可能有点费劲，举个栗子：我刚开始在线上部署代码的时候用的是最笨的手动部署方法，费时又费力，还容易出错，后来使用svn进行部署，方便了不少，但是功能有限，操作也不是这么便捷，再来看jenkins，当我们提交更新的代码到github或者gitlab等平台的时候，jenkins能够自动将代码同步到服务器，并且能够自动运行各种指令，比如构建go服务，真的是做到了一步到位，当然，前提是jenkins与项目的关联配置需要做好，重要的是它有图形操作界面，说是项目自动化神器也不为过。 那么接下来，我们来学习一下jenkins的安装以及使用。 安装这里环境是centos7，首先需要安装好java环境，然后通过 .war 包安装jenkins十分方便(war是java的web项目打包而成)，去官网就可以下载 https://jenkins.io/download/ 选择最下面的war包进行下载，我将其放在 /usr/local/jenkins 目录下 然后进到目录运行这个指令 java -jar jenkins.war 就能够启动jenkins了，简单得令人发指，以下就是启动界面，等待少许时间即可 然后在浏览器中访问 http://主机ip:8080 会出现如下界面，复制页面上的路径，执行 vim /root/.jenkins/secrets/initialAdminPassword 复制密码到页面上进行管理员认证一下即可 然后到选择安装插件界面，一般选择’安装推荐的插件’，这里可能会遇到jenkins离线的问题，我从网上找的方法，修改升级站点url然后重启还是会显示jenkins离线的界面，所以我索性跳过插件安装，先完善后续的账号信息，然后手动添加插件成功了，关于插件，也是使用jenkins必须要了解的一个知识 这就是安装好之后的插件界面，路径为 系统管理 -&gt; 插件管理 ，到此，jenkins的安装算是初步完成了，接下来就是如何使用了，不过在使用之前建议先熟悉下各个界面和常用插件 使用jenkins准备这里我使用jenkins自动构建部署go项目的服务，如下图所示，这是一个基于go语言的项目 运行go项目的基础指令是 go run main.go ，这里我将构建go服务的指令写成脚本 start.sh ，需要重新构建的时候直接运行下 ./start.sh 脚本即可，如果没有jenkins，一旦代码有更新，那么正常的流程就是到这个项目目录下 git pull 拉取最新的代码，然后手动运行start脚本运行程序 使用jenkins的话，只要在本地提交代码，jenkins就会自动帮我们到服务器上拉取最新的代码，并且自动执行start脚本运行程序，方便了很多 这里重点介绍一下 start.sh 脚本，这是脚本中的指令： #!/bin/sh #go build -a -o file_pool_ser main.go kill -9 $(pidof /var/go/src/file_pool_service/file_pool_ser) nohup /var/go/src/file_pool_service/file_pool_ser -c /var/go/src/file_pool_service/conf/conf.yaml > /var/go/src/file_pool_service/sys.log 2>&amp;1 &amp; kill -9 $(pidof /var/gowww/src/file_pool_service/file_pool_ser) 用于在构建新的进程之前删除旧的正在运行的进程， file_pool_ser 是构建go程序的时候生成的二进制文件，在服务器中运行的就是这个构建的二进制文件 go build -a -o file_pool_ser main.go 就是构建这个go项目的指令，生成二进制文件 file_pool_ser，这个过程放在jenkins中执行，所以start脚本中不运行这个指令 最后那句指令是运行 file_pool_ser ，即在后台运行此项目，相关日志输出到同目录下的 sys.log 文件中，这就是运行一个go程序所执行的步骤 配置jenkins准备好相关项目文件之后，接下来就要在jenkins中配置使之自动构建了 来到jenkins首页，新建一个任务，输入任务名称，然后选择第一个 ‘构建一个自由风格的软件’ 接下来就是配置项目了，首先是常规配置，这里填写描述信息，然后选择 ‘丢弃旧的构建’ ，因为jenkins每次构建都会产生构建的项目包和历史记录，如果一直保留的话会占用更多的磁盘空间，所以这里要做过期处理，数值可以自己根据真实环境来设置 然后是 ‘源码管理’ ，现在的公司基本上都是采用git对项目进行版本控制以及源码管理的，比较有名的就是github和gitlab了，这里我使用github，公司内部的话建议自搭建gitlab环境 首先我们选择git这个选项，填写项目的Git地址，然后点击下面的添加按钮添加凭证，这里选择账号密码的类型，填写自己git的账号跟密码，最后设置服务器上项目需要从github上check out的地址 构建触发器就选择当github有代码提交时构建 构建环境默认，直接到构建选项增加步骤 ‘执行shell’，输入下面的指令，即在项目目录中构建go项目的可执行文件，设置一些文件的权限，然后运行 start.sh 执行脚本即可，这部分上面已经介绍过了，最后点击保存就配置好了 cd /var/gowww/src/file_pool_api go build -a -o file_pool_api main.go sudo chmod +x /var/gowww/src/file_pool_api/file_pool_api sudo chmod +x /var/gowww/src/file_pool_api/start.sh sudo /var/gowww/src/file_pool_api/start.sh echo \"OK\" 注意完成以上步骤之后会发现，本地提交代码到github之后jenkins并没有自动构建，然后我手动点击 ‘立即构建’ 按钮之后项目就开始构建了，这是因为jenkins跟github并没有建立通知关系，也就是说github更新代码之后没有通知jenkins我代码更新了，需要开始构建了 所以，我们还缺少了建立通知关系的配置，先到github界面，进入到访问token设置界面，勾选hook(钩子)相关的权限即可 然后还是在github上，进入到需要通知构建的项目中，进入设置，配置一下 ‘webhook’ 地址，意味着github将会通知到jenkins的这个地址上 上面的这个jenkins webhook地址需要回到jenkins中设置，进入到 ‘系统设置’ ，往下来找到github插件的配置，点击红圈处没展开前有一个高级按钮，勾选下面的 ‘为github指定另一个Hook URL’ ，将会自动生成webhook的地址 结果到此为止，所有的设置工作都做完了，现在我们来验证一下，我在项目 main.go 中打印一个测试字符串，并提交代码 fmt.Println(\"test jenkins!!\") 提交成功之后回到jenkins界面，会发现项目已经开始在构建了，蓝色的表示构建成功，红色的表示构建失败，我们可以点击这些构建历史查看控制台输出的信息，控制台将会输出失败或者成功的日志，方便我们排查错误 最后查看服务上的项目日志，发现成功打印出了代码中的字符串，那就恭喜你，使用jenkins自动更新并构建项目成功了！ 结语本文过了一遍jenkins的安装以及基本用法，但jenkins的很多知识还没有涵盖，大家多多实践，多多查阅资料，感受自动化构建项目的乐趣","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://shuangdeyu.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"CI/CD","slug":"CI-CD","permalink":"https://shuangdeyu.github.io/tags/CI-CD/"}]},{"title":"go Lua 基础教程","slug":"go Lua 基础教程","date":"2019-01-30T16:00:00.000Z","updated":"2023-12-28T02:58:12.311Z","comments":true,"path":"2019/01/31/go-lua-ji-chu-jiao-cheng/","link":"","permalink":"https://shuangdeyu.github.io/2019/01/31/go-lua-ji-chu-jiao-cheng/","excerpt":"","text":"Lua是什么？“Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。” 可以比喻为一个插件，用于插入到程序中执行特定功能的脚本，特点是方便嵌入，容易使用和扩展程序。 举个例子 比如我们有个事件系统，用于处理一些事件和定时任务，要做到可灵活配置这些定时任务，那么主程序代码肯定是不能经常修改甚至不用修改的，那么我们可以这么做，使用 mysql+Lua+cron 进行可配置化定时任务。 如下表所示，‘@hourly‘ 是定时时间，’local Param = { } ret = call_service(userService,”getUserInfo”,Param) print(ret[‘data’])‘ 就是需要执行的Lua脚本了，主程序中写好运行框架，然后在表中添加、修改、删除任务，都不会影响程序结构，是不是很灵活。 lua基础练习这里推荐使用 GopherLua 这个开源项目，它是用Go语言编写的Lua的虚拟机和编译器，使用起来非常方便，先来看一个示例： package main import ( \"fmt\" \"github.com/yuin/gopher-lua\" \"log\" ) func main() &#123; // 创建一个lua解释器实例 l := lua.NewState() defer l.Close() // 注册函数 l.SetGlobal(\"call_service\", l.NewFunction(callService)) // 注册lua变量 l.SetGlobal(\"filePoolService\", lua.LString(\"FilePoolService\")) // 需要执行的lua代码 err := l.DoString(`function info(n) local Param = &#123; ['id'] = n,['name'] = 'jyj' &#125; ret = call_service(filePoolService,\"GetUserInfo\",Param) return ret['data'] end`) if err != nil &#123; log.Println(err) &#125; // 执行具体的lua脚本 err = l.CallByParam(lua.P&#123; Fn: l.GetGlobal(\"info\"), // 获取info函数引用 NRet: 1, // 指定返回值数量 Protect: true, // 如果出现异常，是panic还是返回err &#125;, lua.LNumber(1)) // 传递输入参数n=1 if err != nil &#123; panic(err) &#125; // 获取返回结果 ret := l.Get(-1) // 从堆栈中删除返回值 l.Pop(1) // 打印返回结果 fmt.Println(ret) &#125; // lua脚本中调用的函数 func callService(L *lua.LState) int &#123; // 根据编号获取传入参数(从1开始) service := L.ToString(1) param := L.ToTable(3) param.ForEach(func(key, value lua.LValue) &#123; fmt.Println(key.String()) fmt.Println(value.String()) &#125;) // 注册一个table类型,设置返回参数 t := L.NewTable() t.RawSet(lua.LString(\"msg\"), lua.LString(\"success\")) t.RawSet(lua.LString(\"data\"), lua.LString(service)) // 将返货结果堆栈 L.Push(t) return 1 &#125; 以上程序打印输出为 ‘FilePoolService‘，下面我们来解读一下这段代码 l.SetGlobal() 注册函数，’call_service’是lua代码里的调用函数，我们实际需要执行的是go代码，所以需要注册一下，将call_service指向实际运行的代码，这里就是下面的 ‘callService’ 函数了，简单来说’SetGlobal’函数就是用来将lua脚本中的函数变量指向go的。 l.DoString() 加载lua脚本，如果我们换一种写法，不在上面这段lua代码套上函数，直接 l.DoString(`local Param = &#123; ['id'] = n,['name'] = 'jyj' &#125; ret = call_service(filePoolService,\"GetUserInfo\",Param) return ret['data']`) 那么其中的lua代码将直接运行，同样会打印出 ‘FilePoolService‘，但是套上function之后，就需要调用它，执行它才能得到结果 l.CallByParam() 执行lua脚本，根据上面说的，使用这个函数就可以调用执行以上lua的’info’函数了，最后再用’l.Get’即可获取到返回值。 L.NewTable() 这里需要注意的是GopherLua程序中的所有数据都是LValue格式的，所以需要将go的基本格式的数据转化成GopherLua中的格式，当然GopherLua提供了全面的转换接口供我们使用，这里的NewTable即lua中的table类型，可以理解为是关联数据类型。 以上就是go Lua的基础使用方法了，具体的逻辑对应着示例代码看，相信很快就能理解了。","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://shuangdeyu.github.io/tags/Go/"},{"name":"lua","slug":"lua","permalink":"https://shuangdeyu.github.io/tags/lua/"}]},{"title":"golang cron定时任务简单实现","slug":"golang cron定时任务简单实现","date":"2019-01-24T16:00:00.000Z","updated":"2023-12-28T02:58:12.304Z","comments":true,"path":"2019/01/25/golang-cron-ding-shi-ren-wu-jian-dan-shi-xian/","link":"","permalink":"https://shuangdeyu.github.io/2019/01/25/golang-cron-ding-shi-ren-wu-jian-dan-shi-xian/","excerpt":"","text":"golang 实现定时服务很简单，只需要简单几步代码便可以完成，不需要配置繁琐的服务器，直接在代码中实现。 使用 https://github.com/robfig/cron 这个包，它实现了 cron 规范解析器和任务运行器。 cron 介绍参见：https://godoc.org/github.com/robfig/cron 用法 注册在指定时间上运行的函数，cron 将会在协程中运行这些注册函数。AddFunc 函数第一个参数指定定时任务时间间隔，第二个参数指定运行函数。 c := cron.New() c.AddFunc(\"0 30 * * * *\", func() &#123; fmt.Println(\"Every hour on the half hour\") &#125;) c.AddFunc(\"@hourly\", func() &#123; fmt.Println(\"Every hour\") &#125;) c.AddFunc(\"@every 1h30m\", func() &#123; fmt.Println(\"Every hour thirty\") &#125;) c.Start() .. // 函数将在它们自己的goroutine中异步调用 ... // 也可以在运行的Cron中添加任务 c.AddFunc(\"@daily\", func() &#123; fmt.Println(\"Every day\") &#125;) .. // 检查cron任务条目的下一个和上一个运行时间 inspect(c.Entries()) .. c.Stop() // 停止定时任务(不停止已经运行的任务) Cron 表达式格式 字段名 是否必须 取值范围 特殊字符串 秒(Seconds) Yes 0-59 * / , - 分(Minutes) Yes 0-59 * / , - 小时(Hours) Yes 0-23 * / , - 一个月中的某一天(Day of month) Yes 1-31 * / , - ? 月(Month) Yes 1-12 or JAN-DEC * / , - 星期几(Day of week) Yes 0-6 or SUN-SAT * / , - ? 注意：月和星期字段值不区分大小写。’SUN’、’Sun’和’sun’都是一样的 特殊字符说明 星号（*） 星号表示cron表达式将匹配该字段的所有值，比如，在上面表达式’月’中使用星号，就表示每个月 斜线（/） 斜杠用于描述范围的增量，比如’3-59/15’这个表达式在表示从现在的第三分钟开始和往后的每15分钟，到第59分钟为止。表现形式为”* \\ / …”，等同于”N-MAX / m”，即在该字段范围内的增量。即从N开始，使用增量 m 直到 MAX 结束，它没有重复 逗号（,） 逗号用于分隔列表中的项，比如，在上表的’星期几’中使用 “MON,WED,FRI” 表示星期一、星期三和星期五 连字符 (-) 连字符用于定义范围。例如，9-17表示包括上午9点至下午5点在内的每小时 问好 (?) 表示不指定值，可以来代替 “*” 预定义的时间格式 您可以使用几个预定义的表达式来代替上表的表达式 输入 描述 等式 @yearly (or @annually) 每年1月1日午夜跑步一次 0 0 0 1 1 * @monthly 每个月第一天的午夜跑一次 0 0 0 1 * * @weekly 每周周六的午夜运行一次 0 0 0 * * 0 @daily (or @midnight) 每天午夜跑一次 0 0 0 * * * @hourly 每小时运行一次 0 0 * * * * 使用说明从github下载cron的包到本地库或者加入道自己的项目中引用都可以，包中有多个测试用例，可以参考它们的用法 代码实现 代码很简单，只要几行即可实现，下面是一个简单使用的示例，说明见代码注释： package main import ( \"demo/cron\" \"log\" \"time\" ) func main() &#123; log.Println(\"Starting...\") // 定义一个cron运行器 c := cron.New() // 定时5秒，每5秒执行print5 c.AddFunc(\"*/5 * * * * *\", print5) // 定时15秒，每5秒执行print5 c.AddFunc(\"*/15 * * * * *\", print15) // 开始 c.Start() defer c.Stop() // 这是一个使用time包实现的定时器，与cron做对比 t1 := time.NewTimer(time.Second * 10) for &#123; select &#123; case &lt;-t1.C: t1.Reset(time.Second * 10) print10() &#125; &#125; &#125; func print5() &#123; log.Println(\"Run 5s cron\") &#125; func print10() &#123; log.Println(\"Run 10s cron\") &#125; func print15() &#123; log.Println(\"Run 15s cron\") &#125; 运行结果 可以看出time包形式的定时器是以程序启动时间为准的，而cron的定时有表达式决定，两者都实现了定时器效果，一般程序中也够用了 以上就是基于golang的cron的基本使用了","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://shuangdeyu.github.io/tags/Go/"},{"name":"cron","slug":"cron","permalink":"https://shuangdeyu.github.io/tags/cron/"}]},{"title":"我是从什么时候开始变宅的","slug":"我是从什么时候开始变宅的","date":"2018-09-04T16:00:00.000Z","updated":"2023-12-22T08:26:04.962Z","comments":true,"path":"2018/09/05/wo-shi-cong-shi-me-shi-hou-kai-shi-bian-zhai-de/","link":"","permalink":"https://shuangdeyu.github.io/2018/09/05/wo-shi-cong-shi-me-shi-hou-kai-shi-bian-zhai-de/","excerpt":"","text":"宅这个词有多种解释，表面上理解就是不与人接触整天窝在家里，往深了讲是专注精神追求，享受私人空间，不管作何解释，有一点是不变的，那就是足不出户。宅不是一个贬义词，但很多人宅着宅着就废了，我想我是其中之一。 我是从什么时候开始变宅的？ 冒出这个问题的起因是我今天回了一趟老家（一个山水远远多于瓦砾的小县城，好久没回去了），突然发现我已经很久没有走出去欣赏外面的世界了，于是我想着想着就想了很多，从经历、年龄、性格、心态、工作等，各方面的都有，最后还是没有得出一个答案，不过我觉得这个答案根本无关紧要，没人会关心我是什么时候开始变宅的，我也不关心，真正重要的是我从这个问题出发回顾思考了我从大学甚至是小时候到现在的一些经历，并得出一些结论以及其它方面的答案，我想很多人忙着珍惜当下和着眼未来的时候往往忽视了曾经吧，我觉得曾经是人生中最宝贵的财富之一，不管它是好是差。 回不去的童年庆幸我的童年留在了老家，和大多数人一样，小时候的我总是精力充沛，不怕热，不怕冷，夏天捕蝉抓鱼，冬天玩雪爬山，野性十足，抓过蛇，打过鸟，追着兔子跑，赤溜溜去小溪里游泳，挖地里的草根啃出来甜甜的汁，跟弟弟装冒险家捡个精致的石头当宝物，等等等等，这山水，这天地就是我们的游乐园，至今我们都没有将所有项目都玩过一遍。因为深刻，所以难忘，这段童年的细节我是记得如此的清晰，这或许就是最美的童年记忆吧，小的时候总是有探索不完的事物，也有一颗停不下来探索的心。 来到山外山外是我们那边的土话，意思就是离开家乡，小时候总是读不懂文章里作者的思乡之情，现在我觉得我是懂的，从十三岁离开家乡到如今，一晃十四载，有些年没回家，有些年只回家过个年，往往都是来去匆匆，可能往后很长一段时间里，乡愁都会伴随我左右。初来外地，一切都是陌生的，不过那时候还是个孩子，小孩跟小孩玩在一起倒也挺快，纯真的年纪里总是很容易交到志同道合的朋友，往后的初中三年，我跟新交的朋友们闯荡了镇上的角角落落，池塘里钓龙虾，蹲在书店里看漫画，偷偷去游戏厅打拳皇，去黑网吧上网，一台Gameboy轮流玩，漫无目的地闲逛……青春如此迷人就是因为在这段时间里发生的事情往往美好得真实而又梦幻，没有太多压力，只有到处释放的精力，身上没有镣铐，天大地大，由我们尽情玩耍。 真正开始拥有烦恼，迫不得已的时候，我想是从高中开始的吧，烦恼也是这时候的青春主旋律之一。虽然我承认高考是一个必不可少的筛选机制，但我也想说这个机制对少年的天性压抑得何其厉害，万般冲劲就这样被囚禁在校园与题海之中，有人将这股冲劲转移到了学习之上，也有人无处转移最后名落孙山，也是从这时候开始，我探索的步伐一下子止步不前，因为四面都是围墙，我的脚步被禁锢在课桌底下移动不了分毫，再加上当时又搬了家，环境所致没有离得近的同学朋友，而且地处偏僻，周末回家也是无处所去，所以，我的第一次宅就是从那时候开始的，既没有在知识的海洋中遨游，也没有在现实世界中探索。 成人世界就我自己的经历来说，我最有冲劲的时候就是小时候到初中那段时间，大学初那会可能是一下子从高考的压抑中解脱的缘故，我骑着室友的小自行车“走南闯北”，风驰电掣，摸清了学校周边的条条道道，心血来潮之时，往往一个人骑车乱逛，我知道，那时候我的探索欲望又回来了，多么久违啊。可是好景不长，不知道从什么时候开始，我也跟别人一样宅起了寝室，点起了外卖，真的是不知不觉就这样了，懒了一段时间之后就再也爬不起来。 宅着宅着就宅到了毕业，奇怪的是刚工作的时候又想着走出去。经济独立了之后，想着终于有钱可以去那些以前不敢去的地方了，于是买了相机，一个人去西湖拍夜景，小长假一个人报团去户外徒步爬山，可是这点小动作对于我心中的诗和远方来说着实是隔靴挠痒，然而由于经济实力的限制，我终究还是鼓不起勇气去那远方圆一个诗意的梦，或许是越来越觉得这个梦难以实现了吧，后来相机卖了，脑子也不想了，又当起了宅男，宅着宅着就废了。 慢慢的工作忙起来了，假变少了，就更不愿意出门，周末呆在房间里看剧睡觉，啥也不想，别提有多爽，在这个本来应该铆足了劲奋斗的年纪，我却选择了颓废，可常常在心里又一遍一遍的告诉自己你应该抓紧每一分每一秒努力学习，两相矛盾之下，废得不自在，学得不专心，思维也渐渐麻木，时间就这样在我的茫然中悄悄流逝。 宅而不废今天这次回老家是我一年来的第一次，停留仅仅只有两个多小时，又不得不回到山外，因为明天还要上班。年纪上来了就容易想多，见景生情，迸发的思绪万千，我曾是少年，探索于这天地，有梦有冲劲，然而现在却活成了行尸走肉，回过神来惊出一身冷汗。 可以宅但不要废，虽说以上说的都是空间上的探索，但你我明白探索又何止于如此，探索知识，探索思想，探索方法，万般皆探索，在有限的生命里探索无限的可能，才能对得起曾经少年，对得起有幸来到这世上，不辜负良辰美景，不辜负他人，不辜负自己。 凑巧的是写这篇文章期间听到了《你曾是少年》这首歌，或许这就是冥冥天意，让我如梦方醒，往后余生要做的事情太多了，此时不醒更待何时。 ……你我来自湖北四川广西宁夏河南山东贵州云南的小镇乡村曾经发誓 要做了不起的人却在北京上海广州深圳某天夜半忽然醒来 像被命运叫醒了它说你不能就这样过完一生许多年前 你有一双清澈的双眼奔跑起来 像是一道春天的闪电想看遍这世界 去最遥远的远方感觉有双翅膀 能飞越高山和海洋……","categories":[{"name":"闲谈","slug":"闲谈","permalink":"https://shuangdeyu.github.io/categories/%E9%97%B2%E8%B0%88/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://shuangdeyu.github.io/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"Gin框架中文文档","slug":"Gin框架中文文档","date":"2018-06-07T16:00:00.000Z","updated":"2023-12-22T08:31:59.381Z","comments":true,"path":"2018/06/08/gin-kuang-jia-zhong-wen-wen-dang/","link":"","permalink":"https://shuangdeyu.github.io/2018/06/08/gin-kuang-jia-zhong-wen-wen-dang/","excerpt":"","text":"最近更新时间：2019-02-20 另附看云地址 Gin 是一个 go 写的 web 框架，具有高性能的优点。官方地址：https://github.com/gin-gonic/gin 目录 安装要安装Gin包，首先需要安装Go并设置Go工作区 1、下载并安装 $ go get -u github.com/gin-gonic/gin 2、在代码中导入它 import “github.com/gin-gonic/gin” 使用包管理工具Govendor安装 1、go get govendor(安装) $ go get github.com/kardianos/govendor 2、创建项目文件夹并进入文件夹 $ mkdir -p $GOPATH/src/github.com/myusername/project &amp;&amp; cd “$_” 3、初始化项目并添加 gin $ govendor init $ govendor fetch github.com/gin-gonic/gin@v1.3 4、复制一个模板到你的项目 $ curl https://raw.githubusercontent.com/gin-gonic/gin/master/examples/basic/main.go &gt; main.go 5、运行项目 $ go run main.go 前提使用gin需要Go的版本号为1.6或更高 快速入门运行这段代码并在浏览器中访问 http://localhost:8080 package main import \"github.com/gin-gonic/gin\" func main() &#123; r := gin.Default() r.GET(\"/ping\", func(c *gin.Context) &#123; c.JSON(200, gin.H&#123; \"message\": \"pong\", &#125;) &#125;) r.Run() // listen and serve on 0.0.0.0:8080 &#125; 代码示例使用 GET, POST, PUT, PATCH, DELETE, OPTIONSfunc main() &#123; // Disable Console Color // gin.DisableConsoleColor() // 使用默认中间件创建一个gin路由器 // logger and recovery (crash-free) 中间件 router := gin.Default() router.GET(\"/someGet\", getting) router.POST(\"/somePost\", posting) router.PUT(\"/somePut\", putting) router.DELETE(\"/someDelete\", deleting) router.PATCH(\"/somePatch\", patching) router.HEAD(\"/someHead\", head) router.OPTIONS(\"/someOptions\", options) // 默认启动的是 8080端口，也可以自己定义启动端口 router.Run() // router.Run(\":3000\") for a hard coded port &#125; 获取路径中的参数func main() &#123; router := gin.Default() // 此规则能够匹配/user/john这种格式，但不能匹配/user/ 或 /user这种格式 router.GET(\"/user/:name\", func(c *gin.Context) &#123; name := c.Param(\"name\") c.String(http.StatusOK, \"Hello %s\", name) &#125;) // 但是，这个规则既能匹配/user/john/格式也能匹配/user/john/send这种格式 // 如果没有其他路由器匹配/user/john，它将重定向到/user/john/ router.GET(\"/user/:name/*action\", func(c *gin.Context) &#123; name := c.Param(\"name\") action := c.Param(\"action\") message := name + \" is \" + action c.String(http.StatusOK, message) &#125;) router.Run(\":8080\") &#125; 获取Get参数func main() &#123; router := gin.Default() // 匹配的url格式: /welcome?firstname=Jane&amp;lastname=Doe router.GET(\"/welcome\", func(c *gin.Context) &#123; firstname := c.DefaultQuery(\"firstname\", \"Guest\") lastname := c.Query(\"lastname\") // 是 c.Request.URL.Query().Get(\"lastname\") 的简写 c.String(http.StatusOK, \"Hello %s %s\", firstname, lastname) &#125;) router.Run(\":8080\") &#125; 获取Post参数func main() &#123; router := gin.Default() router.POST(\"/form_post\", func(c *gin.Context) &#123; message := c.PostForm(\"message\") nick := c.DefaultPostForm(\"nick\", \"anonymous\") // 此方法可以设置默认值 c.JSON(200, gin.H&#123; \"status\": \"posted\", \"message\": message, \"nick\": nick, &#125;) &#125;) router.Run(\":8080\") &#125; Get + Post 混合示例： POST /post?id=1234&amp;page=1 HTTP/1.1 Content-Type: application/x-www-form-urlencoded name=manu&amp;message=this_is_great func main() &#123; router := gin.Default() router.POST(\"/post\", func(c *gin.Context) &#123; id := c.Query(\"id\") page := c.DefaultQuery(\"page\", \"0\") name := c.PostForm(\"name\") message := c.PostForm(\"message\") fmt.Printf(\"id: %s; page: %s; name: %s; message: %s\", id, page, name, message) &#125;) router.Run(\":8080\") &#125; 结果：id: 1234; page: 1; name: manu; message: this_is_great 上传文件单文件上传参考问题 #774，细节 example code 慎用 file.Filename ，参考 Content-Disposition on MDN 和 #1693 上传文件的文件名可以由用户自定义，所以可能包含非法字符串，为了安全起见，应该由服务端统一文件名规则 func main() &#123; router := gin.Default() // 给表单限制上传大小 (默认 32 MiB) // router.MaxMultipartMemory = 8 &lt;&lt; 20 // 8 MiB router.POST(\"/upload\", func(c *gin.Context) &#123; // 单文件 file, _ := c.FormFile(\"file\") log.Println(file.Filename) // 上传文件到指定的路径 // c.SaveUploadedFile(file, dst) c.String(http.StatusOK, fmt.Sprintf(\"'%s' uploaded!\", file.Filename)) &#125;) router.Run(\":8080\") &#125; curl 测试： curl -X POST http://localhost:8080/upload \\ -F \"file=@/Users/appleboy/test.zip\" \\ -H \"Content-Type: multipart/form-data\" 多文件上传详细示例：example code func main() &#123; router := gin.Default() // 给表单限制上传大小 (默认 32 MiB) // router.MaxMultipartMemory = 8 &lt;&lt; 20 // 8 MiB router.POST(\"/upload\", func(c *gin.Context) &#123; // 多文件 form, _ := c.MultipartForm() files := form.File[\"upload[]\"] for _, file := range files &#123; log.Println(file.Filename) // 上传文件到指定的路径 // c.SaveUploadedFile(file, dst) &#125; c.String(http.StatusOK, fmt.Sprintf(\"%d files uploaded!\", len(files))) &#125;) router.Run(\":8080\") &#125; curl 测试： curl -X POST http://localhost:8080/upload \\ -F \"upload[]=@/Users/appleboy/test1.zip\" \\ -F \"upload[]=@/Users/appleboy/test2.zip\" \\ -H \"Content-Type: multipart/form-data\" 路由分组func main() &#123; router := gin.Default() // Simple group: v1 v1 := router.Group(\"/v1\") &#123; v1.POST(\"/login\", loginEndpoint) v1.POST(\"/submit\", submitEndpoint) v1.POST(\"/read\", readEndpoint) &#125; // Simple group: v2 v2 := router.Group(\"/v2\") &#123; v2.POST(\"/login\", loginEndpoint) v2.POST(\"/submit\", submitEndpoint) v2.POST(\"/read\", readEndpoint) &#125; router.Run(\":8080\") &#125; 无中间件启动使用 r := gin.New() 代替 // 默认启动方式，包含 Logger、Recovery 中间件 r := gin.Default() 使用中间件func main() &#123; // 创建一个不包含中间件的路由器 r := gin.New() // 全局中间件 // 使用 Logger 中间件 r.Use(gin.Logger()) // 使用 Recovery 中间件 r.Use(gin.Recovery()) // 路由添加中间件，可以添加任意多个 r.GET(\"/benchmark\", MyBenchLogger(), benchEndpoint) // 路由组中添加中间件 // authorized := r.Group(\"/\", AuthRequired()) // exactly the same as: authorized := r.Group(\"/\") // per group middleware! in this case we use the custom created // AuthRequired() middleware just in the \"authorized\" group. authorized.Use(AuthRequired()) &#123; authorized.POST(\"/login\", loginEndpoint) authorized.POST(\"/submit\", submitEndpoint) authorized.POST(\"/read\", readEndpoint) // nested group testing := authorized.Group(\"testing\") testing.GET(\"/analytics\", analyticsEndpoint) &#125; // Listen and serve on 0.0.0.0:8080 r.Run(\":8080\") &#125; 写日志文件func main() &#123; // 禁用控制台颜色 gin.DisableConsoleColor() // 创建记录日志的文件 f, _ := os.Create(\"gin.log\") gin.DefaultWriter = io.MultiWriter(f) // 如果需要将日志同时写入文件和控制台，请使用以下代码 // gin.DefaultWriter = io.MultiWriter(f, os.Stdout) router := gin.Default() router.GET(\"/ping\", func(c *gin.Context) &#123; c.String(200, \"pong\") &#125;) router.Run(\":8080\") &#125; 自定义日志格式func main() &#123; router := gin.New() // LoggerWithFormatter 中间件会将日志写入 gin.DefaultWriter // By default gin.DefaultWriter = os.Stdout router.Use(gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string &#123; // 你的自定义格式 return fmt.Sprintf(\"%s - [%s] \\\"%s %s %s %d %s \\\"%s\\\" %s\\\"\\n\", param.ClientIP, param.TimeStamp.Format(time.RFC1123), param.Method, param.Path, param.Request.Proto, param.StatusCode, param.Latency, param.Request.UserAgent(), param.ErrorMessage, ) &#125;)) router.Use(gin.Recovery()) router.GET(\"/ping\", func(c *gin.Context) &#123; c.String(200, \"pong\") &#125;) router.Run(\":8080\") &#125; 输出示例： ::1 - [Fri, 07 Dec 2018 17:04:38 JST] &quot;GET &#x2F;ping HTTP&#x2F;1.1 200 122.767µs &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.80 Safari&#x2F;537.36&quot; &quot; 模型绑定和验证若要将请求主体绑定到结构体中，请使用模型绑定，目前支持JSON、XML、YAML和标准表单值(foo=bar&amp;boo=baz)的绑定。 Gin使用 go-playground/validator.v8 验证参数，查看完整文档。 需要在绑定的字段上设置tag，比如，绑定格式为json，需要这样设置 json:&quot;fieldname&quot; 。 此外，Gin还提供了两套绑定方法： Must bind Methods - Bind, BindJSON, BindXML, BindQuery, BindYAML Behavior - 这些方法底层使用 MustBindWith，如果存在绑定错误，请求将被以下指令中止 c.AbortWithError(400, err).SetType(ErrorTypeBind)，响应状态代码会被设置为400，请求头Content-Type被设置为text/plain; charset=utf-8。注意，如果你试图在此之后设置响应代码，将会发出一个警告 [GIN-debug] [WARNING] Headers were already written. Wanted to override status code 400 with 422，如果你希望更好地控制行为，请使用ShouldBind相关的方法 Should bind Methods - ShouldBind, ShouldBindJSON, ShouldBindXML, ShouldBindQuery, ShouldBindYAML Behavior - 这些方法底层使用 ShouldBindWith，如果存在绑定错误，则返回错误，开发人员可以正确处理请求和错误。 当我们使用绑定方法时，Gin会根据Content-Type推断出使用哪种绑定器，如果你确定你绑定的是什么，你可以使用MustBindWith或者BindingWith。 你还可以给字段指定特定规则的修饰符，如果一个字段用binding:&quot;required&quot;修饰，并且在绑定时该字段的值为空，那么将返回一个错误。 // 绑定为json type Login struct &#123; User string `form:\"user\" json:\"user\" xml:\"user\" binding:\"required\"` Password string `form:\"password\" json:\"password\" xml:\"password\" binding:\"required\"` &#125; func main() &#123; router := gin.Default() // Example for binding JSON (&#123;\"user\": \"manu\", \"password\": \"123\"&#125;) router.POST(\"/loginJSON\", func(c *gin.Context) &#123; var json Login if err := c.ShouldBindJSON(&amp;json); err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;\"error\": err.Error()&#125;) return &#125; if json.User != \"manu\" || json.Password != \"123\" &#123; c.JSON(http.StatusUnauthorized, gin.H&#123;\"status\": \"unauthorized\"&#125;) return &#125; c.JSON(http.StatusOK, gin.H&#123;\"status\": \"you are logged in\"&#125;) &#125;) // Example for binding XML ( // &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> // &lt;root> // &lt;user>user&lt;/user> // &lt;password>123&lt;/password> // &lt;/root>) router.POST(\"/loginXML\", func(c *gin.Context) &#123; var xml Login if err := c.ShouldBindXML(&amp;xml); err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;\"error\": err.Error()&#125;) return &#125; if xml.User != \"manu\" || xml.Password != \"123\" &#123; c.JSON(http.StatusUnauthorized, gin.H&#123;\"status\": \"unauthorized\"&#125;) return &#125; c.JSON(http.StatusOK, gin.H&#123;\"status\": \"you are logged in\"&#125;) &#125;) // Example for binding a HTML form (user=manu&amp;password=123) router.POST(\"/loginForm\", func(c *gin.Context) &#123; var form Login // This will infer what binder to use depending on the content-type header. if err := c.ShouldBind(&amp;form); err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;\"error\": err.Error()&#125;) return &#125; if form.User != \"manu\" || form.Password != \"123\" &#123; c.JSON(http.StatusUnauthorized, gin.H&#123;\"status\": \"unauthorized\"&#125;) return &#125; c.JSON(http.StatusOK, gin.H&#123;\"status\": \"you are logged in\"&#125;) &#125;) // Listen and serve on 0.0.0.0:8080 router.Run(\":8080\") &#125; 请求示例： $ curl -v -X POST \\ http://localhost:8080/loginJSON \\ -H 'content-type: application/json' \\ -d '&#123; \"user\": \"manu\" &#125;' > POST /loginJSON HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.51.0 > Accept: */* > content-type: application/json > Content-Length: 18 > * upload completely sent off: 18 out of 18 bytes &lt; HTTP/1.1 400 Bad Request &lt; Content-Type: application/json; charset=utf-8 &lt; Date: Fri, 04 Aug 2017 03:51:31 GMT &lt; Content-Length: 100 &lt; &#123;\"error\":\"Key: 'Login.Password' Error:Field validation for 'Password' failed on the 'required' tag\"&#125; 跳过验证： 当使用上面的curl命令运行上面的示例时，返回错误，因为示例中Password字段使用了binding:&quot;required&quot;，如果我们使用binding:&quot;-&quot;，那么它就不会报错。 自定义验证器Gin允许我们自定义参数验证器，参考1，参考2，参考3 package main import ( \"net/http\" \"reflect\" \"time\" \"github.com/gin-gonic/gin\" \"github.com/gin-gonic/gin/binding\" \"gopkg.in/go-playground/validator.v8\" ) // Booking contains binded and validated data. type Booking struct &#123; CheckIn time.Time `form:\"check_in\" binding:\"required,bookabledate\" time_format:\"2006-01-02\"` CheckOut time.Time `form:\"check_out\" binding:\"required,gtfield=CheckIn\" time_format:\"2006-01-02\"` &#125; func bookableDate( v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value, field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param string, ) bool &#123; if date, ok := field.Interface().(time.Time); ok &#123; today := time.Now() if today.Year() > date.Year() || today.YearDay() > date.YearDay() &#123; return false &#125; &#125; return true &#125; func main() &#123; route := gin.Default() if v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123; v.RegisterValidation(\"bookabledate\", bookableDate) &#125; route.GET(\"/bookable\", getBookable) route.Run(\":8085\") &#125; func getBookable(c *gin.Context) &#123; var b Booking if err := c.ShouldBindWith(&amp;b, binding.Query); err == nil &#123; c.JSON(http.StatusOK, gin.H&#123;\"message\": \"Booking dates are valid!\"&#125;) &#125; else &#123; c.JSON(http.StatusBadRequest, gin.H&#123;\"error\": err.Error()&#125;) &#125; &#125; $ curl \"localhost:8085/bookable?check_in=2018-04-16&amp;check_out=2018-04-17\" &#123;\"message\":\"Booking dates are valid!\"&#125; $ curl \"localhost:8085/bookable?check_in=2018-03-08&amp;check_out=2018-03-09\" &#123;\"error\":\"Key: 'Booking.CheckIn' Error:Field validation for 'CheckIn' failed on the 'bookabledate' tag\"&#125; 只绑定Get参数ShouldBindQuery 函数只绑定Get参数，不绑定post数据，查看详细信息 package main import ( \"log\" \"github.com/gin-gonic/gin\" ) type Person struct &#123; Name string `form:\"name\"` Address string `form:\"address\"` &#125; func main() &#123; route := gin.Default() route.Any(\"/testing\", startPage) route.Run(\":8085\") &#125; func startPage(c *gin.Context) &#123; var person Person if c.ShouldBindQuery(&amp;person) == nil &#123; log.Println(\"====== Only Bind By Query String ======\") log.Println(person.Name) log.Println(person.Address) &#125; c.String(200, \"Success\") &#125; 绑定Get参数或者Post参数查看详细信息，这个例子很有用，可以自己实践一下 package main import ( \"log\" \"time\" \"github.com/gin-gonic/gin\" ) type Person struct &#123; Name string `form:\"name\"` Address string `form:\"address\"` Birthday time.Time `form:\"birthday\" time_format:\"2006-01-02\" time_utc:\"1\"` &#125; func main() &#123; route := gin.Default() route.GET(\"/testing\", startPage) route.Run(\":8085\") &#125; func startPage(c *gin.Context) &#123; var person Person // If `GET`, only `Form` binding engine (`query`) used. // 如果是Get，那么接收不到请求中的Post的数据？？ // 如果是Post, 首先判断 `content-type` 的类型 `JSON` or `XML`, 然后使用对应的绑定器获取数据. // See more at https://github.com/gin-gonic/gin/blob/master/binding/binding.go#L48 if c.ShouldBind(&amp;person) == nil &#123; log.Println(person.Name) log.Println(person.Address) log.Println(person.Birthday) &#125; c.String(200, \"Success\") &#125; 绑定uri查看详细信息 package main import \"github.com/gin-gonic/gin\" type Person struct &#123; ID string `uri:\"id\" binding:\"required,uuid\"` Name string `uri:\"name\" binding:\"required\"` &#125; func main() &#123; route := gin.Default() route.GET(\"/:name/:id\", func(c *gin.Context) &#123; var person Person if err := c.ShouldBindUri(&amp;person); err != nil &#123; c.JSON(400, gin.H&#123;\"msg\": err&#125;) return &#125; c.JSON(200, gin.H&#123;\"name\": person.Name, \"uuid\": person.ID&#125;) &#125;) route.Run(\":8088\") &#125; 测试用例： $ curl -v localhost:8088/thinkerou/987fbc97-4bed-5078-9f07-9141ba07c9f3 $ curl -v localhost:8088/thinkerou/not-uuid 绑定HTML复选框查看详细信息 main.go ... type myForm struct &#123; Colors []string `form:\"colors[]\"` &#125; ... func formHandler(c *gin.Context) &#123; var fakeForm myForm c.ShouldBind(&amp;fakeForm) c.JSON(200, gin.H&#123;\"color\": fakeForm.Colors&#125;) &#125; ... form.html &lt;form action=\"/\" method=\"POST\"> &lt;p>Check some colors&lt;/p> &lt;label for=\"red\">Red&lt;/label> &lt;input type=\"checkbox\" name=\"colors[]\" value=\"red\" id=\"red\"> &lt;label for=\"green\">Green&lt;/label> &lt;input type=\"checkbox\" name=\"colors[]\" value=\"green\" id=\"green\"> &lt;label for=\"blue\">Blue&lt;/label> &lt;input type=\"checkbox\" name=\"colors[]\" value=\"blue\" id=\"blue\"> &lt;input type=\"submit\"> &lt;/form> result: &#123;\"color\":[\"red\",\"green\",\"blue\"]&#125; 绑定Post参数package main import ( \"github.com/gin-gonic/gin\" ) type LoginForm struct &#123; User string `form:\"user\" binding:\"required\"` Password string `form:\"password\" binding:\"required\"` &#125; func main() &#123; router := gin.Default() router.POST(\"/login\", func(c *gin.Context) &#123; // you can bind multipart form with explicit binding declaration: // c.ShouldBindWith(&amp;form, binding.Form) // or you can simply use autobinding with ShouldBind method: var form LoginForm // in this case proper binding will be automatically selected if c.ShouldBind(&amp;form) == nil &#123; if form.User == \"user\" &amp;&amp; form.Password == \"password\" &#123; c.JSON(200, gin.H&#123;\"status\": \"you are logged in\"&#125;) &#125; else &#123; c.JSON(401, gin.H&#123;\"status\": \"unauthorized\"&#125;) &#125; &#125; &#125;) router.Run(\":8080\") &#125; 测试用例： $ curl -v --form user=user --form password=password http://localhost:8080/login XML、JSON、YAML和ProtoBuf 渲染（输出格式）即接口返回的数据格式 func main() &#123; r := gin.Default() // gin.H is a shortcut for map[string]interface&#123;&#125; r.GET(\"/someJSON\", func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123;\"message\": \"hey\", \"status\": http.StatusOK&#125;) &#125;) r.GET(\"/moreJSON\", func(c *gin.Context) &#123; // You also can use a struct var msg struct &#123; Name string `json:\"user\"` Message string Number int &#125; msg.Name = \"Lena\" msg.Message = \"hey\" msg.Number = 123 // Note that msg.Name becomes \"user\" in the JSON // Will output : &#123;\"user\": \"Lena\", \"Message\": \"hey\", \"Number\": 123&#125; c.JSON(http.StatusOK, msg) &#125;) r.GET(\"/someXML\", func(c *gin.Context) &#123; c.XML(http.StatusOK, gin.H&#123;\"message\": \"hey\", \"status\": http.StatusOK&#125;) &#125;) r.GET(\"/someYAML\", func(c *gin.Context) &#123; c.YAML(http.StatusOK, gin.H&#123;\"message\": \"hey\", \"status\": http.StatusOK&#125;) &#125;) r.GET(\"/someProtoBuf\", func(c *gin.Context) &#123; reps := []int64&#123;int64(1), int64(2)&#125; label := \"test\" // The specific definition of protobuf is written in the testdata/protoexample file. data := &amp;protoexample.Test&#123; Label: &amp;label, Reps: reps, &#125; // Note that data becomes binary data in the response // Will output protoexample.Test protobuf serialized data c.ProtoBuf(http.StatusOK, data) &#125;) // Listen and serve on 0.0.0.0:8080 r.Run(\":8080\") &#125; SecureJSON 使用SecureJSON可以防止json劫持，如果返回的数据是数组，则会默认在返回值前加上&quot;while(1)&quot; func main() &#123; r := gin.Default() // 可以自定义返回的json数据前缀 // r.SecureJsonPrefix(\")]&#125;',\\n\") r.GET(\"/someJSON\", func(c *gin.Context) &#123; names := []string&#123;\"lena\", \"austin\", \"foo\"&#125; // 将会输出: while(1);[\"lena\",\"austin\",\"foo\"] c.SecureJSON(http.StatusOK, names) &#125;) // Listen and serve on 0.0.0.0:8080 r.Run(\":8080\") &#125; JSONP 使用JSONP可以跨域传输，如果参数中存在回调参数，那么返回的参数将是回调函数的形式 func main() &#123; r := gin.Default() r.GET(\"/JSONP\", func(c *gin.Context) &#123; data := map[string]interface&#123;&#125;&#123; \"foo\": \"bar\", &#125; // 访问 http://localhost:8080/JSONP?callback=call // 将会输出: call(&#123;foo:\"bar\"&#125;) c.JSONP(http.StatusOK, data) &#125;) // Listen and serve on 0.0.0.0:8080 r.Run(\":8080\") &#125; AsciiJSON 使用AsciiJSON将使特殊字符编码 func main() &#123; r := gin.Default() r.GET(\"/someJSON\", func(c *gin.Context) &#123; data := map[string]interface&#123;&#125;&#123; \"lang\": \"GO语言\", \"tag\": \"&lt;br>\", &#125; // 将输出: &#123;\"lang\":\"GO\\u8bed\\u8a00\",\"tag\":\"\\u003cbr\\u003e\"&#125; c.AsciiJSON(http.StatusOK, data) &#125;) // Listen and serve on 0.0.0.0:8080 r.Run(\":8080\") &#125; PureJSON 通常情况下，JSON会将特殊的HTML字符替换为对应的unicode字符，比如&lt;替换为\\u003c，如果想原样输出html，则使用PureJSON，这个特性在Go 1.6及以下版本中无法使用。 func main() &#123; r := gin.Default() // Serves unicode entities r.GET(\"/json\", func(c *gin.Context) &#123; c.JSON(200, gin.H&#123; \"html\": \"&lt;b>Hello, world!&lt;/b>\", &#125;) &#125;) // Serves literal characters r.GET(\"/purejson\", func(c *gin.Context) &#123; c.PureJSON(200, gin.H&#123; \"html\": \"&lt;b>Hello, world!&lt;/b>\", &#125;) &#125;) // listen and serve on 0.0.0.0:8080 r.Run(\":8080\") &#125; 设置静态文件路径访问静态文件需要先设置路径 func main() &#123; router := gin.Default() router.Static(\"/assets\", \"./assets\") router.StaticFS(\"/more_static\", http.Dir(\"my_file_system\")) router.StaticFile(\"/favicon.ico\", \"./resources/favicon.ico\") // Listen and serve on 0.0.0.0:8080 router.Run(\":8080\") &#125; 返回第三方获取的数据func main() &#123; router := gin.Default() router.GET(\"/someDataFromReader\", func(c *gin.Context) &#123; response, err := http.Get(\"https://raw.githubusercontent.com/gin-gonic/logo/master/color.png\") if err != nil || response.StatusCode != http.StatusOK &#123; c.Status(http.StatusServiceUnavailable) return &#125; reader := response.Body contentLength := response.ContentLength contentType := response.Header.Get(\"Content-Type\") extraHeaders := map[string]string&#123; \"Content-Disposition\": `attachment; filename=\"gopher.png\"`, &#125; c.DataFromReader(http.StatusOK, contentLength, contentType, reader, extraHeaders) &#125;) router.Run(\":8080\") &#125; HTML渲染使用LoadHTMLGlob() 或者 LoadHTMLFiles() func main() &#123; router := gin.Default() router.LoadHTMLGlob(\"templates/*\") //router.LoadHTMLFiles(\"templates/template1.html\", \"templates/template2.html\") router.GET(\"/index\", func(c *gin.Context) &#123; c.HTML(http.StatusOK, \"index.tmpl\", gin.H&#123; \"title\": \"Main website\", &#125;) &#125;) router.Run(\":8080\") &#125; templates/index.tmpl &lt;html> &lt;h1> &#123;&#123; .title &#125;&#125; &lt;/h1> &lt;/html> 在不同目录中使用具有相同名称的模板 func main() &#123; router := gin.Default() router.LoadHTMLGlob(\"templates/**/*\") router.GET(\"/posts/index\", func(c *gin.Context) &#123; c.HTML(http.StatusOK, \"posts/index.tmpl\", gin.H&#123; \"title\": \"Posts\", &#125;) &#125;) router.GET(\"/users/index\", func(c *gin.Context) &#123; c.HTML(http.StatusOK, \"users/index.tmpl\", gin.H&#123; \"title\": \"Users\", &#125;) &#125;) router.Run(\":8080\") &#125; templates/posts/index.tmpl &#123;&#123; define \"posts/index.tmpl\" &#125;&#125; &lt;html>&lt;h1> &#123;&#123; .title &#125;&#125; &lt;/h1> &lt;p>Using posts/index.tmpl&lt;/p> &lt;/html> &#123;&#123; end &#125;&#125; templates/users/index.tmpl &#123;&#123; define \"users/index.tmpl\" &#125;&#125; &lt;html>&lt;h1> &#123;&#123; .title &#125;&#125; &lt;/h1> &lt;p>Using users/index.tmpl&lt;/p> &lt;/html> &#123;&#123; end &#125;&#125; 自定义模板渲染器 import \"html/template\" func main() &#123; router := gin.Default() html := template.Must(template.ParseFiles(\"file1\", \"file2\")) router.SetHTMLTemplate(html) router.Run(\":8080\") &#125; 自定义渲染分隔符 r := gin.Default() r.Delims(\"&#123;[&#123;\", \"&#125;]&#125;\") r.LoadHTMLGlob(\"/path/to/templates\") 自定义模板函数 详细信息 main.go import ( \"fmt\" \"html/template\" \"net/http\" \"time\" \"github.com/gin-gonic/gin\" ) func formatAsDate(t time.Time) string &#123; year, month, day := t.Date() return fmt.Sprintf(\"%d%02d/%02d\", year, month, day) &#125; func main() &#123; router := gin.Default() router.Delims(\"&#123;[&#123;\", \"&#125;]&#125;\") router.SetFuncMap(template.FuncMap&#123; \"formatAsDate\": formatAsDate, &#125;) router.LoadHTMLFiles(\"./testdata/template/raw.tmpl\") router.GET(\"/raw\", func(c *gin.Context) &#123; c.HTML(http.StatusOK, \"raw.tmpl\", map[string]interface&#123;&#125;&#123; \"now\": time.Date(2017, 07, 01, 0, 0, 0, 0, time.UTC), &#125;) &#125;) router.Run(\":8080\") &#125; raw.tmpl 然后就可以在html中直接使用formatAsDate函数了 Date: &#123;[&#123;.now | formatAsDate&#125;]&#125; Result: Date: 2017&#x2F;07&#x2F;01 多个模板文件Gin默认情况下只允许使用一个html模板文件（即一次可以加载多个模板文件），点击这里查看实现案例 重定向发布HTTP重定向很容易，支持内部和外部链接 r.GET(\"/test\", func(c *gin.Context) &#123; c.Redirect(http.StatusMovedPermanently, \"http://www.google.com/\") &#125;) Gin路由重定向，使用如下的HandleContext r.GET(\"/test\", func(c *gin.Context) &#123; c.Request.URL.Path = \"/test2\" r.HandleContext(c) &#125;) r.GET(\"/test2\", func(c *gin.Context) &#123; c.JSON(200, gin.H&#123;\"hello\": \"world\"&#125;) &#125;) 自定义中间件func Logger() gin.HandlerFunc &#123; return func(c *gin.Context) &#123; t := time.Now() // Set example variable c.Set(\"example\", \"12345\") // before request c.Next() // after request latency := time.Since(t) log.Print(latency) // access the status we are sending status := c.Writer.Status() log.Println(status) &#125; &#125; func main() &#123; r := gin.New() r.Use(Logger()) r.GET(\"/test\", func(c *gin.Context) &#123; example := c.MustGet(\"example\").(string) // it would print: \"12345\" log.Println(example) &#125;) // Listen and serve on 0.0.0.0:8080 r.Run(\":8080\") &#125; 使用BasicAuth()（验证）中间件// simulate some private data var secrets = gin.H&#123; \"foo\": gin.H&#123;\"email\": \"foo@bar.com\", \"phone\": \"123433\"&#125;, \"austin\": gin.H&#123;\"email\": \"austin@example.com\", \"phone\": \"666\"&#125;, \"lena\": gin.H&#123;\"email\": \"lena@guapa.com\", \"phone\": \"523443\"&#125;, &#125; func main() &#123; r := gin.Default() // Group using gin.BasicAuth() middleware // gin.Accounts is a shortcut for map[string]string authorized := r.Group(\"/admin\", gin.BasicAuth(gin.Accounts&#123; \"foo\": \"bar\", \"austin\": \"1234\", \"lena\": \"hello2\", \"manu\": \"4321\", &#125;)) // /admin/secrets endpoint // hit \"localhost:8080/admin/secrets authorized.GET(\"/secrets\", func(c *gin.Context) &#123; // get user, it was set by the BasicAuth middleware user := c.MustGet(gin.AuthUserKey).(string) if secret, ok := secrets[user]; ok &#123; c.JSON(http.StatusOK, gin.H&#123;\"user\": user, \"secret\": secret&#125;) &#125; else &#123; c.JSON(http.StatusOK, gin.H&#123;\"user\": user, \"secret\": \"NO SECRET :(\"&#125;) &#125; &#125;) // Listen and serve on 0.0.0.0:8080 r.Run(\":8080\") &#125; 中间件中使用Goroutines在中间件或处理程序中启动新的Goroutines时，你不应该使用其中的原始上下文，你必须使用只读副本（c.Copy()） func main() &#123; r := gin.Default() r.GET(\"/long_async\", func(c *gin.Context) &#123; // 创建要在goroutine中使用的副本 cCp := c.Copy() go func() &#123; // simulate a long task with time.Sleep(). 5 seconds time.Sleep(5 * time.Second) // 这里使用你创建的副本 log.Println(\"Done! in path \" + cCp.Request.URL.Path) &#125;() &#125;) r.GET(\"/long_sync\", func(c *gin.Context) &#123; // simulate a long task with time.Sleep(). 5 seconds time.Sleep(5 * time.Second) // 这里没有使用goroutine，所以不用使用副本 log.Println(\"Done! in path \" + c.Request.URL.Path) &#125;) // Listen and serve on 0.0.0.0:8080 r.Run(\":8080\") &#125; 自定义HTTP配置直接像这样使用http.ListenAndServe() func main() &#123; router := gin.Default() http.ListenAndServe(\":8080\", router) &#125; 或者 func main() &#123; router := gin.Default() s := &amp;http.Server&#123; Addr: \":8080\", Handler: router, ReadTimeout: 10 * time.Second, WriteTimeout: 10 * time.Second, MaxHeaderBytes: 1 &lt;&lt; 20, &#125; s.ListenAndServe() &#125; 支持Let’s Encrypt证书1行代码实现LetsEncrypt HTTPS服务器 package main import ( \"log\" \"github.com/gin-gonic/autotls\" \"github.com/gin-gonic/gin\" ) func main() &#123; r := gin.Default() // Ping handler r.GET(\"/ping\", func(c *gin.Context) &#123; c.String(200, \"pong\") &#125;) log.Fatal(autotls.Run(r, \"example1.com\", \"example2.com\")) &#125; 自定义autocert管理器的示例 package main import ( \"log\" \"github.com/gin-gonic/autotls\" \"github.com/gin-gonic/gin\" \"golang.org/x/crypto/acme/autocert\" ) func main() &#123; r := gin.Default() // Ping handler r.GET(\"/ping\", func(c *gin.Context) &#123; c.String(200, \"pong\") &#125;) m := autocert.Manager&#123; Prompt: autocert.AcceptTOS, HostPolicy: autocert.HostWhitelist(\"example1.com\", \"example2.com\"), Cache: autocert.DirCache(\"/var/www/.cache\"), &#125; log.Fatal(autotls.RunWithManager(r, &amp;m)) &#125; Gin运行多个服务请参阅问题并尝试以下示例 package main import ( \"log\" \"net/http\" \"time\" \"github.com/gin-gonic/gin\" \"golang.org/x/sync/errgroup\" ) var ( g errgroup.Group ) func router01() http.Handler &#123; e := gin.New() e.Use(gin.Recovery()) e.GET(\"/\", func(c *gin.Context) &#123; c.JSON( http.StatusOK, gin.H&#123; \"code\": http.StatusOK, \"error\": \"Welcome server 01\", &#125;, ) &#125;) return e &#125; func router02() http.Handler &#123; e := gin.New() e.Use(gin.Recovery()) e.GET(\"/\", func(c *gin.Context) &#123; c.JSON( http.StatusOK, gin.H&#123; \"code\": http.StatusOK, \"error\": \"Welcome server 02\", &#125;, ) &#125;) return e &#125; func main() &#123; server01 := &amp;http.Server&#123; Addr: \":8080\", Handler: router01(), ReadTimeout: 5 * time.Second, WriteTimeout: 10 * time.Second, &#125; server02 := &amp;http.Server&#123; Addr: \":8081\", Handler: router02(), ReadTimeout: 5 * time.Second, WriteTimeout: 10 * time.Second, &#125; g.Go(func() error &#123; return server01.ListenAndServe() &#125;) g.Go(func() error &#123; return server02.ListenAndServe() &#125;) if err := g.Wait(); err != nil &#123; log.Fatal(err) &#125; &#125; 优雅重启或停止想要优雅地重启或停止你的Web服务器，使用下面的方法 我们可以使用fvbock/endless来替换默认的ListenAndServe，有关详细信息，请参阅问题＃296 router := gin.Default() router.GET(\"/\", handler) // [...] endless.ListenAndServe(\":4242\", router) 一个替换方案 manners：一个Go HTTP服务器，能优雅的关闭 graceful：Graceful是一个go的包，支持优雅地关闭http.Handler服务器 grace：对Go服务器进行优雅的重启和零停机部署 如果你的Go版本是1.8，你可能不需要使用这个库，考虑使用http.Server内置的Shutdown()方法进行优雅关闭，查看例子 // +build go1.8 package main import ( \"context\" \"log\" \"net/http\" \"os\" \"os/signal\" \"time\" \"github.com/gin-gonic/gin\" ) func main() &#123; router := gin.Default() router.GET(\"/\", func(c *gin.Context) &#123; time.Sleep(5 * time.Second) c.String(http.StatusOK, \"Welcome Gin Server\") &#125;) srv := &amp;http.Server&#123; Addr: \":8080\", Handler: router, &#125; go func() &#123; // service connections if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed &#123; log.Fatalf(\"listen: %s\\n\", err) &#125; &#125;() // Wait for interrupt signal to gracefully shutdown the server with // a timeout of 5 seconds. quit := make(chan os.Signal) signal.Notify(quit, os.Interrupt) &lt;-quit log.Println(\"Shutdown Server ...\") ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() if err := srv.Shutdown(ctx); err != nil &#123; log.Fatal(\"Server Shutdown:\", err) &#125; log.Println(\"Server exiting\") &#125; 构建包含模板的二进制文件你可以使用go-assets将服务器构建成一个包含模板的二进制文件 func main() &#123; r := gin.New() t, err := loadTemplate() if err != nil &#123; panic(err) &#125; r.SetHTMLTemplate(t) r.GET(\"/\", func(c *gin.Context) &#123; c.HTML(http.StatusOK, \"/html/index.tmpl\",nil) &#125;) r.Run(\":8080\") &#125; // loadTemplate loads templates embedded by go-assets-builder func loadTemplate() (*template.Template, error) &#123; t := template.New(\"\") for name, file := range Assets.Files &#123; if file.IsDir() || !strings.HasSuffix(name, \".tmpl\") &#123; continue &#125; h, err := ioutil.ReadAll(file) if err != nil &#123; return nil, err &#125; t, err = t.New(name).Parse(string(h)) if err != nil &#123; return nil, err &#125; &#125; return t, nil &#125; 请参见examples/assets-in-binary目录中的例子 使用自定义结构绑定表单数据以下示例使用自定义结构 type StructA struct &#123; FieldA string `form:\"field_a\"` &#125; type StructB struct &#123; NestedStruct StructA FieldB string `form:\"field_b\"` &#125; type StructC struct &#123; NestedStructPointer *StructA FieldC string `form:\"field_c\"` &#125; type StructD struct &#123; NestedAnonyStruct struct &#123; FieldX string `form:\"field_x\"` &#125; FieldD string `form:\"field_d\"` &#125; func GetDataB(c *gin.Context) &#123; var b StructB c.Bind(&amp;b) c.JSON(200, gin.H&#123; \"a\": b.NestedStruct, \"b\": b.FieldB, &#125;) &#125; func GetDataC(c *gin.Context) &#123; var b StructC c.Bind(&amp;b) c.JSON(200, gin.H&#123; \"a\": b.NestedStructPointer, \"c\": b.FieldC, &#125;) &#125; func GetDataD(c *gin.Context) &#123; var b StructD c.Bind(&amp;b) c.JSON(200, gin.H&#123; \"x\": b.NestedAnonyStruct, \"d\": b.FieldD, &#125;) &#125; func main() &#123; r := gin.Default() r.GET(\"/getb\", GetDataB) r.GET(\"/getc\", GetDataC) r.GET(\"/getd\", GetDataD) r.Run() &#125; 运行示例： $ curl \"http://localhost:8080/getb?field_a=hello&amp;field_b=world\" &#123;\"a\":&#123;\"FieldA\":\"hello\"&#125;,\"b\":\"world\"&#125; $ curl \"http://localhost:8080/getc?field_a=hello&amp;field_c=world\" &#123;\"a\":&#123;\"FieldA\":\"hello\"&#125;,\"c\":\"world\"&#125; $ curl \"http://localhost:8080/getd?field_x=hello&amp;field_d=world\" &#123;\"d\":\"world\",\"x\":&#123;\"FieldX\":\"hello\"&#125;&#125; 注意：不支持以下样式结构 type StructX struct &#123; X struct &#123;&#125; `form:\"name_x\"` // HERE have form &#125; type StructY struct &#123; Y StructX `form:\"name_y\"` // HERE have form &#125; type StructZ struct &#123; Z *StructZ `form:\"name_z\"` // HERE have form &#125; 总之，现在只支持现在没有form标签的自定义结构 将请求体绑定到不同的结构体中绑定请求体的常规方法使用c.Request.Body，并且不能多次调用 type formA struct &#123; Foo string `json:\"foo\" xml:\"foo\" binding:\"required\"` &#125; type formB struct &#123; Bar string `json:\"bar\" xml:\"bar\" binding:\"required\"` &#125; func SomeHandler(c *gin.Context) &#123; objA := formA&#123;&#125; objB := formB&#123;&#125; // This c.ShouldBind consumes c.Request.Body and it cannot be reused. if errA := c.ShouldBind(&amp;objA); errA == nil &#123; c.String(http.StatusOK, `the body should be formA`) // Always an error is occurred by this because c.Request.Body is EOF now. &#125; else if errB := c.ShouldBind(&amp;objB); errB == nil &#123; c.String(http.StatusOK, `the body should be formB`) &#125; else &#123; ... &#125; &#125; 同样，你能使用c.ShouldBindBodyWith func SomeHandler(c *gin.Context) &#123; objA := formA&#123;&#125; objB := formB&#123;&#125; // This reads c.Request.Body and stores the result into the context. if errA := c.ShouldBindBodyWith(&amp;objA, binding.JSON); errA == nil &#123; c.String(http.StatusOK, `the body should be formA`) // At this time, it reuses body stored in the context. &#125; else if errB := c.ShouldBindBodyWith(&amp;objB, binding.JSON); errB == nil &#123; c.String(http.StatusOK, `the body should be formB JSON`) // And it can accepts other formats &#125; else if errB2 := c.ShouldBindBodyWith(&amp;objB, binding.XML); errB2 == nil &#123; c.String(http.StatusOK, `the body should be formB XML`) &#125; else &#123; ... &#125; &#125; c.ShouldBindBodyWith 在绑定之前将body存储到上下文中，这对性能有轻微影响，因此如果你要立即调用，则不应使用此方法 此功能仅适用于这些格式 – JSON, XML, MsgPack, ProtoBuf。对于其他格式，Query, Form, FormPost, FormMultipart, 可以被c.ShouldBind()多次调用而不影响性能（参考 #1341） HTTP/2 服务器推送http.Pusher只支持Go 1.8或更高版本，有关详细信息，请参阅golang博客 package main import ( \"html/template\" \"log\" \"github.com/gin-gonic/gin\" ) var html = template.Must(template.New(\"https\").Parse(` &lt;html> &lt;head> &lt;title>Https Test&lt;/title> &lt;script src=\"/assets/app.js\">&lt;/script> &lt;/head> &lt;body> &lt;h1 style=\"color:red;\">Welcome, Ginner!&lt;/h1> &lt;/body> &lt;/html> `)) func main() &#123; r := gin.Default() r.Static(\"/assets\", \"./assets\") r.SetHTMLTemplate(html) r.GET(\"/\", func(c *gin.Context) &#123; if pusher := c.Writer.Pusher(); pusher != nil &#123; // use pusher.Push() to do server push if err := pusher.Push(\"/assets/app.js\", nil); err != nil &#123; log.Printf(\"Failed to push: %v\", err) &#125; &#125; c.HTML(200, \"https\", gin.H&#123; \"status\": \"success\", &#125;) &#125;) // Listen and Server in https://127.0.0.1:8080 r.RunTLS(\":8080\", \"./testdata/server.pem\", \"./testdata/server.key\") &#125; 自定义路由日志的格式默认的路由日志是这样的： [GIN-debug] POST /foo --> main.main.func1 (3 handlers) [GIN-debug] GET /bar --> main.main.func2 (3 handlers) [GIN-debug] GET /status --> main.main.func3 (3 handlers) 如果你想以给定的格式记录这些信息（例如 JSON，键值对或其他格式），你可以使用gin.DebugPrintRouteFunc来定义格式，在下面的示例中，我们使用标准日志包记录路由日志，你可以使用其他适合你需求的日志工具 import ( \"log\" \"net/http\" \"github.com/gin-gonic/gin\" ) func main() &#123; r := gin.Default() gin.DebugPrintRouteFunc = func(httpMethod, absolutePath, handlerName string, nuHandlers int) &#123; log.Printf(\"endpoint %v %v %v %v\\n\", httpMethod, absolutePath, handlerName, nuHandlers) &#125; r.POST(\"/foo\", func(c *gin.Context) &#123; c.JSON(http.StatusOK, \"foo\") &#125;) r.GET(\"/bar\", func(c *gin.Context) &#123; c.JSON(http.StatusOK, \"bar\") &#125;) r.GET(\"/status\", func(c *gin.Context) &#123; c.JSON(http.StatusOK, \"ok\") &#125;) // Listen and Server in http://0.0.0.0:8080 r.Run() &#125; 设置并获取cookieimport ( \"fmt\" \"github.com/gin-gonic/gin\" ) func main() &#123; router := gin.Default() router.GET(\"/cookie\", func(c *gin.Context) &#123; cookie, err := c.Cookie(\"gin_cookie\") if err != nil &#123; cookie = \"NotSet\" c.SetCookie(\"gin_cookie\", \"test\", 3600, \"/\", \"localhost\", false, true) &#125; fmt.Printf(\"Cookie value: %s \\n\", cookie) &#125;) router.Run() &#125; 测试net/http/httptest包是http测试的首选方式 package main func setupRouter() *gin.Engine &#123; r := gin.Default() r.GET(\"/ping\", func(c *gin.Context) &#123; c.String(200, \"pong\") &#125;) return r &#125; func main() &#123; r := setupRouter() r.Run(\":8080\") &#125; 测试上面的示例代码 package main import ( \"net/http\" \"net/http/httptest\" \"testing\" \"github.com/stretchr/testify/assert\" ) func TestPingRoute(t *testing.T) &#123; router := setupRouter() w := httptest.NewRecorder() req, _ := http.NewRequest(\"GET\", \"/ping\", nil) router.ServeHTTP(w, req) assert.Equal(t, 200, w.Code) assert.Equal(t, \"pong\", w.Body.String()) &#125; 用户以下是使用Gin的一些用户 drone: Drone is a Continuous Delivery platform built on Docker, written in Go. gorush: A push notification server written in Go. fnproject: The container native, cloud agnostic serverless platform. photoprism: Personal photo management powered by Go and Google TensorFlow. krakend: Ultra performant API Gateway with middlewares. picfit: An image resizing server written in Go.","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://shuangdeyu.github.io/tags/Go/"},{"name":"Gin","slug":"Gin","permalink":"https://shuangdeyu.github.io/tags/Gin/"}]},{"title":"gitlab安装教程","slug":"gitlab安装教程","date":"2018-04-24T16:00:00.000Z","updated":"2023-12-20T08:34:12.430Z","comments":true,"path":"2018/04/25/gitlab-an-zhuang-jiao-cheng/","link":"","permalink":"https://shuangdeyu.github.io/2018/04/25/gitlab-an-zhuang-jiao-cheng/","excerpt":"","text":"记录下gitlab搭建的过程以及这中间遇到的问题。 环境：centos7，cpu 1核，内存 1G，swap 1G(后期扩展) 参考地址1：https://www.cnblogs.com/weifeng1463/p/7714492.html 参考地址2：http://blog.51cto.com/fuwenchao/1337896 查看内存配置我们先不急着来安装gitlab，先来看一下自己电脑的内存情况，我把这一步提到最前面，是因为这是我安装过程中遇到的最大的坑。 下面是gitlab的cpu和内存需求(https://docs.gitlab.com.cn/ce/install/requirements.html) 这里主要关注swap交换分区，由于我在装gitlab之前机器中已经运行了lnmp相关服务，所以在安装过程中swap出现被占满的情况，导致启动gitlab的时候卡顿奔溃，就算关闭之前的php以及nginx服务，1G的swap也是十分不足，所以最好的办法是在安装gitlab之前就对swap进行扩展。 扩展swap(虚拟内存)查看本机的内存，当然这是我扩展之后的，不然你将看到used跟total几乎一样。 增加分区大小，使用如下指令，大小为2G：# dd if=/dev/zero of=/home/swap bs=1024 count=2048000 设置交换文件：# mkswap /home/swap 然后我们就可以启用这个交换文件来为分区增加容量了：# swapon /home/swap 相对应的关闭命令为：# swapoff /home/swap 开机引导时自动启用，则需要编辑 # vim /etc/fstab ，添加如下代码，保存并退出：/home/swap swap swap defaults 0 0 安装gitlab终于到了激动人心的时刻了，正式开始gitlab的安装，按照顶上的教程，首先配置gitlab的yum安装源：# vim /etc/yum.repos.d/gitlab-ce.repo 在repo文件中添加以下内容，保存并退出： [gitlab-ce] name=Gitlab CE Repository baseurl=[https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el$releasever/](https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el$releasever/) gpgcheck=0 enabled=1 然后更新本地yum缓存，提高搜索安装软件的速度(这些操作记得都在sudo下进行)：# yum makecache 准备就绪，开始安装gitlab最新版，这个安装将会安装gitlab所需的所有环境，一步到位，装好即用：# yum install gitlab-ce 安装完之后需要使服务生效，我的内存瓶颈就是卡在这步上，重启了服务器，再增加分区才解决了：# gitlab-ctl reconfigure 然后启用gitlab组件就能运行了，这里需要说明，如果之前配置了php运行环境的话，可能会跟gitlab冲突，可以选择关闭其中一个来切换使用：# gitlab-ctl start GitLab常用命令列表 gitlab-ctl start # 启动所有 gitlab 组件； gitlab-ctl stop # 停止所有 gitlab 组件； gitlab-ctl restart # 重启所有 gitlab 组件； gitlab-ctl status # 查看服务状态； gitlab-ctl reconfigure # 启动服务； vim /etc/gitlab/gitlab.rb # 修改默认的配置文件； gitlab-rake gitlab:check SANITIZE=true –trace # 检查gitlab； sudo gitlab-ctl tail # 查看日志； 最后放上运行成功的界面","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"https://shuangdeyu.github.io/tags/gitlab/"}]},{"title":"英雄没有这么狭义","slug":"英雄没有这么狭义","date":"2018-02-17T16:00:00.000Z","updated":"2023-12-22T08:36:32.586Z","comments":true,"path":"2018/02/18/ying-xiong-mei-you-zhe-me-xia-yi/","link":"","permalink":"https://shuangdeyu.github.io/2018/02/18/ying-xiong-mei-you-zhe-me-xia-yi/","excerpt":"","text":"已经没事了！要问理由？因为我来了！ 《我的英雄学院》（以下简称《英雄》）是一部年轻的热血漫画，“ 讲述了一个天生无能力的少年绿谷出久追随憧憬的偶像英雄欧尔麦特，在以培养未来英雄为目的的雄英学院中求学、成长的故事 ”。 《英雄》中最令我印象深刻，最耀眼的角色非“欧尔麦特”莫属。他是No.1的英雄，和平的象征，One·for·All（一个强大的异能）个性的继承人，是正义邪恶两方无人不知无人不晓的强大存在，更重要的是，他是一个正义感、责任感强烈，一个真正担当的起“英雄”这个称号的男人。 在《英雄》的世界观中，全世界有超过80%的人类拥有了名为“个性”的力量，就是我们平常所说的超能力，当超能力变得普遍存在的时候，由此而衍生出了“英雄”这个职业，没错，这里的英雄在大部分人眼里俨然变成了一份光荣的谋生的职业，一个以解决普通人无法解决的事件的职业。 英雄，汉语的释义是：无私忘我，不辞艰险，为人民利益而英勇奋斗，令人敬佩的人。从目前的动画来看，欧尔麦特是最有资格获此殊荣的人。 一心一意帮助有困难的人，我觉得这是英雄最高尚的品质，也就是欧尔麦特所拥有的品质，上班途中他会为了救人而迟到，因为他无法放弃任何一个需要帮助的人；当学生们受到伤害，他满积愤怒向克制他的敌人出拳，打到遍体鳞伤；重伤在身，一遍吐血一边用自己得之不易的能力行使正义，从不退缩，从不倒下。他就是这么一个人，英雄，良师，一个担当得起所有荣耀的人，完美的英雄。 那么，把英雄当做职业的人就不能称之为英雄了吗？不完美的人就不是英雄了吗？他们有些人为了挣钱，有些人为了出名，有些人为了工作，也有些人为了改变自己，不管他们出于何种目的选择英雄作为职业，尽管他们包藏私心，没有疑问的是，他们都做着英雄该做的事情，打击罪犯，帮助普通人，救人于危难，维持社会安稳……至少，他们对得起英雄这份职业。 同样是英雄，《漫威》中的钢铁侠傲慢自大、不知谦逊，美国队长自以为是，有道德优越感，《一拳超人》中的英雄们也是各有性格，少有人为了正义而当着英雄。 英雄不应该是狭义的，保家卫国的士兵是英雄，跳河救人的平民也是英雄，捐款援助有困难的人的富豪是英雄，死后捐献遗体器官的人是英雄，无偿献血的人也是英雄，徒手接坠楼女童的保安是英雄，高架上救助被困小猫的消防员也是英雄，妻子眼中撑起家的丈夫也是英雄…… 英雄不是绝对而是相对，英雄不该量化，每个人都有缺点，但每个人也都有可能成为英雄，哪怕是在某一个特定的时间，在一个人的眼中。品德高尚、有重大贡献的英雄自当被歌颂，比如欧尔麦特，但不可否认的是那些各有目的，却行英雄之事的职业英雄也是英雄。 《英雄》中的英雄猎人正是曲解了英雄的含义才会猎杀那些职业英雄，他心中的英雄之道是狭义的，不应该被赞同，不应该被追随。","categories":[{"name":"闲谈","slug":"闲谈","permalink":"https://shuangdeyu.github.io/categories/%E9%97%B2%E8%B0%88/"}],"tags":[{"name":"动漫","slug":"动漫","permalink":"https://shuangdeyu.github.io/tags/%E5%8A%A8%E6%BC%AB/"}]},{"title":"《银翼杀手2049》","slug":"《银翼杀手2049》","date":"2018-01-07T16:00:00.000Z","updated":"2023-12-22T08:46:39.012Z","comments":true,"path":"2018/01/08/yin-yi-sha-shou-2049/","link":"","permalink":"https://shuangdeyu.github.io/2018/01/08/yin-yi-sha-shou-2049/","excerpt":"","text":"人类终究成了造物主，当生命可以被创造，那么被创造的生命存在的意义又是什么 要从2017年上映的科幻电影中选一部最好的话，我选择《银翼杀手2049》，它不仅有科幻片那看得令人爽到全身发颤的视觉特效，更重要的是，它还是一部思想深刻，内涵丰富的优秀作品，可以说是一部既有精美包装，又有灵魂的电影。 看完电影我们是不是都在同情复制人？觉得复制人更有人性，遭受欺凌？人类是利欲熏心的，复制人是纯洁的？ 我不完全同意。电影中的复制人的确是弱势群体，我们会下意识地对他们抱有同情之心，这是人类情感的一种本能，是感性支配的结果，但为什么复制人是弱势群体呢？因为人类处于绝对的统治地位，通俗点讲就是“拳头够硬”，复制人作为人类的创造物自然得不到跟人类同等的待遇，因为从本质上讲，复制人并不是人类的“同类”，但不可忽略的是，复制人也是人，他们是以人类为原型创造的，他们有喜怒哀乐，会恐惧，懂得撒谎隐忍，会使用暴力，也懂得牺牲自我，行使正义，在我看来，他们跟人类毫无区别，甚至在很多方面比人类更能干，强过人类，所以危害更大。 有情感的生物必然无法单纯地定义好坏，人类也好，复制人也好，必然都有善恶，都存在人性的闪光点以及阴暗面，影片中也不是一味地描述人类的恶，复制人的善。K的女上司为了维持社会秩序，避免战乱，她选择毫不畏惧地牺牲自己，而且她对K这个非“同类”存有感情，帮助其逃脱；上代银翼杀手戴克为了保护女儿，忍受着思念以及孤独，隐居在荒芜之地多年，这是何等的坚忍以及对女儿何等之深的爱意。人类一直拥有着这些优秀的情感。 复制人也不是单纯的善，之所以我们会认为他们是正义的一方，是因为他们是反抗者，是受迫害的一方，就好像中国古时的农民起义，我们总是称赞他们的揭竿而起，但这些起义成功了也只是换个人继续当皇帝罢了，没有从根本上解决矛盾，我不认为如果复制人起义成功的话会善待曾经创造但迫害他们的人类。因为我从复制人首领那里看到了欲望 —— 取人类而代之，她为了保护复制人起义的关键 —— 复制人瑞秋所生的女孩，甚至不惜杀了那女孩的生父，曾经的盟友戴克，还有华莱士的助手女复制人心狠手辣，杀人不眨眼，这些在人类身上出现的阴暗同样原封不动地赋予了复制人，他们和人类又有何区别。所以我最喜欢电影中那位为了维持社会秩序的女警官，职责所在，万死不辞。 人类终究成了造物主，当生命可以被创造，那么被创造的生命存在的意义又是什么？被创造的生命同样可以孕育生命，那么他们和人类又有什么不同？创造和孕育，到底哪种形式的生命更尊贵，还是说两者没有高低贵贱之分？电影中还有许多可以解读的内容，以上只是我解读的一方面而已，这足够说明这部电影的伟大之处。 看《银翼杀手2049》，收获的不仅仅是视觉上的享受，更是内心的满足，电影是艺术，不该只有商业和票房。","categories":[{"name":"影评","slug":"影评","permalink":"https://shuangdeyu.github.io/categories/%E5%BD%B1%E8%AF%84/"}],"tags":[{"name":"电影","slug":"电影","permalink":"https://shuangdeyu.github.io/tags/%E7%94%B5%E5%BD%B1/"}]},{"title":"搭建svn服务器","slug":"搭建svn服务器","date":"2017-11-21T16:00:00.000Z","updated":"2023-12-20T08:38:36.004Z","comments":true,"path":"2017/11/22/da-jian-svn-fu-wu-qi/","link":"","permalink":"https://shuangdeyu.github.io/2017/11/22/da-jian-svn-fu-wu-qi/","excerpt":"","text":"1、安装svn服务检查是否已经安装svn服务# rpm -qa subversion 如未安装则下一步安装此服务# yum install subversion 经过不漫长的等待，安装好之后检测一样是否正确安装，查看版本号即可 # svnserve --version svnserve，版本 1.7.14 (r1542130) 2、创建代码库首先创建一个文件夹用于存放项目# mkdir -p /var/svn/projects 然后在此文件夹下创建代码库# svnadmin create /var/svn/projects 看到生成了这些目录，就说明创建成功了 3、配置代码库配置文件在conf目录下，其中 authz 是账号配置，passwd 是账号密码配置，svnserve.conf 是服务器配置 首先配置可访问svn服务器的账户，其中**[groups]下面是账户组，多个用户用逗号分开，[/]是访问的目录，给其下账户组设置权限为rw**，表示可读可写 [groups] gro_users = zhangs,lis [/] @gro_users = rw 然后是passwd配置，给账户组中的用户设置密码就行了 [users] zhangs = 123456 lis = 123456 最后是svnserve.conf服务器配置，取消下面几个配置的注释，如果没有则添加进去 #匿名用户访问的权限，可以是read,write,none anon-access = none #使授权用户有写权限 auth-access = write #密码数据库的路径 password-db = passwd #访问控制文件的路径 authz-db = authz 4、启动svn服务# svnserve -d -r /var/svn/projects 检查svn是否启动 # ps -ef|grep svn|grep -v grep root 4992 1 0 22:44 ? 00:00:00 svnserve -d -r /var/svn/projects 需要注意的是svn服务使用的端口是3690，如有必要，请检查一下这个端口是否被占用 如要停用svn，则使用下面这个命令# killall svnserve 5、使用svn服务器需要在你的客户端下载TortoiseSVN 从svn服务器上checkout 但是，问题来了 这种情况首先排除网络是否连接，如网络没有问题，那十之八九就是服务器的问题，记得别让svn服务的端口被防火墙给拦了 /etc/sysconfig/iptables 在防火墙设置文件中加 -A INPUT -p tcp -m state --state NEW -m tcp --dport 3690 -j ACCEPT 注意，这段代码不能随便加，位置不对并不会企作用，需要加在同类型设置代码的下面 然后重启防火墙再试试svn，出现如下画面就表示成功配置了svn服务器，然后就可以上传下载项目了","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"svn","slug":"svn","permalink":"https://shuangdeyu.github.io/tags/svn/"}]},{"title":"语速快慢对听课效率的影响","slug":"语速快慢对听课效率的影响","date":"2017-06-26T16:00:00.000Z","updated":"2023-12-22T09:31:30.672Z","comments":true,"path":"2017/06/27/yu-su-kuai-man-dui-ting-ke-xiao-lu-de-ying-xiang/","link":"","permalink":"https://shuangdeyu.github.io/2017/06/27/yu-su-kuai-man-dui-ting-ke-xiao-lu-de-ying-xiang/","excerpt":"","text":"不知道大家有没有觉得老师讲课的语速更快，我们听得更认真？ 令我印象最深刻的是高中化学课的时候，我们的化学老师语速很快，首先从我自身来讲，我听得很认真，很入迷，会情不自禁地跟着老师的步骤走，很有激情，当然也有跟不上漏掉某些知识点的时候，好在有些难记的知识点老师会回过头来再跟我们讲一遍，所以当时我的化学成绩还可以，我们班大部分人学的都不赖。 后来换老师了，新换的化学老师语速很温柔，好些人听得昏昏欲睡，很没干劲，渐渐变得很容易开小差，后来我们班整体的化学成绩下降了很多，听课氛围变差，这些都是能强烈感受到的。 首先，我没有任何怪罪老师们的想法，尤记得当初新老师课堂上表现出的深深的无奈，现在想来，感觉很对不起她，当然现在说这些已经晚了，也没意义。但是，老师讲课语速更快，学生们注意力更集中，这是有科学依据的，当然不要钻牛角尖说越快越好，凡事都有个限度，还有这是个普遍现象，当然有许许多多的个例了，总之，有句话我觉得相对来说是很正确的：是学生适应老师而不是老师来适应学生。 有一种情况例外，就是那些普通话极其不标准的老师，我觉得他们对学生是极其不负责任的，因为普通话的标准程度是可以通过训练来矫正的，显然这些老师没有在这方面下功夫。 语速过慢，不仅浪费时间，而且可能使学生的注意力分散，大脑皮层转入抑制状态，从而出现厌倦情绪，降低听课的兴趣与效果。语速过快，大脑来不及处理收到的信息，难免造成信息的脱落或积压，导致信息的传送与接收活动发生障碍：学生对刚听到的语言信号所承载的意义还没有领悟、反应，就又有一连串的话语（语言信号）涌来。 大量信息连续不断的通过感官系统涌入大脑，很容易使学生产生烦躁不安的心理反应；如果持续到一定程度，就会形成抑制、疲劳状态，甚至引起大脑处理信息活动的中段或是禁止，拒绝信号的持续进入。 以上是一段对教师讲课语速快慢所造成的影响的科学性解释，它表达的观点很清楚，读者也不难理解，即语速适中能产生高效的听课效率。 但凡这种高或低，快或慢的问题，标准答案往往是中庸的，我的观点是快语速更能使学生注意力集中。这个想法是我通过观察我的老师们得来的，我发现语速稍快的老师们的课堂上，学生们比较活跃，互动性更强一点，虽然存在很大主观性，但是适当的快语速一定能促进听课效率的提高。 当然影响听课效率的因素还有很多，更复杂的是还需要多种因素配合发挥才能达到很好的听课效率，这里我就不进一步讨论了，我也没有更深入的研究。 虽说是学生去适应老师的教学方式更合理，但有时候老师也有必要改变一下自己的教学风格不是吗？最好是跟学生沟通，找到双方契合的上课方式，我想这对学生和老师来说都是很难得的财富。","categories":[{"name":"闲谈","slug":"闲谈","permalink":"https://shuangdeyu.github.io/categories/%E9%97%B2%E8%B0%88/"}],"tags":[{"name":"感想","slug":"感想","permalink":"https://shuangdeyu.github.io/tags/%E6%84%9F%E6%83%B3/"}]},{"title":"查理.芒格的逆向思维","slug":"查理.芒格的逆向思维","date":"2017-06-21T16:00:00.000Z","updated":"2023-12-22T09:32:25.699Z","comments":true,"path":"2017/06/22/cha-li.mang-ge-de-ni-xiang-si-wei/","link":"","permalink":"https://shuangdeyu.github.io/2017/06/22/cha-li.mang-ge-de-ni-xiang-si-wei/","excerpt":"","text":"本文取名《查理.芒格的逆向思维》，是因为看了芒格在哈佛毕业典礼上的演讲之后，我感触很深，并不是说我对芒格的研究很深，事实上我也是才刚刚开始关注这个人，对他的一切还处在道听途说的阶段，但就算道听途说，这个人也是让人佩服得妥妥的。 平时也经常听说逆向思维的重要性，但大多讲得不是很浅就是长篇大论很抽象，往往令人get不到那个点，但看了查理.芒格于哈佛毕业典礼的演讲稿之后，我好像有一种“拨开云雾见月明”的感觉，虽然对逆向思维的理解和运用远没有达到很深刻的地步，但至少让我知道了一个大概的方向，这是极其珍贵的，有时候踩着别人的肩膀过河总好过自己摸着石头过河。 我们先来看一下什么是“逆向思维”。当大家都朝着一个固定的思维方向思考问题时，而你却独自朝相反的方向思索，这样的思维方式就叫逆向思维。——摘自百度百科。简单概括就是跳出固有“常识”来进行思考，说起来简单，但是做起来并不简单，所谓固有“常识”就好像一个人的习惯一样，一旦养成，是很难在短时间内改正的，当然，我们并不是要完全摒弃固有“常识”，这就说明逆向思维是需要通过锻炼习得的，因为我们从小训练的思维习惯一般都是正向的。 一个最耳熟能详的逆向思维的例子是——司马光砸缸，当小伙伴落水的时候我们（以我们的视角，不是小孩子的视角）的常规思维告诉我们是把他从水里拉出来，那反过来想一下，为什么不是水自己流出来呢？司马光就想到了这一点，于是他砸破了缸，让水流出来，最终小伙伴就得救啦。 然后再回到查理.芒格在哈佛毕业典礼上的演讲，他给了哈佛毕业生们四味人生处方——“要反复无常，不要虔诚地做你正在做的事”，“尽可能从你们自身的经验获得知识”，“当你们在人生的战场上遭遇第一、第二或者第三次严重的失败时，就请意志消沉，从此一蹶不振吧”，“要是知道我会死在哪里，那我就去那个地方躺着”。他开这四味处方的“目的”就是为了让这些学生们过上头脑混乱、痛苦不堪的日子。 先来看看这四味处方都表示什么意思，第一和第三味处方很好理解，前者是说做事要认真，不要像龟兔赛跑中的兔子一样自以为是，不认真比赛而白白丢掉了本该属于你自己的“冠军”，后者是说遭遇失败不要气馁，而要从失败中总结经验再次站起来，第二味是说学习的时候要跳出自己的舒适区，否则你将很难学到更多的知识，第四味的意思就是告诉大家要学会使用逆向思维来思考，也就是把问题反过来想，不要先想我该去哪里，反过来先想想我会死在哪里，然后再决定该往哪里走。 我想没有阅读障碍的朋友都能看懂查理.芒格开出的这四味处方的意思，他开的这四味处方就使用了逆向思维，他没有明明白白的告诉我们该怎么做，而是反过来告诉我们怎么去获得失败和痛苦，这个效果可比正面告诉我们怎么做要好多了，用逆向的方式说出来更让人脊背发凉，感受更深，仿佛这些痛苦说的就是读者自己，如果用正向的方式说出来反而没什么人听，因为我们平时听多了大道理，已经腻了。 然后我简单总结了一下查理.芒格的逆向思考的方式，那就是先思考自己做这件事有哪些途径和方法能使自己感到痛苦，然后不去做就得了，举个栗子，比如说我要从事程序员这个工作，那我先想一下我从事这个工作有哪些方式可以使自己赚不到钱，为了达到这个目标我会不经常看书和学习，我只学一点入门就上手工作然后就做简单的项目，拿固定的死工资，我不会去学习更多的语言，回家我只会玩游戏看视频……然后等我过了30岁，我还是每个月拿着5千的工资，看着曾经的同事月入几万，还没有刚毕业的学生们工资高，还没有女朋友，还没有存款……细思极恐啊，妈蛋，还不滚去敲代码。 以上就是我对逆向思维的一些感想，不说了我要去睡觉了，为了让明天的我自责懊悔，今天计划的事情就不做了。","categories":[{"name":"闲谈","slug":"闲谈","permalink":"https://shuangdeyu.github.io/categories/%E9%97%B2%E8%B0%88/"}],"tags":[{"name":"感想","slug":"感想","permalink":"https://shuangdeyu.github.io/tags/%E6%84%9F%E6%83%B3/"}]},{"title":"centos上安装lnmp环境","slug":"centos上安装lnmp环境","date":"2017-04-11T16:00:00.000Z","updated":"2023-12-20T08:46:59.507Z","comments":true,"path":"2017/04/12/centos-shang-an-zhuang-lnmp-huan-jing/","link":"","permalink":"https://shuangdeyu.github.io/2017/04/12/centos-shang-an-zhuang-lnmp-huan-jing/","excerpt":"","text":"首先简单介绍一下linux的两种安装方法，yum以及编译安装。yum是一个软件包管理器，使用yum指令安装，系统会自动下载软件包并安装，并且还能自动处理依赖，安装依赖包，优点是方便简单，缺点是管理器的软件包往往不是最新版的，甚至可能比较老旧。 而编译安装则需要自己找相关软件的代码源，下载的软件都是没有编译的代码，所以需要自己编译成可执行文件，所以叫做编译安装，它的优点是软件源自己寻找，可以是最新的，也可以是旧的，比较灵活，缺点是操作步骤多，安装繁琐，新手失败率大。 虽然yum安装的软件版本比较低，但我们可以通过配置第三方yum源的方式来安装较新版本的软件，下面我就整理介绍一下通过这种方式安装成功的步骤。 参考了下面教程http://www.cnblogs.com/toughlife/p/5479271.htmlhttp://www.cnblogs.com/xiaoit/p/3991037.htmlhttp://www.2cto.com/os/201702/597890.html 准备工作首先你需要一台装好centos系统的虚拟机或服务器，本机测试环境是CentOS Linux release 7.3.1611 1、配置第三方yum源先看一下默认yum安装的php版本，会发现版本比较低 # yum list php php.x86_64 5.4.16-42.el7 base 安装centos7的源(注意不是6.5，源要与系统大版本号对应，否则会出错) # yum install epel-release # rpm -ivh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm 接下来使用扩展源搜索php的版本，我们发现能搜索到更高版本的软件源了 # yum list --enablerepo=remi --enablerepo=remi-php56 php php.x86_64 5.6.30-1.el7.remi remi-php56 # yum list --enablerepo=remi --enablerepo=remi-php70 php php.x86_64 7.0.17-1.el7.remi remi-php70 关于yum第三方源网上有很多资源，我们可以自行选择，以上是php的源，mysql的源网上也有，这里就不介绍了，道理都是一样的 2、安装php使用扩展源yum安装php及一堆扩展，这里选择5.6版本的 # yum install --enablerepo=remi --enablerepo=remi-php56 php php-fpm php-opcache php-devel php-mbstring php-mcrypt php-mysqlnd php-phpunit-PHPUnit php-pecl-xdebug php-pecl-xhprof 使用下面两个指令，任选其一，查看是否安装成功，如果正确显示版本号或路径信息，则表示安装成功了 # php --version # which php 顺便启动一下php-fpm，再设置一下这个服务的开机启动 # &#x2F;bin&#x2F;systemctl start php-fpm.service # chkconfig php-fpm on 3、安装nginx由于没有设置过nginx的yum源，默认安装就好 #yum install nginx 查看是否安装成功，成功显示版本号信息表示安装成功，或者在浏览器输入’localhost’，看是否出现如下页面 # which nginx /usr/sbin/nginx # /usr/sbin/nginx -v nginx version: nginx/1.10.2 启动nginx服务，并设置开机启动 # &#x2F;bin&#x2F;systemctl start nginx.service # chkconfig nginx on 4、配置nginx支持phpnginx默认是不支持php脚本编译的，所以需要先配置 将配置文件改为备份文件 # mv /etc/nginx/nginx.conf /etc/nginx/nginx.confbak 将默认的配置文件作为配置文件 # cp /etc/nginx/nginx.conf.default /etc/nginx/nginx.conf 进入nginx配置文件进行修改 # vi /etc/nginx/nginx.conf 找到80端口的配置，加入index.php index index.php index.html index.htm; 加入下面的配置代码，如果已经存在的，去掉注释，并修改,其中/usr/share/nginx/html是web根目录的地址，可以根据自己的喜好进行选择，我一般放在/var/www下 location ~ \\.php$ &#123; root /usr/share/nginx/html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /usr/share/nginx/html$fastcgi_script_name; include fastcgi_params; &#125; 最后，编辑文件php.ini，在文件末尾添加cgi.fix_pathinfo = 1，已经存在的去掉注释就好了 # vi /etc/php.ini 重启nginx和php-fpm服务 # /bin/systemctl restart nginx.service # /bin/systemctl restart php-fpm.service 然后新建一个php文件，写一个测试代码，最常见的就是输出phpinfo(); # vi /usr/share/nginx/html/test.php 在浏览器输入’localhost/test.php’，如果如下图所示，表示配置成功 5、安装MySQL同样，MySQL使用原生的yum安装，安装MySQL以及它的服务 # yum install mysql mysql-server mysql-devel 在安装过程中我们会发现**没有可用软件包 mysql-server。**这个提示，因为centos7默认的数据库不是MySQL，而是Mariadb。 Mariadb是MySQL的一个分支，但完全兼容MySQL，它对应的服务是Mariadb—server，其使用方法和MySQL几乎一致，实际上你执行‘yum install mysql’安装的就是Mariadb，如果不习惯还是想使用MySQL服务也是可以的，只要按下面步骤下载包安装即可。 # wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm # rpm -ivh mysql-community-release-el7-5.noarch.rpm # yum install mysql-server 值得注意的是安装mysql服务的时候，会安装一些依赖，原来的Mariadb将会被MySQL替代掉，最后，开启服务，如果没有报错表示安装成功，同时设置开机启动 # /bin/systemctl start mysqld.service # chkconfig mysqld on 如果还想进一步验证，可以使用sql指令验证，输入‘mysql’指令就可以进入sql指令命令窗口 # mysql 6、总结至此，lnmp的环境就算搭建好了，以上仅供参考，遇到问题多搜索，多探索，总会解决的。 扩展1、安装phpmyadmin去PHPmyadmin官网下载安装包到本地，然后使用ssh上传到centos上，上传后我的安装包目录是，/usr/local/src/phpMyAdmin.zip 然后解压安装 # unzip /usr/local/src/phpMyAdmin.zip 移动到web访问目录并重命名（注意解压安装之后的文件夹不是‘phpMyAdmin’，而是类似于‘phpMyAdmin-4.7.0-all-languages’这样的，我的默认安装之后是在‘home’文件夹下） # mv phpMyAdmin-4.7.0-all-languages /usr/share/nginx/html/phpmyadmin 然后在浏览器访问‘localhost/phpmyadmin’，如下图所示就表示安装成功了 有些人可能会遇到 403 不能访问的错误，可以看一下是否关闭了selinux或者phpmyadmin文件夹设置了不能访问的权限 2、配置nginx支持thinkphp在原有的配置文件nginx.conf下修改php解析的代码，修改下面注释的三个地方 location ~ \\.php &#123; #去掉$ root /var/www; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_split_path_info ^(.+\\.php)(.*)$; #增加这一句 fastcgi_param PATH_INFO $fastcgi_path_info; #增加这一句 fastcgi_param SCRIPT_FILENAME /var/www$fastcgi_script_name; include fastcgi_params; &#125; 3、配置nginx隐藏thinkphp路径中的index.php在原有的配置文件nginx.conf下修改代码，添加注释的这一段代码，其中user、tool是你项目文件夹的名称，含有public的是thinkphp5的默认路径 location / &#123; root /var/www; index index.php index.html index.htm; if (!-e $request_filename) &#123; #隐藏index.php rewrite ^/user/public/(.*)$ /user/public/index.php/$1 last; rewrite ^/tool/(.*)$ /tool/index.php/$1 last; &#125; #隐藏index.php &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://shuangdeyu.github.io/tags/linux/"}]},{"title":"将hexo部署到自己的服务器","slug":"将hexo部署到自己的服务器","date":"2017-04-11T16:00:00.000Z","updated":"2023-12-22T09:38:13.897Z","comments":true,"path":"2017/04/12/jiang-hexo-bu-shu-dao-zi-ji-de-fu-wu-qi/","link":"","permalink":"https://shuangdeyu.github.io/2017/04/12/jiang-hexo-bu-shu-dao-zi-ji-de-fu-wu-qi/","excerpt":"","text":"前提一台服务器，一个已经部署到github、oschina等git服务器上，并能正常访问的hexo博客 这里介绍一个简单地将hexo博客部署到自己的服务器上的方法，其原理很简单，就是将已经部署到github上的项目clone到自己的服务器上，由于hexo是静态博客，所以只要clone正确，就能通过自己的服务器正常访问博客了。 1、clone项目到web根目录注意后面要加clone的web根目录，否则clone下来的文件会默认在外面套一个以你的项目命名的文件夹，这样到时候访问的话css、js等路径会出错，因为不是在根目录下 # git clone https://git.oschina.net/shuangdeyu/shuangdeyu.git /var/www 然后到浏览器中访问‘localhost’，正确打开博客就表示成功了 2、更新博客如果你的博客更新了的话，只要在服务器上的web根目录中执行一条指令，就能将github上的项目同步更新下来了，但前提是你已经更新到github上了 # git pull","categories":[{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://shuangdeyu.github.io/tags/hexo/"}]},{"title":"这该死的情怀","slug":"这该死的情怀","date":"2017-04-03T16:00:00.000Z","updated":"2023-12-22T09:38:52.132Z","comments":true,"path":"2017/04/04/zhe-gai-si-de-qing-huai/","link":"","permalink":"https://shuangdeyu.github.io/2017/04/04/zhe-gai-si-de-qing-huai/","excerpt":"","text":"有这么一部动画片，是现在很多年轻人(90后才不是空巢老人，掀桌)的童年回忆——数码宝贝，当然，这里的数码宝贝指的是1999年3月7日在日本富士电视台首播的系列第一部，讲的是以八神太一为首的八个被选中的孩子和他们的数码宝贝搭档的冒险故事。 我已经记不清是什么时候看的这部动画片了，就算放到现在来看，它也是一部制作精良，剧情、打斗、创意、内涵等等元素在线的佳作，那八个性格各异的孩子，八只同样性格各异的数码宝贝，不知道让多少人的童年如那墙角的陈列柜，上面放着这么一本相册，等你老了再来翻翻，嘴角会不禁咧出一丝微笑。每一代人的童年都会有一些令人难忘的事物，我们这一代，数码宝贝就是许多人的其中之一。 就在这份情怀，这份记忆尘封在陈列柜上，只会偶尔走过瞄它一眼的时候，《数码宝贝tri.》突然宣告要和大家见面了，然后这份情怀就像水底沉睡多年的巨兽，迫不及待的想要浮出水面呼吸一下新鲜空气，等着看tri的心情仿佛在等一个明天就会送达的快递。 不知不觉，tri更新到了现在的第四章，我的观影感受也从最初的激动兴奋，再到慢慢变淡，最后竟然变成了无聊。其实在观看tri第一章的时候我就有了不好的预感，因为它给我的感觉不像是一部奇幻、冒险类型的动画片，而更像是学园、成长恋爱类型的，就个人来说，我更喜欢前者，而且tri的这一变化，难免让人感到有些措手不及，毕竟我们印象中的数码宝贝是热血的，是激情的，是天真的，而不是文艺的。 其实仔细想想，这个变化又在情理之中，因为身为主角的八个孩子都长大了，他们要为很多事情而考虑，内心世界更加复杂，情感波动更大，顾虑更多，换句话说，就是更加现实，在这样的逻辑下，当然不能像小孩子一样只顾战斗和友情，然后一往直前。所以，太一变得“懦弱”，阿丈把学业放在第一位，素娜纠结于情感，大家或多或少都有了变化，大人的世界永远都是复杂的，没变的只有那几只数码宝贝，它们只要依赖在拍档身边就好了。 影片（tri是以剧场版形式分集播出的）一开始就以成长后的孩子们的情感和内心世界的变化展开描述，而主线剧情则整个穿插在中间。看到现在为止，每一章的形式几乎都是一样的，大篇幅重点讲述其中一两个或多个孩子的成长变化，然后蜻蜓点水一般推进剧情的发展，结尾再辅以短暂的大战斗，给出一点悬念，只有第四章让观众了解到了更多的剧情信息。 这样就好像是一部完整的电影被硬生生的拆成了六部（据消息说会有六章）播放，看第一章感觉还好，再往下看难免让人产生心烦和套路的感觉。情怀粉并不代表脑残粉，那几只数码宝贝的究极进化，出现更多帅气强大的皇家骑士，剧情吸引人，这些亮点掩盖不了剧情的拖拉，每一章都来浓墨重彩的描述友情和成长，我看到了满屏幕的矫情，如此多的纠结和不干脆的情感强行安在主角们身上，未免显得太用力过度了。 至于画风突变，细节粗糙这些槽点，我觉得都可以忍受，最大的问题还是在于拖拉，这样会让人感觉是在故意拖集数，显得很没有诚意，毕竟一个剧情分六部电影来播放实在是长得让人难以接受。 虽然槽点颇多，但我还是会去看，不是坚持去看，而是发自内心的去看，讲的矫情点，看到这些熟悉的人物，熟悉的数码宝贝，的确是满满的感动和回忆，甚是怀念以前那段无忧无虑的时光，就像这八个被选中的孩子，我们也长大了，再也不像以前那般活得单纯。 最后，他们选择了前进，我们不是也应该如此吗？人生就这样，只有前进才能看到未来。 对于数码宝贝，它长大了，而我还是一个孩子","categories":[{"name":"影评","slug":"影评","permalink":"https://shuangdeyu.github.io/categories/%E5%BD%B1%E8%AF%84/"}],"tags":[{"name":"动漫","slug":"动漫","permalink":"https://shuangdeyu.github.io/tags/%E5%8A%A8%E6%BC%AB/"}]},{"title":"最令我痛心的不是老狼的退幕","slug":"最令我痛心的不是老狼的退幕","date":"2017-03-12T16:00:00.000Z","updated":"2023-12-22T09:39:08.106Z","comments":true,"path":"2017/03/13/zui-ling-wo-tong-xin-de-bu-shi-lao-lang-de-tui-mu/","link":"","permalink":"https://shuangdeyu.github.io/2017/03/13/zui-ling-wo-tong-xin-de-bu-shi-lao-lang-de-tui-mu/","excerpt":"","text":"抛开情怀，我可以问心无愧的说这是一部好电影。 距离金刚狼3上映已经一周多了，相信很多人都看过了这部传奇谢幕的好电影，网路上关于它的文章和视频也是如潮水般涌现，可见大家对这部电影的喜爱，以及它的好口碑的确是实至名归，我也看了好几篇文章，作者们对于它都是真情流露的，写的很棒，每读一篇都会有不同的感受与共鸣，而我自知文笔不是很好，怕写不出那种共鸣感，本来不想写的，但过了一周还是没有从金刚狼的回味中走出来，所以我还是决定记录一下我的一点观后感。 金刚狼3不是第一部以普通人的视角描述超级英雄的电影，但绝对是至今为止最为悲壮的一部。我觉得其中最令我痛心的不是老狼的退幕，而是教授的解脱。 众所周知，教授是X战警的创始人，他一直以一个正义暖心的慈师形象现身，而这么一个总是为他人着想的人，在电影中却是亲手杀害了几百人的凶手，其中有七个更是他的学生，尽管这是他不受控制的无意之举，但可想而知，当时乃至后来，他的内心承受着多大的痛苦与自责。当雇佣兵们持着抢闯进房间的时候，他明知他此时的超能力不受控制，但他还是下意识的发动了，后来他满怀歉意的对罗根说：“我只是想保护劳拉。”在他心中，肯定早就把劳拉当成了自己的学生乃至孙女，由此可见学生在他心中的地位是有多么的重要，可是偏偏命运弄人，让他最爱的学生妄死在了他的手中。 我想，他内心想死的冲动一点都不比罗根少，尽管他有很长一段时间都没有想起那段惨不忍睹的记忆，可是电影中教授永远都是最满怀希望的一个，在变种人，X战警已经穷途末路的情况之下，仅仅因为劳拉的出现，教授就觉得变种人的希望来了，这固然跟他的超能力使他敏锐有一定关系，但更多的我觉得是他一直都没有放弃希望。这就是一个师者的形象，永远走在最前面，带领着学生走向光明的未来。 最后教授的死虽也在意料之中，但真的出现的时候还是忍不住叫人泪目。最后他说：“罗根，我们的逐日号。”我想，他最后的期望可能只是想在一个不会伤害到别人的地方，跟自己最后一个学生，相依为命，度过生命中最后的时光。如果X战警是英雄的话，那X教授就是英雄的英雄，真正的传奇，一路走好，查尔斯·弗朗西斯·泽维尔。 金刚狼3是一部生与死的英雄史诗，老的英雄退幕，新生的英雄正走上历史的舞台，我相信本片如果以X教授为主角的话，其悲壮程度丝毫不会亚于老狼。X战警系列赋予了超级英雄大片肉还有血，而金刚狼3再次升华了一个阶段，拥有了更多灵魂，感谢让我看到了一部不一样的英雄大片。","categories":[{"name":"影评","slug":"影评","permalink":"https://shuangdeyu.github.io/categories/%E5%BD%B1%E8%AF%84/"}],"tags":[{"name":"电影","slug":"电影","permalink":"https://shuangdeyu.github.io/tags/%E7%94%B5%E5%BD%B1/"}]},{"title":"盘点高分韩国犯罪系列电影","slug":"盘点高分韩国犯罪系列电影","date":"2017-03-04T16:00:00.000Z","updated":"2023-12-22T09:39:35.441Z","comments":true,"path":"2017/03/05/pan-dian-gao-fen-han-guo-fan-zui-xi-lie-dian-ying/","link":"","permalink":"https://shuangdeyu.github.io/2017/03/05/pan-dian-gao-fen-han-guo-fan-zui-xi-lie-dian-ying/","excerpt":"","text":"我记得将我引入韩国犯罪系列片中的是《老男孩》这部电影，当时被这部电影的悬疑性，紧凑的剧情，和意想不到的结局深深吸引了，于是我的韩国犯罪电影之路算是萌芽了。 然而真正让我爱上这个系列的是电影《杀人回忆》，曾经在没有看网路上的分析的时候，我一天内就看了两遍，就为了找出电影中的凶手，然而两遍下来我还是毫无头绪，心痒之下便去网上寻找答案，这才了解到这部电影的背景和深意，发现原来韩国电影这么的牛逼。然后，便入了这个值得入的坑。 韩国犯罪电影往往取材于现实事件和社会现象，在刀光血影血肉模糊之下披露人性深层的罪恶和感情，然而又通俗易懂，使人一看就明白，就像去年上映的《釜山行》，里面的人物性格，人性的丑陋浅显易见，总给人一种我也想得出的感觉，或许这就是韩国电影的厉害之处，它能放大平时我们习以为常以至于不受重视的社会现象。 上正片：1、杀人回忆 豆瓣评分：8.5 根据韩国的三大未破解的奇案改编而成，开始节奏较慢，之后就让你无法自拔，生怕错过任何一个画面。让人感受到深深的无助 1986年，韩国京畿道华城郡，热得发昏的夏天，在田野边发现一具女尸，早已发臭，唯一可证实的是这具女尸生前被强奸过。两个月后以相同手法的杀人案相继出现。不过警方对这类连环凶杀案苦无头绪，导致人心惶惶。结果，警方决定成立调查小组去调查这一系列棘手案件。小镇警察朴探员和汉城来的苏探员接手案件， 线索的严重缺乏让毫无经验的朴探员和搭档曹探员只凭粗暴逼供和第六感推断，几次将犯罪嫌疑人屈打成招。而苏探员客观冷静，据理分析，几次排除嫌疑，警察内部为了证明与推翻矛盾不断，然而无辜女子还是接二连三被残忍杀害，他们只好达成共识一起合作。 2、那家伙的声音 豆瓣评分：7.4 根据韩国的三大未破解的奇案改编而成，为人父母的可能更能感受到那份绝望无助，韩国警察无能系列之一 电视台主播韩京培的儿子被绑架了，绑匪打来电话要求1亿韩元的赎金，京培不得讨价还价。京培与妻子智善都十分着急，无奈之下只好报警了，警方很快展开了调查。警方的高科技调查方式对于狡猾的罪犯来说根本起不了作用。唯一有用的证据便是绑匪打来电话时被录下了的嗓音。一把低沉而且毫无感情的嗓音。案情一直没有进展，京培与妻子连儿子的死活都不知道。于是京培决定自己出面，偷偷向绑匪提出见面的要求 3、青蛙少年失踪事件 豆瓣评分：7.4 根据韩国的三大未破解的奇案改编而成，一直找不到高清资源，所以还没看…… 1991年3月26日，韩国大邱。就读于城西小学的5个男孩子结伴上山，从此一去不回。该事件引起轩然大波，虽然警方出动上万搜查人员，却始终一无所获，孩子们的下落成为一个难以破解的谜团。4年后的一天，风光无限的电视制作人姜志胜因涉嫌造假而被总部流放至偏远的大邱，孤高气傲的他发现当地的人们依然关注那起已为很多人遗忘的“青蛙少年失踪案”。为了早日翻身，姜志胜与一直关注此案的黄教授携手，沉疴多年的案件似乎有了新的转机…… 4、我要复仇 豆瓣评分：7.9 复仇三部曲之一，有点心痛，明明都是善良的人，却意外成了仇人；叙事有点跳，前后看完才能全部知道，折射了一些社会现象 Ryu是名聋哑青年，自父母去世一直和姐姐相依为命。在特殊学校里，他遇上了装作失聪的女友，二人感情发展不错。可是姐姐却患上了绝症，需要移植肾脏以维持生命。他本想通过黑市以自己肾脏换取适合姐姐移植用的肾脏，却遭诈骗，损失自己肾脏外，还被骗去所有的钱。当有合适姐姐的肾脏时，他却没有医药费。女友提议他去绑架有钱人的小孩再索取赎金，并说这种绑架不算是罪过。他们看上了工厂老板东劲（宋康昊饰）的女儿，对离了婚的东劲而言，生命中最重要的就是女儿。遭绑架后，他并没有报警而是准备赎金以求换回女儿，由此展开了一段残酷的复仇史 5、老男孩 豆瓣评分：8.2 复仇三部曲之二，结局很震撼，命运弄人啊，全片的基调都是复仇，悬疑性也很好，很吸引人 女儿生日那天，中年男子吴大修在醉酒回家路上，突遭不明身份的人绑架失踪。就此，他毫无理由地被囚禁在一个神秘的私人监狱中。寻死未果的吴大修，每天看电视，三餐吃煎饺。通过电视，他得知妻子已遭杀害，女儿下落不明，自己更被怀疑为凶手。就此，吴大修开始锻炼身体，决心复仇，并在牢中度过漫长的15年…… 6、亲切的金子 豆瓣评分：7.6 复仇三部曲之三，画面有点文艺，比复仇更强烈的是亲情 金子20岁时，就因被控“诱拐儿童”入狱而成为头条新闻，人们惊诧于她的美貌、她的年轻。在13年的牢狱生活中，有着天使般容貌的她是狱中绝对的模范。金子尽心尽力地帮助身边的每一个人，因此狱友们都称她为“亲切的金子”。表面上金子似乎比谁都诚实守纪，但内心里的复仇火焰一天也没有熄灭。当金子出狱后，她还是马上展开复仇计划——它已经暗中策划准备了13年之久的，而狱友们也都在不同的地方帮助着她。 7、熔炉 豆瓣评分：9.2 也是根据真实事件改编，唯一一部不是因为烂而看不下去的电影，太虐了，因为这部片知道了男神孔侑；虽然有些黑暗宁可从不知道，但必须被知道。 来自首尔的哑语美术老师仁浩（孔宥饰）来到雾津，应聘慈爱聋哑人学校。天降大雾，他意外撞车，维修时邂逅了人权组织成员柔珍。仁浩妻子早亡，8岁女儿天生哮喘由祖母照看，所以他不辞辛苦谋职养家。然而，双胞胎的校长与教导主任竟逼仁浩索贿5千万韩元。同时，仁浩逐渐发现学校笼罩着一种紧张压抑的气氛，令人窒息。尤其有三个孩子引人关注：聪颖的金妍斗和贪吃的陈宥利总是躲闪。全民秀的弟弟自杀身亡，他总是满脸淤青。下课后，仁浩还听到女厕所中有呼喊与哭泣，在门卫的阻拦下他未深究。之后。他意外目睹了校长行贿警察，教导员毒打民秀，宿导溺罚妍斗的行径。一个惊天的隐秘被慢慢揭开，真相令韩国震惊…… 8、追击者 豆瓣评分：8.4 很有节奏感的一部电影，提着心看的，可惜不是我想看到的美好结局，韩国警察无能系列之一，这世界上是真的有杀人不咋眼的变态的 深夜的首尔街头，出租车上频频被插上写有电话的应召女郎的卡片。前刑警忠浩手下就有着一批应召女郎，表面粗暴野蛮的他，对姐妹们貌似毫不讲理。最近忠浩手下的姐妹频频发生失踪事件，他认为是有人故意把她们拐卖。暴跳如雷的他猛翻登记簿寻找蛛丝 马迹，最后确定了一个嫌疑电话尾数为4885。正好这个电话这时呼入需要应召女郎。忠浩让美珍前去。 正在家里发烧卧床的美珍想拒绝，无奈拗不过忠浩，留下七岁女儿在家后还是出门了。忠浩让她记住对方的地址并且用短信告诉他，叮嘱她别搞砸。忠浩亦同时尾随而去，想揪出这个拐卖贩子。美珍跟着4885池英民进入房间时发觉一切已经太迟，在这个毫无信号的地方，池英民要将她残忍杀害…… 9、黄海 豆瓣评分：8.4 节奏感同追击者类似，同一个导演的作品，造化弄人，过程令人感到心酸，结局更令人心酸，要结合影片描述的现实背景才能看懂 为了能让妻子去韩国打工，出租车司机久南（河正宇 Jeong-woo Ha饰）不惜借6万块钱的巨款。妻子已经有六个月没有消息了，久南每日只能用酒精和赌博来麻醉自己的神经。一天，在债主的介绍下，久南认识了绵先生。绵先生不仅愿意帮助他偷渡到韩国寻找妻子，而且愿意为他还掉所有的债务，条件是让他在首尔杀一个人。几经波折，久南最终渡过茫茫黄海到达首尔，然而要杀死被严密保护的对象并不那么容易，久南一边开始周密的计划，一边开始到处打听妻子的下落。妻子就像从人间消失了一样音讯全无，而并没有杀人的久南却因出现在凶案现场而成为警方通缉的疑犯。此时，由于怕买凶杀人的事情暴露，从延边赶来的绵先生也极力致久南于死地，久南几乎陷入绝望的境地…… 10、恐怖直播 豆瓣评分：8.7 把政府黑出了翔，而我天朝体制身体够开放了，思想却不开放；河正宇演技爆表，看着很舒服 韩国首尔某个平凡的早上，广播电台Daily Topic节目的主持人尹英华（河正宇饰）正就税率改革与听众进行连线，这时一个自称住在首尔昌信洞的普通工人朴鲁圭打入电话，大肆抱怨超高的电费和相关部门对他的威胁。尹英华颇不耐烦，以偏离主题为由强行切断电话。谁知连线无法单方面由电台方面中断，愤怒的朴鲁圭继续抱怨，并扬言炸掉汉江大桥。尹英华不以为然，进而怂恿对方想做就做，谁知话音刚落，窗外的麻浦大桥便炸作废墟。大惊失色的尹英华很快冷静下来，他决定利用这次难得的机会打一次事业的翻身仗。在他的主持下，针对恐怖分子的连线直播就此展开，无关良知的节目拉开帷幕…… 11、看见恶魔 豆瓣评分：7.5 有点小重口，干脆利落，有的人因为爱情，因为仇恨变成了恶魔，而恶魔也不是完全的泯灭人性，到底什么才是真正的恶魔，脱离法制，肆意妄为或许才是真正的恶魔，如果法不得当，那将是比恶魔更可怕的事情 供职于国情局的青年警员金秀贤（李秉宪饰）即将和心爱的女孩珠燕走入婚姻的殿堂，但是在一个飘雪之夜，独自驱车夜归的珠燕被人残忍杀害并分尸。秀贤痛不欲生，他找到四个主要嫌疑人的照片，开始独立追查凶手。经过一番调查，终于将目标锁定在为某学院包车的中年大叔张京哲（崔岷植饰）的身上。张生活坎坷，性格极度扭曲，他经常袭击夜归的女子，并将她们无情杀害。秀贤找到张的据点，对其进行残酷的惩罚，却最终手下留情。侥幸活命的张反而由此激发所有的兽性，一场野兽对野兽的修罗之战渐次激烈…… 12、不可饶恕 豆瓣评分：7.7 复仇解谜主题的电影，结局同样出人意料，感觉比《老男孩》震撼，尺度也比它大，但别的方面稍欠缺 一具被切分得支离破碎的女性尸体，前所未闻的连环杀人事件。国立科学搜查研究所要员姜民浩为了能腾出更多的时间陪伴与自己相依为命的女儿，与上司约定结束这个棘手案子后就放一段长假。死者吴恩雅生前是容貌美丽的女人，为酒吧坐台小姐，尸体缺了右手手臂。经他和具有天才推理能力的热血女警闵瑞英的联合调查，他们把杀人嫌疑锁定在李圣浩身上。 13、我是杀人犯 豆瓣评分：7.4 脑洞新奇，出人意料，一场联合捉凶的戏 17年前，社会上发生了一件影响极其恶劣的女子连环凶杀案，而崔向久则是负责此案的警探。狡猾的凶手巧妙的躲过了正义的天罗地网，当15年诉讼有效期到来的那一天，当凶手彻底的逃脱了法律制裁的那一天，受害者的家属以死发出了对无能警察以及残暴凶手的控诉。 正当大家以为惨剧带来的阴影即将消散之时，一本名为《我是杀人犯》的书的出版让所有的人都极为震惊，而书的作者不是别人，正是当年凶杀案的始作俑者李斗锡。可是，作为当年追捕凶手的警探，崔向久并不相信李斗锡就是当年的罪犯，一场激烈的猫鼠之争在两人之间展开。 14、假面 豆瓣评分：7.5 这部电影不能剧透，看下去，你会惊呆的，只能说，爱情真伟大 一名男子在他的公寓里被杀害了，警方在调查中发现死者乃是运动中心的富豪，现场唯一的线索是AB型男子的毛发。在调查中，怀疑的第一个对象是酒吧女，因为她曾在案发前给死者拨过电话。警员赵京尹前去调查取样。然而，京尹却从同事口中得知，情况另有变化。大家开始怀疑死者与游泳中心教练是同性恋。不过随后，这个犯罪嫌疑人也惨遭杀害。警员们开始怀疑是连环杀人案与死者服兵役的经历有关。与京尹一同调查的警员朴恩珠是他的警校同学，虽有假小子作风，内心却渴望被呵护，而且暗恋的对象便是京尹。不过，京尹却面临更复杂的感情选择，他有固定的女友，也有藕断丝连的情人。随着抽丝剥茧，京尹发现此案隐藏着一段童年的往事…… 15、奥罗拉公主 豆瓣评分：7.1 一个失去孩子的母亲的心碎复仇路，多少人利用精神病这个漏洞逃过法律的追责 一个可怜的小女孩在厕所里遭到后母虐打，这位后母随后被谋杀了。随后不断发生了连环神秘谋杀事件。凶手被锁定是一名女性，凶手留下的唯一线索是一幅奥罗拉公主贴画。吴警察越深入调查案件，便越觉得凶手是他的前妻郑顺贞。 这场连环杀人案件是一场复仇计划。多年前，郑顺贞与吴警察的只有6岁的女儿被奸杀碎尸，辩方律师却以凶手有精神问题为理由，使凶手躲过制裁…… 16、手机 豆瓣评分：6.7 有点科幻的味道，前面可能有点无聊，高潮在中后期，漏洞比较多，适合打发时间观看 2014年5月16日，在瑞草洞住宅区发生了杀人事件，高东浩的妻子赵妍秀被发现惨死家中，而凶手一直未能落网。东浩在妻子被杀害之后生活失意，整日颓废不振难以自拔，他唯一的女儿高景林也因父亲的消沉而备受折磨。一年后的某天，因为磁场异常，东浩发现自己竟然能和一年前的妻子通电话，并且从通话中得到了拯救妻子生命的线索，而给他的时间只有一天。东浩决心一定要抓住这个改变命运的机会，为了救出妻子展开孤军奋战。 17、七天 豆瓣评分：7.5 我发现韩影中以母亲这个视角展开的电影有好多啊，但不撕票的很少很少，这部就是 女律师刘智妍业务能力过人，保持着从未败诉的记录，她和女儿恩英一起生活，把所有的爱都倾注在后者身上。学校举办的运动会上，恩英在混乱的人流中被人绑走了。起初，刘智妍因为报警而遭到了绑匪的警告，第二天，刘智妍终于得知了绑匪的目的：他并非为钱，而是要求刘智妍为一个杀人嫌犯辩护。一个月前，一个年轻女子被人杀死在家中并遭弃尸，郑铁镇因为在现场留下了指纹和足迹成为最大嫌疑人，在一审中，郑铁镇被判死，眼下距离二审开庭只有四天时间，刘智妍找到深陷违纪案的小学同学金警官帮忙，迅速展开了对案情的调查，随着种种证据浮现，刘智妍发现此案确有蹊跷，而案件背后的隐情，更是只露出了冰山一角…… 18、彷徨之刃 豆瓣评分：7.1 改编自东野圭吾同名小说，很虐心，未成年犯罪立法在全世界可能都是一个难以解决的问题，东野圭吾好几部小说都有揭示这个现象 胜贤怎么也想不到，自己那乖巧可爱的女儿李秀珍会以一具冰冷的尸体的形式躺在自己的面前，然而事实已经发生，无法改变，李秀珍被卷入了一场谋杀案中，成为了案件里的受害者。 某日，痛苦的胜贤收到了一封神秘的信件，追随着信件中给出的线索，胜贤见到了女儿临死前最后的影响，绝望和愤怒之中，胜贤杀死了罪犯之一的哲勇，事件并没有就此结束，一位依然有杀害自己女儿的凶手逍遥法外。哲勇的死吸引了警方的注意，一直在调查李秀珍一案的刑警亿观展开了对于胜贤的追捕。 19、抓住那个家伙 豆瓣评分：7.9 又是一部以母亲为主角的电影，韩国人真的好爱用母亲这个角色来表达电影，类似套路的犯罪片，看的爽就好了 15年前，名叫西珍的小女孩遭人绑架杀害，重案组警官吴青浩虽答应西珍母亲一定将凶手绳之以法，无奈经过漫长的追查却始终一无所获。眼看追诉期将近，吴警官孤注一掷，结果与嫌疑人对面错过。在此之后，吴警官抱着遗憾离开警队，过起破罐破摔的颓废生活。而西珍妈妈始终不曾放弃追凶的信念，她凭借柔弱女子之躯展开独立调查，终于发现罪犯留下的蛛丝马迹。未过多久，又有一名小女孩在光天化日之下遭人绑架，其作案手法与西珍案件如出一辙，警方旋即布下天罗地网，与之展开周旋。而面对狡猾多端的嫌犯，警方只得再次请出闲赋家中的吴青浩。 小女孩命悬一线，西珍妈妈和吴青浩能否抓到犯人，一偿夙愿…… 20、母亲 豆瓣评分：8.3 可怜，伟大，而又可恶的母亲，电影总体平缓，需要耐心看，略心酸，电影也很有隐喻 因为儿子尹泰宇是智障，所以母亲总是担心他受伤。一天，泰宇被一辆奔驰车撞倒，朋友镇泰带他去高尔夫球场找打球的教授报仇，结果被带回了警局。因为镇泰踢坏了后视镜，教授向他们索赔，泰宇被当成了挡箭牌。 从警局出来后，在家吃过晚饭，泰宇去找镇泰喝酒，但此时镇泰趁着夜色回到球场找出了白天扔进湖中的球杆。泰宇酒后尾随一个名叫文雅中的女学生，结果第二天雅中的尸体就出现在屋顶。泰宇被当做唯一的嫌疑人带回了警局，接着在警察的威胁下画押认罪。得知儿子入狱，心急如焚的母亲委托著名律师为他翻案。但是，泰宇的病影响了他的记忆，母亲在替儿申冤的道路上步履蹒跚…… 21、回归 豆瓣评分：6.9 无意中放出了恶魔，以前就在想那些做手术的人要是突然麻醉失效会怎么样，我的话，宁可选择死亡 一次手术中，年幼的病人身上发生了可怕的麻醉觉醒事故。这恐怖的经历和巨大的疼痛让病人的性格发生了一百八十度的转变，甚至在出院后犯下了连杀数人的不可饶恕的罪过而被关入了精神病院。当然，这场事故的责任，被归于主刀医生，即柳在宇的父亲的身上。继病人在精神病院神秘失踪后，柳在宇的父亲也一蹶不振。 一转眼，25年过去了。就当众人以为事故带来的伤痛早已平息的时候，已经成年的病人再度现身了，围绕着他发生的，是又一连串的非法神秘事件。为了查明真相，柳在宇联合同事张植浩和江旭焕等人，对病人展开了调查和追捕。 22、邻居 豆瓣评分：7.4 啊啊啊啊，超爱金赛纶……讲了邻里乡亲合力对付变态杀人犯邻居的故事，要是我们周边住着这么一个邻居……细思极恐 城中发生连环凶杀案，每隔十天就有一人被杀，凶手将尸体装入旅行箱抛弃于荒郊。江山公寓202号的女孩就是第一个受害者，某日放学后突降暴雨，女孩搭乘邻居的车回家，岂料邻居竟然心怀不轨虐杀了小女孩。女孩的继母（金允珍饰）为此十分内疚，经常幻觉女孩回到家中。为了掩盖自己的犯罪事实，凶手不放过任何一个对他有怀疑的人，事件演变为连环杀人案。这时，令凶手最为惶恐的是另一个女孩的出现，这个女孩竟与之前遇害的女孩长相极为相似，凶手一边计划着杀掉她，一边陷入心魔无法自拔……","categories":[{"name":"影评","slug":"影评","permalink":"https://shuangdeyu.github.io/categories/%E5%BD%B1%E8%AF%84/"}],"tags":[{"name":"分享","slug":"分享","permalink":"https://shuangdeyu.github.io/tags/%E5%88%86%E4%BA%AB/"},{"name":"电影","slug":"电影","permalink":"https://shuangdeyu.github.io/tags/%E7%94%B5%E5%BD%B1/"}]},{"title":"来自日本的“七宗罪”","slug":"来自日本的“七宗罪”","date":"2017-02-25T16:00:00.000Z","updated":"2023-12-22T09:44:12.139Z","comments":true,"path":"2017/02/26/lai-zi-ri-ben-de-qi-zong-zui/","link":"","permalink":"https://shuangdeyu.github.io/2017/02/26/lai-zi-ri-ben-de-qi-zong-zui/","excerpt":"","text":"今天我要来安利一部日本的刑侦犯罪电影，说是安利，其实并不是因为这部电影有多么好，而是因为众多妹子（可能还有汉子）的老公出演了该片的男主角，他就是，男女老少通吃，戏路宽广，多才多艺，演什么像什么的日本当红影星——小栗旬。 首先，吸引我去看这部电影的是网上有一篇介绍，说这部电影是一部重口味的犯罪片，于是只要有这几个字就够了，我可是半资深重口味阅片无数者，真的是太投我所好了。 不过当看完电影的时候，我的感受是也就一般般吧，虽然有一些看着挺恶心的画面，但都是静物画面罢了，还没到不能下饭的地步，因为电影中并没有很清晰的施暴过程的镜头，也可能是我口味太重了吧，对于看过七部致命弯道，四部汉尼拔，下水道的美人鱼，人肉叉烧包，大部分韩国犯罪片如看见恶魔、老男孩、追击者等等电影的我来说，这种血肉模糊的画面已经不能引起我内心巨大的波动和心跳了。 本人唯一服的是欧美的虫子灾难片和黏糊糊恶心的外星异形片（不是异形系列）。 好了，回到正题上来吧，这种电影的套路无非就是警察抓贼，一步步解开谜题，引出犯人身世故事或警察背后的故事之类的，对于经常看韩国犯罪电影的同学来说，可能都能猜到下一步的情节发展了，而犯人也基本上都是些复仇者或者心理扭曲变态的杀人狂。 这里我有几个脑洞一直关不上，虽说为了情节需要不需要太较真，但不吐不快，我还是要说一下的： 1、为什么警察的战斗力往往这么弱，而犯人的战斗力爆表 2、为什么警察都喜欢在思考的时候抽烟 3、为什么犯人都好有钱，总是能搞到房车 话说，蛙男里的警察更渣的说，连基本的格斗技都没有。 关于电影里面的几个杀人手法，犯人在杀人之后都会留下一张纸条，指明被杀害者所犯的罪行，颇有点《七宗罪》的味道，但越往后，被杀害者的罪行就更牵强了，到最后则彻底沦为了心理变态，不过前期还是能给观众制造一些悬疑的味道的。 说到前期，我觉得这部电影前期还不错，有惊悚悬疑的成分，中期也还好，围绕着追捕犯罪者展开，至于后期，很多东西就有点生搬硬套了，还显得很乱，而且关于杀人犯的故事交代太少，看得人莫名其妙，只知道他小的时候父母被人分尸杀害了，然后现在他就成了变态杀人魔了，虽然我们也能理解凶手变成杀人魔的原因，但对于电影来说，还是略显突兀的。 更重要的是，凶手以为自己的杀人是在制造艺术，他为什么会有这个心理呢，难道就因为他父母生前是艺术收藏家？ 总的来说，电影节奏是紧凑的，不会让人感到无聊。 另一方面，这算是一部披着惊悚犯罪外皮的家庭教育片吧，电影的主干讲的是小栗旬主演的警察忙于工作，而忽视了妻儿的感情，套于犯罪之中，让经历劫难的警察明白家庭的重要性，让妻子知道丈夫工作的不容易，从而相互理解，万事皆休，和和睦睦。 从凶手的角度来说也是一样的，他从小失去父母，双胞胎妹妹又被别人收养了，而他应该是独自一人生活的（电影没有交待凶手父母遇害后凶手的经历），又患上了紫外线过敏，不能见到阳光，可以想象，这样一个长期独自生活在暗处的人，他的内心基本是不可能健康成长的，从侧面来讲，一个健康的家庭环境对一个小孩来说，是至关重要的。 而本片中，小栗旬也贡献了一个警察从无奈、无助、愤怒、绝望、崩溃、理解、幸福的变化的好演技，最后变成一个顾家的丈夫，不愧是你们的好老公。 总结，这是一部适合打发时间，看了又不会觉得浪费时间的电影。","categories":[{"name":"影评","slug":"影评","permalink":"https://shuangdeyu.github.io/categories/%E5%BD%B1%E8%AF%84/"}],"tags":[{"name":"电影","slug":"电影","permalink":"https://shuangdeyu.github.io/tags/%E7%94%B5%E5%BD%B1/"}]},{"title":"《生化危机.终章》完结撒花","slug":"《生化危机.终章》完结撒花","date":"2017-02-24T16:00:00.000Z","updated":"2023-12-22T09:44:18.243Z","comments":true,"path":"2017/02/25/sheng-hua-wei-ji.zhong-zhang-wan-jie-sa-hua/","link":"","permalink":"https://shuangdeyu.github.io/2017/02/25/sheng-hua-wei-ji.zhong-zhang-wan-jie-sa-hua/","excerpt":"","text":"大家好，我是打不死的小强，爱丽丝，真高兴又和大家见面了，这是我最后一次在荧幕耍帅打怪兽了(应该…吧)，没有什么想说的，就想说：“欢迎回家。” 生化危机从2002年上映到现在的终章上映，之间整整经过了15年，真不知道是它看着我们长大还是我们看着它成长，虽然成长的方向不尽如人意，但终归是有始有终，生化总算是画上了一个圆满的句号，给了影迷一个交代（虽然过程比较曲折，有兴趣的同学可以去网上搜一下电影拍摄过程中的两个大事故和一些花絮）。 电影一开始，我的第一感觉就是爱丽丝“老了”，虽然化过妆，但很明显能看到脸上的岁月痕迹，爱丽丝不是一开始那个肤白水嫩的爱丽丝了，而我们可能也不是15年前那个毛头小子了，难免有点唏嘘。这里的爱丽丝皮肤黝黑，身着便装，一看就是身经百战的模样，这也是电影中一个符合基本逻辑的细节之处，诚意还是有的，不过后面马上就要被一路虐过去了，除了心疼爱丽丝，我还想给编剧寄刀片。 随着电影的进行，我就要吐槽一下了，这压根跟第五部没什么联系啊，第五部完结的时候我还期待着第六部能看到爱丽丝率领着一队人马打各种各样的变异丧尸，然而终章里面别说打丧尸了，就连丧尸都没见着几只（种类），不过话说回来，这也在情理之中，终章本来就是要做个了断的，而这个了断不是和丧尸做，而是和一切的始作俑者保护伞公司做个了断，所以这也算是合情合理，只不过没有看到更多的丧尸镜头有点小遗憾而已。 附上本作boss级丧尸，也算是本作出现的新型丧尸，前作好像有匆匆一笔带过这个怪。 至于具体的剧情我就不说了，毕竟还有很多人没有看过，剧透可是要被打死的，其实剧情无非就是爱丽丝带着一对人马去保护伞玩闯关游戏罢了，很直线，但特效动作流畅，不像前一部那样老是放慢镜头，有水电影时长的嫌疑，此部的打斗戏看着可都是拳拳到肉的，我们的爱丽丝打了十年(电影世界的时长)丧尸，身手非常牛逼（不好意思，实在好不到文雅的形容词），特别是躲激光那段简直帅我一脸，惊险刺激，看的呼吸都停止了，女主角这么帅，也值得我们去电影院舔屏了，她最帅的一句话就是：“你就这点本事？”。 话说，超想看到爱丽丝爆发超能力啊。 终章从头到尾基本上都是在打斗中度过的，所以一直处在高潮中，不知不觉电影很快就结束了，这给人有点意犹未尽的感觉，抛去剧情之类的更深一层的要求，终章肯定是一部值得一看的电影，反正我是看的很爽。 话说槽点呢，肯定是有的，我觉得里面最让人想笑的是那个神一样的“作战预测软件”，当boss艾萨克斯介绍它的时候真的很像是在打广告，就是那种在别的科幻片中出现过的未来世界广告，瞬间很出戏好嘛，2333333。我只想说，这么好的软件，给我来一套。 而且，在这样一个末日片中来谈公司的股权问题，这就更出戏了，可能是我不了解老美的公司观念吧，反正一个坏事做尽的boss竟然会为了一个所谓的股东而不果断，这很不合逻辑，拜托你都干掉了她爸，那你为什么不早点干掉她呢，明知道她是和你作对的。 以上是我印象最深的两个槽点，至于好的地方，除了上面说到的打斗戏，动作戏外，我觉得最让人感动的是爱丽丝的身世了。下面可能有剧透，慎重观看，我尽量少写剧透内容。 我们知道爱丽丝总是处于失忆的状态，而且没有童年的记忆，这个坑在终章中也为我们填上了，答案就是：爱丽丝是克隆人，克隆人怎么会有童年的记忆呢。 电影的开头，爱丽丝就自述了自己的这一趟旅程就好像是自己的命运一样，她一直在寻找一个答案来告诉她到底是谁，所以这一仗她打了十年，现在终于找到了答案，她是保护伞公司大股东艾丽西亚的克隆人，T病毒的起源也跟艾丽西亚息息相关，最后帮助爱丽丝找到抗病毒素的人就是她，红后也是以她童年时的形象制造的，所以这一切的起源是艾丽西亚，只是我想不明白爱丽丝是为了什么而被克隆出来的。 她是克隆人，但比人类更有人性，就像影片中艾丽西亚说的：“克隆人变得比人类更有人性”。就算是艾萨克斯的克隆体，也比艾萨克斯本人更像人类，艾萨克斯本人心中只有欲望和野心，而他的克隆体会因为爱丽丝打败了他而生气地冒着生命危险带着活死人大军来找爱丽丝复仇，以至于最后反而帮了爱丽丝，所以这是很讽刺的，克隆人更有人性。 影片的最后，艾丽西亚本人随着保护伞公司灰飞烟灭，她是一切的起源，所以这也算是她最终的归宿吧，而她最后把自己童年的记忆给了爱丽丝，从此爱丽丝的记忆就完整了，身为观众，衷心的为她感到开心，但爱丽丝还是那个勇敢的爱丽丝，她可以是艾丽西亚，但艾丽西亚成不了爱丽丝。 结局当然是抗病毒素成功被释放了，但通过空气传播到全球需要一段时间，所以我们的爱丽丝的旅程还没有结束，她要去各地打怪兽，为了保护幸存的人类不受伤害。 最后，她骑在摩托车上笑了，这个笑容包含了很多，有开心，有胜利的喜悦，有解脱，也有对后面追来的怪物的不屑…… 好了，阅读理解到此为止，这是一部看了不会后悔的电影，完结撒花。","categories":[{"name":"影评","slug":"影评","permalink":"https://shuangdeyu.github.io/categories/%E5%BD%B1%E8%AF%84/"}],"tags":[{"name":"电影","slug":"电影","permalink":"https://shuangdeyu.github.io/tags/%E7%94%B5%E5%BD%B1/"}]},{"title":"一部成人向的国产良心动漫《疯味英雄》","slug":"一部成人向的国产良心动漫","date":"2017-02-11T16:00:00.000Z","updated":"2023-12-22T09:44:12.119Z","comments":true,"path":"2017/02/12/yi-bu-cheng-ren-xiang-de-guo-chan-liang-xin-dong-man/","link":"","permalink":"https://shuangdeyu.github.io/2017/02/12/yi-bu-cheng-ren-xiang-de-guo-chan-liang-xin-dong-man/","excerpt":"","text":"今天，我要安利一部绝对让你大跌眼镜，看了不会后悔的良心国产动画，哦不，严格意义上来说应该算是大半部分国产吧，但是，它的制作团队可是地地道道的国产——艺画天开，一个一鸣惊人的团队。这部动画的名字就叫做《疯味英雄》，看到名字是不是觉得很雷，很二，是不是有一种国产弱智儿童片的既视感，但是，不要被它的名字吓到了，豆瓣评分9.0，网上一片好评这就是它的战果，说实话，我第一次看到它也是抱着一种怀疑的态度，这个弱智的名字加上有点Q的动画封面一度让我想打退堂鼓，好在我进一步搜索了这部动画片在网络上的评价才决定点开一看，于是，我被感动了，一口气看完一季。上一次被国漫惊艳到还是看《大圣归来》的时候。 动画总共有13集，从刚开始的十几分钟一集，慢慢到二十几分钟一集，再到三十几分钟一集，最后一集更是达到了58分钟，从时长上来说也是满满的良心，绝对能让你持续高潮，不会秒射。 简单介绍一下剧情，就是伟大的先知在毁灭者肆虐下在一个名叫诺德林的星球上建造了屏障，来保护家园被毁灭者摧残的宇宙各种族，然后各族中的英雄会进入叫做竞技场的虚拟空间进行生死搏斗（有点像MOBA游戏，自行脑补），以此来磨练自己的技能，为了抵抗将来可能到来的灾难——毁灭者，直到一个竞技场的虚拟小兵——码奴拥有了自我意识和灵魂，故事由此展开。 有必要说明一下，动画里的英雄出自世界著名游戏公司暴雪旗下，所以这也就限制了它只能是一部同人作品，而不是纯粹的原创国漫，这点是比较可惜的，如果《疯味》的角色模型也是原创的话，那它绝对还可以在提升一个档次，其对于国漫的意义也将更加重大。 别看它画面这么Q，这可是一部真正的18禁动画，里面经常会出现一些少儿不宜的血腥暴力画面和污段子画面，女性角色的敏感部位的特写镜头更是刺激眼球，但是这并不影响它的内涵，它一点也不俗。简单概括，这是一部集搞笑、战斗、热血、深度于一体的动画，剧中人物模型设计精美细腻，各具特点，人物性格分明，塑造的很成功，而且还有各种好听合适的BGM，绝对是耳机控的福利，还有各种“神剧了”的桥段，让人直呼过瘾。总之，这不是一部儿童向的动画，未成年人慎看。 最重要的是这是一部有灵魂的深度动画。再华丽的外表就算没有灵魂，那也只会让人感到空洞，看过之后内心毫无波动，庆幸的是《疯味》不是，我总结了下这部剧大方向的两个所要表达的涵义，那就是自由和小人物的挣扎奋斗史，前者是全篇的主题，后者是剧情穿插的重要内容，这一切都是围绕我们的主角——一个本来任人宰割的码奴展开的。 先说后者吧，码奴本来是动画里最底层的存在，由于某些原因（这个原因这一季动画里还没交代）产生了自我意识并拥有了灵魂，于是展开了他对这个世界的规则的抗争，当然，刚开始他就像刚来到这个世界的婴儿，没有战斗的目的，茫然无知，只知道他不想作为一个码奴任人宰割，可是，在别的英雄眼中，码奴就是码奴，并不会因为你特别一点就成为了跟他们一样的英雄，就像德鲁伊嘲讽的那样：一介低等码奴，成天只会拿着一把废品冲出去送死，这点低等的战斗力，还妄想获得英雄称号；码奴就是码奴，既没有装备，更没有技能，只是系统虚拟出来，满足英雄杀戮的行尸走肉而已，你知道自己战斗的目的吗。 然后，码奴说：我不能有吗，如果可以战胜你。这里码奴的前后变化我觉得比较突兀，基本上没经过多少剧情的心里活动，码奴就像喝了鸡汤一样掷地有声的呐喊：下贱的杂碎也好，没有装备也好，不懂法术也好，就算已经如此，我也要战斗到底。 从码奴身上，我们很多人都很容易找到自己的影子，没有身世，没有英雄那样的天赋异禀，就是一个普普通通的人，很多时候都会茫然，不清楚自己奋斗的目的，一遍一遍自卑的说着自己就是个“码奴”。但是，今天是码奴不代表明天也是一个普通的码奴，《疯味》中的码奴做到了，他可以反杀英雄，就像英雄们屠杀码奴们一样，尽管在英雄心中他仍旧还是一个低微的码奴。我们既然做不成先天条件优越的英雄，那我们就成为一个前进的码奴，就像动画里说的：管他什么对与错，码奴生来只知道前进。 这里的英雄很奇特，他们在动画里所做的并不是拯救，而是杀戮，而杀戮的对象自然是没有自我意识的码奴们了，那个竞技场看似是追逐力量与荣耀的光明圣殿，实则是遭受痛苦与杀戮的凶残炼狱，不过英雄们愿意为了未知的危险一遍遍经历死亡与重生这点倒是让人觉得他们不是白白称作英雄的。 可是更多的，他们只是躲在屏障中苟且偷生的懦弱之徒，因为星球外有危机，因为害怕而迷信先知的屏障，一生都躲在诺德林，永远都活在自己对未来的恐惧之中，其实这根本不配称作英雄，而且还因为恐惧想方设法处死核心的bug——码奴，因为他们不愿相信那是核心的错误，这意味着灾难，他们就像关久了的猛虎，害怕走出保护他们的笼子。事实上，他们已经停止了前进，而没有停止前进，对自由渴望的码奴更像是一个能带领他们前进的英雄。 以上已经说到自由这个主题了，码奴被囚禁在核心系统中，而英雄们何尝不是被囚禁者呢，一辈子都生活在诺德林，没有勇气去探索星辰大海，英雄们都是自私的。最后码奴得出了他的结论，既然无法挣脱束缚，那就毁灭啊，毁灭阻挡在你身前的一切，这阻挡他获得自由的就是英雄们。 不禁让人想起魔兽的名言：兽人永不为奴。 这一季的故事到此也就结束了，留下了很多很多的坑，也首次完整展现了诺德林的庞大世界观，码奴可能会黑化向英雄们复仇，英雄之间的分歧也值得期待，总之，看完了还是意犹未尽，每一集都能让你感到惊艳，期待下一季的开播，顺带一提，《疯味》只是这个系列动画的前传。","categories":[{"name":"影评","slug":"影评","permalink":"https://shuangdeyu.github.io/categories/%E5%BD%B1%E8%AF%84/"}],"tags":[{"name":"动漫","slug":"动漫","permalink":"https://shuangdeyu.github.io/tags/%E5%8A%A8%E6%BC%AB/"}]},{"title":"三流但不末流《长城》","slug":"三流但不末流《长城》","date":"2017-02-10T16:00:00.000Z","updated":"2023-12-22T09:44:12.141Z","comments":true,"path":"2017/02/11/san-liu-dan-bu-mo-liu-chang-cheng/","link":"","permalink":"https://shuangdeyu.github.io/2017/02/11/san-liu-dan-bu-mo-liu-chang-cheng/","excerpt":"","text":"“所有不经过导演亲口认同的影评都是过分解读的阅读理解。” —— 沃.兹吉硕德。 在我心里，科幻/魔幻类(以下统称科幻)电影分为四个等级，像X战警前传三部曲这样又有特效剧情又有内涵的电影是一流科幻片；漫威这种看的很爽的爆米花类电影，剧情也流畅的，毛病少的是二流科幻片；那三流就是长城这样特效流畅，剧情一般老套，个别演员演技尴尬的电影了，类似的还有功夫之王；末流电影就是那些五毛特效，不知所云，看了开头就没有想看下去的欲望的电影的总和了，举几个例子有蒸发太平洋、一万年以后、清算日等；最后，那就是我称之为神级的电影了，我认为那些开创一个现象级电影系列的和剧情内涵特效演技等等各方面都让人看得津津有味的电影可以称为神级，大家所熟知的就有异形、星球大战、哈利波特、蝙蝠侠黑暗骑士、守望者、骇客帝国、生化危机等电影，当然这些电影中有些严格来说属于一流的科幻电影，但它开创了一个现象级系列片，所以它的地位是不可代替的。我认为，以上三流的电影算是烂片但绝不是完全的烂，顶多算是俗，末流的那些才是真正的烂，二流及以上的就算是好片了。 再说长城，虽然槽点满满，但里面也有感人的地方，接下来就让我们分别来分析一下。 首先是槽点，无影禁军分为五个军系，但看完一遍我好像只记得蓝色的送死兵和红色的弓箭兵的具体功能，剩下的三军好像都是肉搏的，吧，而且分成五个军系完全不合理嘛，饕餮在城下，那就射箭打，上城了那就近身战，两个就够了嘛，算了，一切为了电影效果。 然后，明明是东方玄幻片，硬塞几个外国人进来，很出戏，有没有，有没有，没办法，中外合拍片嘛，打怪兽还是歪果仁比较在行。 皇帝和大臣的处理，虽说为了表现皇宫内部的腐败奢靡和无影禁军的无私奉献，但把皇宫内的众人演的这么弱智未免也太敷衍了，没吃过猪肉总见过猪跑吧，饕餮都涌入了京城了，皇帝你还要靠无影军打怪兽呢，还一点都不尊重他们，是我就把你喂了饕餮。 还有，饕餮你就不能等打完仗了再进食？有可能是饿了60年，所以迫不及待了吧，这就是不作不die。 再说感人的地方，送别殿帅，长城夜放孔明灯，敲鼓奏歌的场景的确是看得人心有所触，满满的悲壮确实让人感受到了，让人不禁想起驻守边关的古今将士，还有片尾鹿晗的回眸和军师的牺牲都让人产生共鸣，这就是所谓的牺牲小我，成就大我吧，我想这也是本片要表现的主题。就这两点吧，别的地方还真没有触动到我。 总得来说，长城就是一部爆米花电影，只是看的不是很爽，元素内容太多往往浅尝辄止，因为一部电影的时间是很有限的，长城就是如此，里面很多东方元素都是蜻蜓点水露了个面，所以看起来是一部大杂烩，并没有给人意犹未尽的感觉，而是莫名其妙。如果喜欢看东方玄幻元素的倒是值得一看，虽然有点烂，但并不是一无是处，希望大家把争议带到电影中，而不是某个演员，除非，他演的是真的很尴尬。","categories":[{"name":"影评","slug":"影评","permalink":"https://shuangdeyu.github.io/categories/%E5%BD%B1%E8%AF%84/"}],"tags":[{"name":"电影","slug":"电影","permalink":"https://shuangdeyu.github.io/tags/%E7%94%B5%E5%BD%B1/"}]}],"categories":[{"name":"小说","slug":"小说","permalink":"https://shuangdeyu.github.io/categories/%E5%B0%8F%E8%AF%B4/"},{"name":"读书","slug":"读书","permalink":"https://shuangdeyu.github.io/categories/%E8%AF%BB%E4%B9%A6/"},{"name":"技术","slug":"技术","permalink":"https://shuangdeyu.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"影评","slug":"影评","permalink":"https://shuangdeyu.github.io/categories/%E5%BD%B1%E8%AF%84/"},{"name":"生活","slug":"生活","permalink":"https://shuangdeyu.github.io/categories/%E7%94%9F%E6%B4%BB/"},{"name":"闲谈","slug":"闲谈","permalink":"https://shuangdeyu.github.io/categories/%E9%97%B2%E8%B0%88/"},{"name":"游戏","slug":"游戏","permalink":"https://shuangdeyu.github.io/categories/%E6%B8%B8%E6%88%8F/"},{"name":"资源","slug":"资源","permalink":"https://shuangdeyu.github.io/categories/%E8%B5%84%E6%BA%90/"}],"tags":[{"name":"武侠","slug":"武侠","permalink":"https://shuangdeyu.github.io/tags/%E6%AD%A6%E4%BE%A0/"},{"name":"经典","slug":"经典","permalink":"https://shuangdeyu.github.io/tags/%E7%BB%8F%E5%85%B8/"},{"name":"余华","slug":"余华","permalink":"https://shuangdeyu.github.io/tags/%E4%BD%99%E5%8D%8E/"},{"name":"工具书","slug":"工具书","permalink":"https://shuangdeyu.github.io/tags/%E5%B7%A5%E5%85%B7%E4%B9%A6/"},{"name":"Go","slug":"Go","permalink":"https://shuangdeyu.github.io/tags/Go/"},{"name":"PDF","slug":"PDF","permalink":"https://shuangdeyu.github.io/tags/PDF/"},{"name":"vue","slug":"vue","permalink":"https://shuangdeyu.github.io/tags/vue/"},{"name":"电影","slug":"电影","permalink":"https://shuangdeyu.github.io/tags/%E7%94%B5%E5%BD%B1/"},{"name":"生活","slug":"生活","permalink":"https://shuangdeyu.github.io/tags/%E7%94%9F%E6%B4%BB/"},{"name":"docker","slug":"docker","permalink":"https://shuangdeyu.github.io/tags/docker/"},{"name":"etcd","slug":"etcd","permalink":"https://shuangdeyu.github.io/tags/etcd/"},{"name":"database","slug":"database","permalink":"https://shuangdeyu.github.io/tags/database/"},{"name":"mac","slug":"mac","permalink":"https://shuangdeyu.github.io/tags/mac/"},{"name":"k8s","slug":"k8s","permalink":"https://shuangdeyu.github.io/tags/k8s/"},{"name":"CI/CD","slug":"CI-CD","permalink":"https://shuangdeyu.github.io/tags/CI-CD/"},{"name":"Mysql","slug":"Mysql","permalink":"https://shuangdeyu.github.io/tags/Mysql/"},{"name":"经验","slug":"经验","permalink":"https://shuangdeyu.github.io/tags/%E7%BB%8F%E9%AA%8C/"},{"name":"总结","slug":"总结","permalink":"https://shuangdeyu.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"Nintendo","slug":"Nintendo","permalink":"https://shuangdeyu.github.io/tags/Nintendo/"},{"name":"工具","slug":"工具","permalink":"https://shuangdeyu.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"linux","slug":"linux","permalink":"https://shuangdeyu.github.io/tags/linux/"},{"name":"软件技术","slug":"软件技术","permalink":"https://shuangdeyu.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"},{"name":"Rabbitmq","slug":"Rabbitmq","permalink":"https://shuangdeyu.github.io/tags/Rabbitmq/"},{"name":"爬虫","slug":"爬虫","permalink":"https://shuangdeyu.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"分享","slug":"分享","permalink":"https://shuangdeyu.github.io/tags/%E5%88%86%E4%BA%AB/"},{"name":"lua","slug":"lua","permalink":"https://shuangdeyu.github.io/tags/lua/"},{"name":"cron","slug":"cron","permalink":"https://shuangdeyu.github.io/tags/cron/"},{"name":"Gin","slug":"Gin","permalink":"https://shuangdeyu.github.io/tags/Gin/"},{"name":"gitlab","slug":"gitlab","permalink":"https://shuangdeyu.github.io/tags/gitlab/"},{"name":"动漫","slug":"动漫","permalink":"https://shuangdeyu.github.io/tags/%E5%8A%A8%E6%BC%AB/"},{"name":"svn","slug":"svn","permalink":"https://shuangdeyu.github.io/tags/svn/"},{"name":"感想","slug":"感想","permalink":"https://shuangdeyu.github.io/tags/%E6%84%9F%E6%83%B3/"},{"name":"hexo","slug":"hexo","permalink":"https://shuangdeyu.github.io/tags/hexo/"}]}